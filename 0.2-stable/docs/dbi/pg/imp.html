<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<title>dbi.pg.imp</title>
	<style type="text/css">
		.underline {
			text-decoration: underline;
		}

		.big {
			font-size: larger;
		}

		.small {
			font-size: smaller;
		}

		.red {
			color: red;
		}

		.blue {
			color: blue;
		}

		.green {
			color: green;
		}

		.yellow {
			color: yellow;
		}

		.black {
			color: black;
		}

		.white {
			color: white;
		}
	</style>
</head>
<body>
<h1>dbi.pg.imp</h1>
<!-- Generated by Ddoc from dbi\pg\imp.d -->
<p>PostgreSQL import library.
</p>
<p>Part of the D DBI project.

</p>
<p><strong>Version:</strong><br />PostgreSQL version 8.2.1
<br /><br />

	Import library version 1.04

</p>
<p><strong>Authors:</strong><br />The D DBI project

</p>

<dl><dt><span class="big">alias <span class="underline">pqbool</span>;
</span></dt>
<dd><p>This type is used with PQprint because C doesn't have a true boolean type.
 
</p>

</dd>
<dt><span class="big">typedef <span class="underline">Oid</span>;
</span></dt>
<dd><p>Object ID is a fundamental type in PostgreSQL.
 
</p>

</dd>
<dt><span class="big">const Oid <span class="underline">InvalidOid</span>;
</span></dt>
<dd><p><span class="underline">InvalidOid</span> indicates that something went wrong.  Try checking for errors.
 
</p>

</dd>
<dt><span class="big">deprecated const Oid <span class="underline">OID_MAX</span>;
</span></dt>
<dd><p><span class="red">Deprecated:</span><br />Use Oid.max directly.
 
</p>

</dd>
<dt><span class="big">const uint <span class="underline">NAMEDATALEN</span>;
</span></dt>
<dd><p>This is the max length for system identifiers.  It must be a multiple of int.sizeof.
</p>
<p>Databases with different <span class="underline">NAMEDATALEN</span> values cannot interoperate!
 
</p>

</dd>
<dt><span class="big">const char <span class="underline">PG_DIAG_SEVERITY</span>;
</span></dt>
<dd><p>Identifiers of error message fields.
 
</p>

</dd>
<dt><span class="big">const uint <span class="underline">INV_WRITE</span>;
</span></dt>
<dd><p>Read/write mode flags for inversion (large object) calls.
 
</p>

</dd>
<dt><span class="big">const char[] <span class="underline">PQnoPasswordSupplied</span>;
</span></dt>
<dd><p>Define the string so all uses are consistent.
 
</p>

</dd>
<dt><span class="big"><span class="underline">SEEK_SET</span></span></dt>
<dd><p>Start seeking from the start.
</p>

</dd>
<dt><span class="big"><span class="underline">SEEK_CUR</span></span></dt>
<dd><p>Start seeking from the current position.
</p>

</dd>
<dt><span class="big"><span class="underline">SEEK_END</span></span></dt>
<dd><p>Start seeking from the end.
</p>

</dd>
<dt><span class="big">enum <span class="underline">ConnStatusType</span>;
</span></dt>
<dd><p><span class="underline">ConnStatusType</span> is the structure that describes the current status of the
 connection to the server.
 
</p>

<dl><dt><span class="big"><span class="underline">CONNECTION_OK</span></span></dt>
<dd><p>Everything is working.
</p>

</dd>
<dt><span class="big"><span class="underline">CONNECTION_BAD</span></span></dt>
<dd><p>Error in the connection.
</p>

</dd>
<dt><span class="big"><span class="underline">CONNECTION_STARTED</span></span></dt>
<dd><p>Waiting for connection to be made.
</p>

</dd>
<dt><span class="big"><span class="underline">CONNECTION_MADE</span></span></dt>
<dd><p>Connection OK; waiting to send.
</p>

</dd>
<dt><span class="big"><span class="underline">CONNECTION_AWAITING_RESPONSE</span></span></dt>
<dd><p>Waiting for a response from the postmaster.
</p>

</dd>
<dt><span class="big"><span class="underline">CONNECTION_AUTH_OK</span></span></dt>
<dd><p>Received authentication; waiting for backend startup.
</p>

</dd>
<dt><span class="big"><span class="underline">CONNECTION_SETENV</span></span></dt>
<dd><p>Negotiating environment.
</p>

</dd>
<dt><span class="big"><span class="underline">CONNECTION_SSL_STARTUP</span></span></dt>
<dd><p>Negotiating SSL.
</p>

</dd>
<dt><span class="big"><span class="underline">CONNECTION_NEEDED</span></span></dt>
<dd><p>Internal state: connect() needed.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">enum <span class="underline">PostgresPollingStatusType</span>;
</span></dt>
<dd><p><span class="underline">PostgresPollingStatusType</span> is the structure that describes the current status of a non-blocking command.
 
</p>

<dl><dt><span class="big"><span class="underline">PGRES_POLLING_FAILED</span></span></dt>
<dd><p>Something went wrong.
</p>

</dd>
<dt><span class="big"><span class="underline">PGRES_POLLING_READING</span></span></dt>
<dd><p>You may use select before polling again.
</p>

</dd>
<dt><span class="big"><span class="underline">PGRES_POLLING_WRITING</span></span></dt>
<dd><p>You may use select before polling again.
</p>

</dd>
<dt><span class="big"><span class="underline">PGRES_POLLING_OK</span></span></dt>
<dd><p>The work has been completed.
</p>

</dd>
<dt><span class="big"><span class="underline">PGRES_POLLING_ACTIVE</span></span></dt>
<dd><p>Unused; keep for awhile for backwards compatibility.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">enum <span class="underline">ExecStatusType</span>;
</span></dt>
<dd><p><span class="underline">ExecStatusType</span> is the structure that describes the results.
 
</p>

<dl><dt><span class="big"><span class="underline">PGRES_EMPTY_QUERY</span></span></dt>
<dd><p>Empty query string was executed.
</p>

</dd>
<dt><span class="big"><span class="underline">PGRES_COMMAND_OK</span></span></dt>
<dd><p>A query command that doesn't return anything was executed properly by the backend.
</p>

</dd>
<dt><span class="big"><span class="underline">PGRES_TUPLES_OK</span></span></dt>
<dd><p>A query command that returns tuples was executed properly by the backend, PGresult contains the result tuples.
</p>

</dd>
<dt><span class="big"><span class="underline">PGRES_COPY_OUT</span></span></dt>
<dd><p>Copy Out data transfer in progress.
</p>

</dd>
<dt><span class="big"><span class="underline">PGRES_COPY_IN</span></span></dt>
<dd><p>Copy In data transfer in progress.
</p>

</dd>
<dt><span class="big"><span class="underline">PGRES_BAD_RESPONSE</span></span></dt>
<dd><p>An unexpected response was received from the backend.
</p>

</dd>
<dt><span class="big"><span class="underline">PGRES_NONFATAL_ERROR</span></span></dt>
<dd><p>Notice or warning message.
</p>

</dd>
<dt><span class="big"><span class="underline">PGRES_FATAL_ERROR</span></span></dt>
<dd><p>Query failed.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">enum <span class="underline">PGTransactionStatusType</span>;
</span></dt>
<dd><p><span class="underline">PGTransactionStatusType</span> is the structure that describes the current status of the transaction.
 
</p>

<dl><dt><span class="big"><span class="underline">PQTRANS_IDLE</span></span></dt>
<dd><p>Connection idle.
</p>

</dd>
<dt><span class="big"><span class="underline">PQTRANS_ACTIVE</span></span></dt>
<dd><p>Command in progress.
</p>

</dd>
<dt><span class="big"><span class="underline">PQTRANS_INTRANS</span></span></dt>
<dd><p>Idle, within transaction block.
</p>

</dd>
<dt><span class="big"><span class="underline">PQTRANS_INERROR</span></span></dt>
<dd><p>Idle, within failed transaction.
</p>

</dd>
<dt><span class="big"><span class="underline">PQTRANS_UNKNOWN</span></span></dt>
<dd><p>Cannot determine status.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">enum <span class="underline">PGVerbosity</span>;
</span></dt>
<dd><p><span class="underline">PGVerbosity</span> is the structure that describes how verbose error message should be.
 
</p>

<dl><dt><span class="big"><span class="underline">PQERRORS_TERSE</span></span></dt>
<dd><p>Single-line error messages.
</p>

</dd>
<dt><span class="big"><span class="underline">PQERRORS_DEFAULT</span></span></dt>
<dd><p>Recommended style.
</p>

</dd>
<dt><span class="big"><span class="underline">PQERRORS_VERBOSE</span></span></dt>
<dd><p>All the facts.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">struct <span class="underline">PGconn</span>;
</span></dt>
<dd><p><span class="underline">PGconn</span> encapsulates a connection to the backend.
</p>
<p>The contents of this struct are not supposed to be known to applications.
 
</p>

<dl></dl>
</dd>
<dt><span class="big">struct <span class="underline">PGresult</span>;
</span></dt>
<dd><p><span class="underline">PGresult</span> encapsulates the result of a query (or more precisely, of a single
 SQL command --- a query string given to PQsendQuery can contain multiple
 commands and thus return multiple <span class="underline">PGresult</span> objects).
</p>
<p>The contents of this struct are not supposed to be known to applications.
 
</p>

<dl></dl>
</dd>
<dt><span class="big">struct <span class="underline">PGcancel</span>;
</span></dt>
<dd><p><span class="underline">PGcancel</span> encapsulates the information needed to cancel a running
 query on an existing connection.
</p>
<p>The contents of this struct are not supposed to be known to applications.
 
</p>

<dl></dl>
</dd>
<dt><span class="big">struct <span class="underline">pgNotify</span>;
</span></dt>
<dd><p>PGnotify represents the occurrence of a NOTIFY message.
</p>
<p>Ideally this would be an opaque typedef, but it's so simple that it's
 unlikely to change.

</p>
<strong>Note:</strong>
In Postgres 6.4 and later, the be_pid is the notifying backend's,
 whereas in earlier versions it was always your own backend's PID.
 


<dl><dt><span class="big">char* <span class="underline">relname</span>;
</span></dt>
<dd><p>Notification condition name.
</p>

</dd>
<dt><span class="big">int <span class="underline">be_pid</span>;
</span></dt>
<dd><p>Process ID of notifying server process.
</p>

</dd>
<dt><span class="big">char* <span class="underline">extra</span>;
</span></dt>
<dd><p>Notification parameter.
</p>

</dd>
<dt><span class="big">pgNotify * <span class="underline">next</span>;
</span></dt>
<dd><p>List link.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">alias <span class="underline">PQnoticeReceiver</span>;
</span></dt>
<dd><p>Function types for notice-handling callbacks.
 
</p>

</dd>
<dt><span class="big">struct <span class="underline">_PQprintOpt</span>;
</span></dt>
<dd><p>Print options for PQprint().
 
</p>

<dl><dt><span class="big">byte <span class="underline">header</span>;
</span></dt>
<dd><p>Print output field headings and row count.
</p>

</dd>
<dt><span class="big">byte <span class="underline">alignment</span>;
</span></dt>
<dd><p>Fill align the fields.
</p>

</dd>
<dt><span class="big">byte <span class="underline">standard</span>;
</span></dt>
<dd><p>Old brain dead format.
</p>

</dd>
<dt><span class="big">byte <span class="underline">html3</span>;
</span></dt>
<dd><p>Output html tables.
</p>

</dd>
<dt><span class="big">byte <span class="underline">expanded</span>;
</span></dt>
<dd><p>Expand tables.
</p>

</dd>
<dt><span class="big">byte <span class="underline">pager</span>;
</span></dt>
<dd><p>Use <span class="underline">pager</span> for output if needed.
</p>

</dd>
<dt><span class="big">char* <span class="underline">fieldSep</span>;
</span></dt>
<dd><p>Field separator.
</p>

</dd>
<dt><span class="big">char* <span class="underline">tableOpt</span>;
</span></dt>
<dd><p>Insert a table in HTML.
</p>

</dd>
<dt><span class="big">char* <span class="underline">caption</span>;
</span></dt>
<dd><p>Insert a <span class="underline">caption</span> in HTML.
</p>

</dd>
<dt><span class="big">char** <span class="underline">fieldName</span>;
</span></dt>
<dd><p>Null terminated array of replacement field names.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">struct <span class="underline">_PQconninfoOption</span>;
</span></dt>
<dd><p>Structure for the conninfo parameter definitions returned by PQconndefaults
</p>
<p>All fields except "val" point at static strings which must not be altered.
 "val" is either NULL or a malloc'd current-value string.  PQconninfoFree()
 will release both the val strings and the PQconninfoOption array itself.
 
</p>

<dl><dt><span class="big">char* <span class="underline">keyword</span>;
</span></dt>
<dd><p>The <span class="underline">keyword</span> of the option.
</p>

</dd>
<dt><span class="big">char* <span class="underline">envvar</span>;
</span></dt>
<dd><p>Fallback environment variable name.
</p>

</dd>
<dt><span class="big">char* <span class="underline">compiled</span>;
</span></dt>
<dd><p>Fallback <span class="underline">compiled</span> in default value.
</p>

</dd>
<dt><span class="big">char* <span class="underline">val</span>;
</span></dt>
<dd><p>Option's current value, or <strong>null</strong>.
</p>

</dd>
<dt><span class="big">char* <span class="underline">label</span>;
</span></dt>
<dd><p>Label for field in connect dialog.
</p>

</dd>
<dt><span class="big">char* <span class="underline">dispchar</span>;
</span></dt>
<dd><p>Character to display for this field in a connect dialog. Values are: "" Display entered value as is "*" Password field - hide value "D"  Debug option - don't show by default.
</p>

</dd>
<dt><span class="big">int <span class="underline">dispsize</span>;
</span></dt>
<dd><p>Field size in characters for dialog.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">struct <span class="underline">PQArgBlock</span>;
</span></dt>
<dd><p><span class="underline">PQArgBlock</span> is the structure used for PQfn arguments.
</p>
<p><span class="red">Deprecated:</span><br />This is only used for PQfn and that is deprecated.
 
</p>

<dl></dl>
</dd>
<dt><span class="big">PGconn * <span class="underline">PQconnectStart</span>(char* <em>conninfo</em>);
</span></dt>
<dd><p>Make a new connection to the database server in a nonblocking manner.
</p>
<strong>Params:</strong><br /><table><tr><td>char* <em>conninfo</em></td>
<td>Parameters to use when connecting.</td></tr>
</table>
<p><strong>Returns:</strong><br />A PostgreSQL connection that is inactive.

</p>
<p><strong>See Also:</strong><br />The online PostgreSQL documentation describes what you can use in <em>conninfo</em>.
 
</p>

</dd>
<dt><span class="big">PostgresPollingStatusType <span class="underline">PQconnectPoll</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Get the current status of the nonblocking PostgreSQL connection.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The nonblocking PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />A PostgrePollingStatusType describing the current condition of the connection.
 
</p>

</dd>
<dt><span class="big">PGconn * <span class="underline">PQconnectdb</span>(char* <em>conninfo</em>);
</span></dt>
<dd><p>Make a new connection to the database server in a blocking manner.
</p>
<strong>Params:</strong><br /><table><tr><td>char* <em>conninfo</em></td>
<td>Parameters to use when connecting.</td></tr>
</table>
<p><strong>Returns:</strong><br />The PostgreSQL connection.

</p>
<p><strong>See Also:</strong><br />The online PostgreSQL documentation describes what you can use in <em>conninfo</em>.
 
</p>

</dd>
<dt><span class="big">PGconn * <span class="underline">PQsetdbLogin</span>(char* <em>pghost</em>, char* <em>pgport</em>, char* <em>pgoptions</em>, char* <em>pgtty</em>, char* <em>dbName</em>, char* <em>login</em>, char* <em>pwd</em>);
</span></dt>
<dd><p>Make a new connection to the database server in a blocking manner.
</p>
<p><span class="red">Deprecated:</span><br />Although this isn't actually deprecated, it is preferred that you use PQconnectdb.

</p>
<strong>Params:</strong><br /><table><tr><td>char* <em>pghost</em></td>
<td>Name of the host to connect to.  Defaults to either a Unix socket or localhost.</td></tr>
<tr><td>char* <em>pgport</em></td>
<td>Port number to connect to the server with.  Defaults to nothing.</td></tr>
<tr><td>char* <em>pgoptions</em></td>
<td>Command line options to send to the server.  Defaults to nothing.</td></tr>
<tr><td>char* <em>pgtty</em></td>
<td>Currently ignored.</td></tr>
<tr><td>char* <em>dbName</em></td>
<td>The name of the database to use.  Defaults to <em>login</em>.</td></tr>
<tr><td>char* <em>login</em></td>
<td>Username to authenticate with.  Defaults to the current OS username.</td></tr>
<tr><td>char* <em>pwd</em></td>
<td>Password to authenticate with.</td></tr>
</table>
<p><strong>Returns:</strong><br />The PostgreSQL connection.
 
</p>

</dd>
<dt><span class="big">deprecated void <span class="underline">PQsetdb</span>(char* <em>M_PGHOST</em>, char* <em>M_PGPORT</em>, char* <em>M_PGOPT</em>, char* <em>M_PGTTY</em>, char* <em>M_DBNAME</em>);
</span></dt>
<dd><p>Make a new connection to the database server in a blocking manner.
</p>
<p><span class="red">Deprecated:</span><br />This is deprecated in favor of PQsetdbLogin, but PQconnectdb is an even better choice.

</p>
<strong>Params:</strong><br /><table><tr><td>pghost</td>
<td>Name of the host to connect to.  Defaults to either a Unix socket or localhost.</td></tr>
<tr><td>pgport</td>
<td>Port number to connect to the server with.  Defaults to nothing.</td></tr>
<tr><td>pgoptions</td>
<td>Command line options to send to the server.  Defaults to nothing.</td></tr>
<tr><td>pgtty</td>
<td>Currently ignored.</td></tr>
<tr><td>dbName</td>
<td>The name of the database to use.  Defaults to the login username.</td></tr>
</table>
<p><strong>Returns:</strong><br />The PostgreSQL connection.
 
</p>

</dd>
<dt><span class="big">void <span class="underline">PQfinish</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Close the PostgreSQL connection and free the memory it used.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>

</dd>
<dt><span class="big">_PQconninfoOption * <span class="underline">PQconndefaults</span>();
</span></dt>
<dd><p>Get the default connection options.
</p>
<p><strong>Returns:</strong><br />A PQconninfoOption structure with all of the default values filled in.
 
</p>

</dd>
<dt><span class="big">void <span class="underline">PQconninfoFree</span>(_PQconninfoOption * <em>connOptions</em>);
</span></dt>
<dd><p>Free the memory used by a PQconninfoOption structure.
</p>
<strong>Params:</strong><br /><table><tr><td>_PQconninfoOption * <em>connOptions</em></td>
<td>The PQconnifoOption structure to erase.</td></tr>
</table>

</dd>
<dt><span class="big">int <span class="underline">PQresetStart</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Reset the connection to PostgreSQL in a nonblocking manner.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />1 on success and 0 on failure.
 
</p>

</dd>
<dt><span class="big">PostgresPollingStatusType <span class="underline">PQresetPoll</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Get the current status of the nonblocking reset of the PostgreSQL connection.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />A PostgrePollingStatusType describing the current condition of the connection.
 
</p>

</dd>
<dt><span class="big">void <span class="underline">PQreset</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Reset the connection to PostgreSQL in a blocking manner.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>

</dd>
<dt><span class="big">PGcancel * <span class="underline">PQgetCancel</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Create the structure used to cancel commands.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />The PGcancel structure on success or <strong>null</strong> on failure.
 
</p>

</dd>
<dt><span class="big">void <span class="underline">PQfreeCancel</span>(PGcancel * <em>cancel</em>);
</span></dt>
<dd><p>Free the memory used by a PGcancel structure.
</p>
<strong>Params:</strong><br /><table><tr><td>PGcancel * <em>cancel</em></td>
<td>The PGcancel structure to erase.</td></tr>
</table>

</dd>
<dt><span class="big">int <span class="underline">PQcancel</span>(PGcancel * <em>cancel</em>, char* <em>errbuf</em>, int <em>errbufsize</em>);
</span></dt>
<dd><p>Request that the server stops processing the current command.
</p>
<strong>Params:</strong><br /><table><tr><td>PGcancel * <em>cancel</em></td>
<td>The PGcancel structure returned by PQgetCancel.</td></tr>
<tr><td>char* <em>errbuf</em></td>
<td>A buffer to place the reason <span class="underline">PQcancel</span> failed in.</td></tr>
<tr><td>int <em>errbufsize</em></td>
<td>The size of <em>errbuf</em>.  The recommended size is 256.</td></tr>
</table>
<p><strong>Returns:</strong><br />1 on success and 0 on failure.
 
</p>

</dd>
<dt><span class="big">deprecated int <span class="underline">PQrequestCancel</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Request that the server stops processing the current command.
</p>
<p><span class="red">Deprecated:</span><br />PQcancel should be used instead because it is thread-safe.

</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>

</dd>
<dt><span class="big">char* <span class="underline">PQdb</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Get the name of the database used in the connection.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />The database name.
 
</p>

</dd>
<dt><span class="big">char* <span class="underline">PQuser</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Get the username used in the connection.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />The username.
 
</p>

</dd>
<dt><span class="big">char* <span class="underline">PQpass</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Get the password used in the connection.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />The password.
 
</p>

</dd>
<dt><span class="big">char* <span class="underline">PQhost</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Get the server host name used in the connection.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />The server host name.
 
</p>

</dd>
<dt><span class="big">char* <span class="underline">PQport</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Get the port used in the connection.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />The port.
 
</p>

</dd>
<dt><span class="big">deprecated char* <span class="underline">PQtty</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p><span class="red">Deprecated:</span><br />This no longer has any effect.  Don't use it.
 
</p>

</dd>
<dt><span class="big">char* <span class="underline">PQoptions</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Get the command line options used in the connection.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />The command line options.
 
</p>

</dd>
<dt><span class="big">ConnStatusType <span class="underline">PQstatus</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Get the status of the connection.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />A ConnStatusType value describing the current connection.
 
</p>

</dd>
<dt><span class="big">PGTransactionStatusType <span class="underline">PQtransactionStatus</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Get the current in-transaction status of the server.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />A PGTransactionStatusType value describing the status of the transaction.
 
</p>

</dd>
<dt><span class="big">char* <span class="underline">PQparameterStatus</span>(PGconn * <em>conn</em>, char* <em>paramName</em>);
</span></dt>
<dd><p>Get the current parameter settings of the server.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />A string containing various parameter settings of the server.

</p>
<p><strong>See Also:</strong><br />The online PostgreSQL documentation describes what is in the returned string.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQprotocolVersion</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Get the version of the protocol used in the connection.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />The protocol version.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQserverVersion</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Get the version of PostgreSQL used by the server..
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />The version of PostgreSQL.
 
</p>

</dd>
<dt><span class="big">char* <span class="underline">PQerrorMessage</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Get the most recent error message from the connection.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />The most recent error message.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQsocket</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Get the socket used in the connection.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />The number that represents the socket.  A negative number is returned if no connection is open.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQbackendPID</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Get the PID of PostgreSQL on the server..
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />The PID.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQclientEncoding</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Get the character encoding currently being used.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />The integer representation of the character encoding.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQsetClientEncoding</span>(PGconn * <em>conn</em>, char* <em>encoding</em>);
</span></dt>
<dd><p>Change the character <em>encoding</em> used in the connection.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <em>encoding</em></td>
<td>The string representation of the desired character encoding.</td></tr>
</table>
<p><strong>Returns:</strong><br />0 on success and -1 on failure.
 
</p>

</dd>
<dt><span class="big">void* <span class="underline">PQgetssl</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Get the OpenSSL structure associated with a connection.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />The SSL structure used in the connection or <strong>null</strong> if SSL is not in use.
 
</p>

</dd>
<dt><span class="big">void <span class="underline">PQinitSSL</span>(int <em>do_init</em>);
</span></dt>
<dd><p>Tell the interface that SSL has already been initialized within your application.
</p>
<strong>Params:</strong><br /><table><tr><td>int <em>do_init</em></td>
<td>Set to 1 if you use SSL within your application and 0 otherwise.</td></tr>
</table>

</dd>
<dt><span class="big">PGVerbosity <span class="underline">PQsetErrorVerbosity</span>(PGconn * <em>conn</em>, PGVerbosity <em>verbosity</em>);
</span></dt>
<dd><p>Set how verbose the error messages should be.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>PGVerbosity <em>verbosity</em></td>
<td>A PGVerbosity value of the desired setting.</td></tr>
</table>
<p><strong>Returns:</strong><br />A PGVerbosity value with the previous setting.
 
</p>

</dd>
<dt><span class="big">void <span class="underline">PQtrace</span>(PGconn * <em>conn</em>, _iobuf * <em>debug_port</em>);
</span></dt>
<dd><p>Start copying all of the communications with the server to a stream.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>_iobuf * <em>debug_port</em></td>
<td>The CStream to send the data to.</td></tr>
</table>

</dd>
<dt><span class="big">void <span class="underline">PQuntrace</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Stop copying all of the communications with the server to a stream.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>

</dd>
<dt><span class="big">void(* <span class="underline">PQsetNoticeReceiver</span>(PGconn * <em>conn</em>, void(* <em>proc</em>)(void* <em>arg</em>, PGresult * res), void* <em>arg</em>))(void* <em>arg</em>, PGresult * res);
</span></dt>
<dd><p>Change the function that formats the notices.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>void(* <em>proc</em>)(void* <em>arg</em>, PGresult * res)</td>
<td>The new function.</td></tr>
<tr><td>void* <em>arg</em></td>
<td>Arguments to pass to the function whenever it is called.</td></tr>
</table>
<p><strong>Returns:</strong><br />The previous function.
 
</p>

</dd>
<dt><span class="big">void(* <span class="underline">PQsetNoticeProcessor</span>(PGconn * <em>conn</em>, void(* <em>proc</em>)(void* <em>arg</em>, char* message), void* <em>arg</em>))(void* <em>arg</em>, char* message);
</span></dt>
<dd><p>Change the function that handles the notices.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>void(* <em>proc</em>)(void* <em>arg</em>, char* message)</td>
<td>The new function.</td></tr>
<tr><td>void* <em>arg</em></td>
<td>Arguments to pass to the function whenever it is called.</td></tr>
</table>
<p><strong>Returns:</strong><br />The previous function.
 
</p>

</dd>
<dt><span class="big">alias <span class="underline">pgthreadlock_t</span>;
</span></dt>
<dd><p>Used to set callback that prevents concurrent access to
 non-thread safe functions that libpq needs.
 The default implementation uses a libpq internal mutex.
 Only required for multithreaded apps that use kerberos
 both within their app and for postgresql connections.
 
</p>

</dd>
<dt><span class="big">void(* <span class="underline">PQregisterThreadLock</span>(void(* <em>newhandler</em>)(int acquire)))(int acquire);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">PGresult * <span class="underline">PQexec</span>(PGconn * <em>conn</em>, char* <em>query</em>);
</span></dt>
<dd><p>Submit a command to the server and wait for the results.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <em>query</em></td>
<td>The SQL command(s) to execute.</td></tr>
</table>
<strong>Results:</strong>
A PGresult structure containing the results or <strong>null</strong> on a serious error.
 


</dd>
<dt><span class="big">PGresult * <span class="underline">PQexecParams</span>(PGconn * <em>conn</em>, char* <em>command</em>, int <em>nParams</em>, Oid* <em>paramTypes</em>, char** <em>paramValues</em>, int* <em>paramLengths</em>, int* <em>paramFormats</em>, int <em>resultFormat</em>);
</span></dt>
<dd><p>Submit a <em>command</em> to the server and wait for the results.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <em>command</em></td>
<td>The SQL command to execute.</td></tr>
<tr><td>int <em>nParams</em></td>
<td>The number of parameters.</td></tr>
<tr><td>Oid* <em>paramTypes</em></td>
<td>An array of types specified using Oid.  Use <strong>null</strong> or 0 to have the server guess.</td></tr>
<tr><td>char** <em>paramValues</em></td>
<td>The parameters themselves in the expected format.</td></tr>
<tr><td>int* <em>paramLengths</em></td>
<td>An array of lengths of the parameters.  This is ignored for non-binary data.</td></tr>
<tr><td>int* <em>paramFormats</em></td>
<td>An array of formats of the parameters.  Use 0 for text and 1 for binary.</td></tr>
<tr><td>int <em>resultFormat</em></td>
<td>Use 0 to obtain the results in text format and 1 for binary.</td></tr>
</table>
<p><strong>Returns:</strong><br />A PGresult structure containing the results or <strong>null</strong> on a serious error.
 
</p>

</dd>
<dt><span class="big">PGresult * <span class="underline">PQprepare</span>(PGconn * <em>conn</em>, char* <em>stmtName</em>, char* <em>query</em>, int <em>nParams</em>, Oid* <em>paramTypes</em>);
</span></dt>
<dd><p>Create a prepared statement and wait for completion.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <em>stmtName</em></td>
<td>The name to assign to the prepared statement.</td></tr>
<tr><td>char* <em>query</em></td>
<td>The SQL command to prepare.</td></tr>
<tr><td>int <em>nParams</em></td>
<td>The number of parameters.</td></tr>
<tr><td>Oid* <em>paramTypes</em></td>
<td>An array of types specified using Oid.  Use <strong>null</strong> or 0 to have the server guess.</td></tr>
</table>
<strong>Results:</strong>
A PGresult structure containing the results or <strong>null</strong> on a serious error.
 


</dd>
<dt><span class="big">PGresult * <span class="underline">PQexecPrepared</span>(PGconn * <em>conn</em>, char* <em>stmtName</em>, int <em>nParams</em>, char** <em>paramValues</em>, int* <em>paramLengths</em>, int* <em>paramFormats</em>, int <em>resultFormat</em>);
</span></dt>
<dd><p>Execute a prepared statement and wait for the results.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <em>stmtName</em></td>
<td>The name of the prepared statement to execute.</td></tr>
<tr><td>int <em>nParams</em></td>
<td>The number of parameters.</td></tr>
<tr><td>char** <em>paramValues</em></td>
<td>The parameters themselves in the expected format.</td></tr>
<tr><td>int* <em>paramLengths</em></td>
<td>An array of lengths of the parameters.  This is ignored for non-binary data.</td></tr>
<tr><td>int* <em>paramFormats</em></td>
<td>An array of formats of the parameters.  Use 0 for text and 1 for binary.</td></tr>
<tr><td>int <em>resultFormat</em></td>
<td>Use 0 to obtain the results in text format and 1 for binary.</td></tr>
</table>
<strong>Results:</strong>
A PGresult structure containing the results or <strong>null</strong> on a serious error.
 


</dd>
<dt><span class="big">int <span class="underline">PQsendQuery</span>(PGconn * <em>conn</em>, char* <em>query</em>);
</span></dt>
<dd><p>Submit a command to the server without waiting for the results.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <em>query</em></td>
<td>The SQL command(s) to execute.</td></tr>
</table>
<p><strong>Returns:</strong><br />1 on success or 0 on failure.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQsendQueryParams</span>(PGconn * <em>conn</em>, char* <em>command</em>, int <em>nParams</em>, Oid* <em>paramTypes</em>, char** <em>paramValues</em>, int* <em>paramLengths</em>, int* <em>paramFormats</em>, int <em>resultFormat</em>);
</span></dt>
<dd><p>Submit a command to the server without waiting for the results.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <em>command</em></td>
<td>The SQL command to execute.</td></tr>
<tr><td>int <em>nParams</em></td>
<td>The number of parameters.</td></tr>
<tr><td>Oid* <em>paramTypes</em></td>
<td>An array of types specified using Oid.  Use <strong>null</strong> or 0 to have the server guess.</td></tr>
<tr><td>char** <em>paramValues</em></td>
<td>The parameters themselves in the expected format.</td></tr>
<tr><td>int* <em>paramLengths</em></td>
<td>An array of lengths of the parameters.  This is ignored for non-binary data.</td></tr>
<tr><td>int* <em>paramFormats</em></td>
<td>An array of formats of the parameters.  Use 0 for text and 1 for binary.</td></tr>
<tr><td>int <em>resultFormat</em></td>
<td>Use 0 to obtain the results in text format and 1 for binary.</td></tr>
</table>
<p><strong>Returns:</strong><br />1 on success or 0 on failure.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQsendPrepare</span>(PGconn * <em>conn</em>, char* <em>stmtName</em>, char* <em>query</em>, int <em>nParams</em>, Oid* <em>paramTypes</em>);
</span></dt>
<dd><p>Create a prepared statement without waiting for completion.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <em>stmtName</em></td>
<td>The name to assign to the prepared statement.</td></tr>
<tr><td>char* <em>query</em></td>
<td>The SQL command to prepare.</td></tr>
<tr><td>int <em>nParams</em></td>
<td>The number of parameters.</td></tr>
<tr><td>Oid* <em>paramTypes</em></td>
<td>An array of types specified using Oid.  Use <strong>null</strong> or 0 to have the server guess.</td></tr>
</table>
<p><strong>Returns:</strong><br />1 on success or 0 on failure.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQsendQueryPrepared</span>(PGconn * <em>conn</em>, char* <em>stmtName</em>, int <em>nParams</em>, char** <em>paramValues</em>, int* <em>paramLengths</em>, int* <em>paramFormats</em>, int <em>resultFormat</em>);
</span></dt>
<dd><p>Execute a prepared statement without waiting for the results.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <em>stmtName</em></td>
<td>The name of the prepared statement to execute.</td></tr>
<tr><td>int <em>nParams</em></td>
<td>The number of parameters.</td></tr>
<tr><td>char** <em>paramValues</em></td>
<td>The parameters themselves in the expected format.</td></tr>
<tr><td>int* <em>paramLengths</em></td>
<td>An array of lengths of the parameters.  This is ignored for non-binary data.</td></tr>
<tr><td>int* <em>paramFormats</em></td>
<td>An array of formats of the parameters.  Use 0 for text and 1 for binary.</td></tr>
<tr><td>int <em>resultFormat</em></td>
<td>Use 0 to obtain the results in text format and 1 for binary.</td></tr>
</table>
<p><strong>Returns:</strong><br />1 on success or 0 on failure.
 
</p>

</dd>
<dt><span class="big">PGresult * <span class="underline">PQgetResult</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Get the current result set.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />A PGresult structure describing the current status or <strong>null</strong> if no command is being processed.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQisBusy</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Determine if the server is currently busy with a command.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />1 if a command is busy and 0 if it is safe to call PQgetResult.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQconsumeInput</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Get any input from the server.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />1 on success and 0 on failure.
 
</p>

</dd>
<dt><span class="big">pgNotify * <span class="underline">PQnotifies</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Get the next unhandled notification event.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />The PGnotify structure representing the notification event.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQputCopyData</span>(PGconn * <em>conn</em>, char* <em>buffer</em>, int <em>nbytes</em>);
</span></dt>
<dd><p>Send data to the server after a copy command.
</p>
<p>This function will only be unable to send the data if nonblocking is set.

</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <em>buffer</em></td>
<td>The data to send to the server.</td></tr>
<tr><td>int <em>nbytes</em></td>
<td>The length of <em>buffer</em>.</td></tr>
</table>
<p><strong>Returns:</strong><br />1 on success, -1 on failure, or 0 if the data wasn't sent.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQputCopyEnd</span>(PGconn * <em>conn</em>, char* <em>errormsg</em>);
</span></dt>
<dd><p>Tell the server that no more data needs to be copied.
</p>
<p>This function will only be unable to send the data if nonblocking is set.

</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <em>errormsg</em></td>
<td><strong>null</strong> on success and the error message on failure.</td></tr>
</table>
<p><strong>Returns:</strong><br />1 on success, -1 on failure, or 0 if the data wasn't sent.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQgetCopyData</span>(PGconn * <em>conn</em>, char** <em>buffer</em>, int <em>async</em>);
</span></dt>
<dd><p>Get the data from the server after a copy command.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char** <em>buffer</em></td>
<td>A pointer to the buffer.  The memory will be allocated by PostgreSQL.</td></tr>
<tr><td>int <em>async</em></td>
<td>Use 0 for nonblocking and any other number for blocking.</td></tr>
</table>
<p><strong>Returns:</strong><br />-1 on success, -2 on failure, or 0 if the command is still in progress.
 
</p>

</dd>
<dt><span class="big">deprecated int <span class="underline">PQgetline</span>(PGconn * <em>conn</em>, char* <em>string</em>, int <em>length</em>);
<br />deprecated int <span class="underline">PQputline</span>(PGconn * <em>conn</em>, char* <em>string</em>);
<br />deprecated int <span class="underline">PQgetlineAsync</span>(PGconn * <em>conn</em>, char* <em>buffer</em>, int <em>bufsize</em>);
<br />deprecated int <span class="underline">PQputnbytes</span>(PGconn * <em>conn</em>, char* <em>buffer</em>, int <em>nbytes</em>);
<br />deprecated int <span class="underline">PQendcopy</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p><span class="red">Deprecated:</span><br />These functions have poor error handling, nonblocking transfers, binary data,
	or easy end of data detection.  Use PQputCopyData, PQputCopyEnd, and PQgetCopyData instead.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQsetnonblocking</span>(PGconn * <em>conn</em>, int <em>arg</em>);
</span></dt>
<dd><p>Set the nonblocking status of the connection.
</p>
<p>PQexec will ignore this setting.

</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>int <em>arg</em></td>
<td>1 for nonblocking and 0 for blocking.</td></tr>
</table>
<p><strong>Returns:</strong><br />0 on success and -1 on failure.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQisnonblocking</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Get the current nonblocking status of the connection.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />1 if the connection is nonblocking and 0 if it is blocking.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQisthreadsafe</span>();
</span></dt>
<dd><p>todo
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQflush</span>(PGconn * <em>conn</em>);
</span></dt>
<dd><p>Attempt to send all queries to the server immediately.
</p>
<p>This function will only be unable to send the data if nonblocking is set.

</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
</table>
<p><strong>Returns:</strong><br />0 on success, -1 on failure, or 1 if not all of the data was sent.
 
</p>

</dd>
<dt><span class="big">deprecated PGresult * <span class="underline">PQfn</span>(PGconn * <em>conn</em>, int <em>fnid</em>, int* <em>result_buf</em>, int* <em>result_len</em>, int <em>result_is_int</em>, PQArgBlock * <em>args</em>, int <em>nargs</em>);
</span></dt>
<dd><p>Send a simple command to the query very quickly.
</p>
<p><span class="red">Deprecated:</span><br />Prepared functions are just as fast and more powerful.  Use them instead.

</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>int <em>fnid</em></td>
<td>The Oid of the function to execute.</td></tr>
<tr><td>int* <em>result_buf</em></td>
<td>The buffer the return value will be placed in.</td></tr>
<tr><td>int* <em>result_len</em></td>
<td>The length of <em>result_buf</em>.</td></tr>
<tr><td>int <em>result_is_int</em></td>
<td>This is 1 if an integer of 4 bytes or less is to be returned.  Use 0 otherwise.</td></tr>
<tr><td>PQArgBlock * <em>args</em></td>
<td>An array of PQArgBlock structures.</td></tr>
<tr><td>int <em>nargs</em></td>
<td>The length of <em>args</em>.</td></tr>
</table>
<p><strong>Returns:</strong><br />A PGresult structure describing the current status.
 
</p>

</dd>
<dt><span class="big">ExecStatusType <span class="underline">PQresultStatus</span>(PGresult * <em>res</em>);
</span></dt>
<dd><p>Get the result status of a command.
</p>
<strong>Params:</strong><br /><table><tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure returned by the server.</td></tr>
</table>
<p><strong>Returns:</strong><br />An ExecStatusType value describing the result status.
 
</p>

</dd>
<dt><span class="big">char* <span class="underline">PQresStatus</span>(ExecStatusType <em>status</em>);
</span></dt>
<dd><p>Get the string representing an ExecStatusType value.
</p>
<strong>Params:</strong><br /><table><tr><td>ExecStatusType <em>status</em></td>
<td>The ExecStatusType value.</td></tr>
</table>
<p><strong>Returns:</strong><br />The representative string.
 
</p>

</dd>
<dt><span class="big">char* <span class="underline">PQresultErrorMessage</span>(PGresult * <em>res</em>);
</span></dt>
<dd><p>Get the error message associated with a command.
</p>
<strong>Params:</strong><br /><table><tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure returned by the server.</td></tr>
</table>
<p><strong>Returns:</strong><br />The string form of the error if there is one or an empty string otherwise.
 
</p>

</dd>
<dt><span class="big">char* <span class="underline">PQresultErrorField</span>(PGresult * <em>res</em>, char <em>fieldcode</em>);
</span></dt>
<dd><p>Get an individual field of an error report.
</p>
<strong>Params:</strong><br /><table><tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>char <em>fieldcode</em></td>
<td>The error filed to return.  Accepted values start with PG_DIAG_</td></tr>
</table>
<p><strong>Returns:</strong><br />The string form of the error if there is one or <strong>null</strong> otherwise.

</p>
<p><strong>See Also:</strong><br />The online PostgreSQL documentation describes what you can use in <em>fieldcode</em>.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQntuples</span>(PGresult * <em>res</em>);
</span></dt>
<dd><p>Get the number of tuples in a query result.
</p>
<strong>Params:</strong><br /><table><tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure returned by the server.</td></tr>
</table>
<p><strong>Returns:</strong><br />The number of tuples.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQnfields</span>(PGresult * <em>res</em>);
</span></dt>
<dd><p>Get the number of fields in a query result.
</p>
<strong>Params:</strong><br /><table><tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure returned by the server.</td></tr>
</table>
<p><strong>Returns:</strong><br />The number of fields.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQbinaryTuples</span>(PGresult * <em>res</em>);
</span></dt>
<dd><p>Get whether a query result contains binary data or not.
</p>
<strong>Params:</strong><br /><table><tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure returned by the server.</td></tr>
</table>
<p><strong>Returns:</strong><br />1 if the result set contains binary data and 0 otherwise.
 
</p>

</dd>
<dt><span class="big">char* <span class="underline">PQfname</span>(PGresult * <em>res</em>, int <em>field_num</em>);
</span></dt>
<dd><p>Get the column name associated with a column number in a query result.
</p>
<strong>Params:</strong><br /><table><tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>int <em>field_num</em></td>
<td>The number of the column.</td></tr>
</table>
<p><strong>Returns:</strong><br />The name of the column if it exists or <strong>null</strong> otherwise.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQfnumber</span>(PGresult * <em>res</em>, char* <em>field_name</em>);
</span></dt>
<dd><p>Get the column number associated with a column name in a query result.
</p>
<strong>Params:</strong><br /><table><tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>char* <em>field_name</em></td>
<td>The name of the column.</td></tr>
</table>
<p><strong>Returns:</strong><br />The number of the column if it exists or -1 otherwise.
 
</p>

</dd>
<dt><span class="big">Oid <span class="underline">PQftable</span>(PGresult * <em>res</em>, int <em>field_num</em>);
</span></dt>
<dd><p>Get the Oid of the table from which a column in a query result was fetched.
</p>
<strong>Params:</strong><br /><table><tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>int <em>field_num</em></td>
<td>The number of the column.</td></tr>
</table>
<p><strong>Returns:</strong><br />The Oid of the table if it exists or InvalidOid otherwise.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQftablecol</span>(PGresult * <em>res</em>, int <em>field_num</em>);
</span></dt>
<dd><p>Get the number of a column in its table from its number in a query result.
</p>
<strong>Params:</strong><br /><table><tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>int <em>field_num</em></td>
<td>The number of the column within the query result.</td></tr>
</table>
<p><strong>Returns:</strong><br />The column number if it exists or 0 otherwise.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQfformat</span>(PGresult * <em>res</em>, int <em>field_num</em>);
</span></dt>
<dd><p>Get the format code of a column in a query result.
</p>
<strong>Params:</strong><br /><table><tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>int <em>field_num</em></td>
<td>The number of the column.</td></tr>
</table>
<p><strong>Returns:</strong><br />0 if the format is text and 1 if it is binary.
 
</p>

</dd>
<dt><span class="big">Oid <span class="underline">PQftype</span>(PGresult * <em>res</em>, int <em>field_num</em>);
</span></dt>
<dd><p>Get the data type of a column in a query result.
</p>
<strong>Params:</strong><br /><table><tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>int <em>field_num</em></td>
<td>The number of the column.</td></tr>
</table>
<p><strong>Returns:</strong><br />The Oid representing the data type.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQfsize</span>(PGresult * <em>res</em>, int <em>field_num</em>);
</span></dt>
<dd><p>Get the number of bytes4/17/2006 in a column in a query result.
</p>
<strong>Params:</strong><br /><table><tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>int <em>field_num</em></td>
<td>The number of the column.</td></tr>
</table>
<p><strong>Returns:</strong><br />The number of bytes.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQfmod</span>(PGresult * <em>res</em>, int <em>field_num</em>);
</span></dt>
<dd><p>Get the type modifier of a column in a query result.
</p>
<strong>Params:</strong><br /><table><tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>int <em>field_num</em></td>
<td>The number of the column.</td></tr>
</table>
<p><strong>Returns:</strong><br />The type modifier if it exists or -1 otherwise.
 
</p>

</dd>
<dt><span class="big">char* <span class="underline">PQcmdStatus</span>(PGresult * <em>res</em>);
</span></dt>
<dd><p>Get the command status tag from a query result.
</p>
<strong>Params:</strong><br /><table><tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure returned by the server.</td></tr>
</table>
<p><strong>Returns:</strong><br />The command status tag.
 
</p>

</dd>
<dt><span class="big">deprecated char* <span class="underline">PQoidStatus</span>(PGresult * <em>res</em>);
</span></dt>
<dd><p>Get the Oid in string format of a valid insert in a query result.
</p>
<p><span class="red">Deprecated:</span><br />Use PQoidValue instead.  It is thread-safe.

</p>
<strong>Params:</strong><br /><table><tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure returned by the server.</td></tr>
</table>
<p><strong>Returns:</strong><br />The Oid if it exists and is valid. "0" or "" is returned otherwise.
 
</p>

</dd>
<dt><span class="big">Oid <span class="underline">PQoidValue</span>(PGresult * <em>res</em>);
</span></dt>
<dd><p>Get the Oid of a valid insert in a query result.
</p>
<strong>Params:</strong><br /><table><tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure returned by the server.</td></tr>
</table>
<p><strong>Returns:</strong><br />The Oid if it exists and is valid or InvalidOid if it isn't.
 
</p>

</dd>
<dt><span class="big">char* <span class="underline">PQcmdTuples</span>(PGresult * <em>res</em>);
</span></dt>
<dd><p>Get the number of tuples affected by a query.
</p>
<strong>Params:</strong><br /><table><tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure returned by the server.</td></tr>
</table>
<p><strong>Returns:</strong><br />The number of affected tuples.
 
</p>

</dd>
<dt><span class="big">char* <span class="underline">PQgetvalue</span>(PGresult * <em>res</em>, int <em>tup_num</em>, int <em>field_num</em>);
</span></dt>
<dd><p>Get the value of a single field in a query result.
</p>
<strong>Params:</strong><br /><table><tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>int <em>tup_num</em></td>
<td>The number of the row.</td></tr>
<tr><td>int <em>field_num</em></td>
<td>The number of the column.</td></tr>
</table>
<p><strong>Returns:</strong><br />The value of the field.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQgetlength</span>(PGresult * <em>res</em>, int <em>tup_num</em>, int <em>field_num</em>);
</span></dt>
<dd><p>Get the number of bytes in the length of a single field in a query result.
</p>
<strong>Params:</strong><br /><table><tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>int <em>tup_num</em></td>
<td>The number of the row.</td></tr>
<tr><td>int <em>field_num</em></td>
<td>The number of the column.</td></tr>
</table>
<p><strong>Returns:</strong><br />The number of bytes in the length of the field.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQgetisnull</span>(PGresult * <em>res</em>, int <em>tup_num</em>, int <em>field_num</em>);
</span></dt>
<dd><p>Get whether or not a single field in a query result is <strong>null</strong>.
</p>
<strong>Params:</strong><br /><table><tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>int <em>tup_num</em></td>
<td>The number of the row.</td></tr>
<tr><td>int <em>field_num</em></td>
<td>The number of the column.</td></tr>
</table>
<p><strong>Returns:</strong><br />1 if it is <strong>null</strong> or 0 otherwise.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQnparams</span>(PGresult * <em>res</em>);
</span></dt>
<dd><p>todo
 
</p>

</dd>
<dt><span class="big">Oid <span class="underline">PQparamtype</span>(PGresult * <em>res</em>, int <em>param_num</em>);
</span></dt>
<dd><p>todo
 
</p>

</dd>
<dt><span class="big">PGresult * <span class="underline">PQdescribePrepared</span>(PGconn * <em>conn</em>, char* <em>stmt</em>);
</span></dt>
<dd><p>todo
 
</p>

</dd>
<dt><span class="big">PGresult * <span class="underline">PQdescribePortal</span>(PGconn * <em>conn</em>, char* <em>portal</em>);
</span></dt>
<dd><p>todo
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQsendDescribePrepared</span>(PGconn * <em>conn</em>, char* <em>stmt</em>);
</span></dt>
<dd><p>todo
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQsendDescribePortal</span>(PGconn * <em>conn</em>, char* <em>portal</em>);
</span></dt>
<dd><p>todo
 
</p>

</dd>
<dt><span class="big">void <span class="underline">PQclear</span>(PGresult * <em>res</em>);
</span></dt>
<dd><p>Free all memory associated with a result.  This includes all returned strings.
</p>
<strong>Params:</strong><br /><table><tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure to erase.</td></tr>
</table>

</dd>
<dt><span class="big">void <span class="underline">PQfreemem</span>(void* <em>ptr</em>);
</span></dt>
<dd><p>Free memory allocated by the the interface library.
</p>
<p>This is necessary only on Windows.  Users of other operating systems can simply use free.

</p>
<strong>Params:</strong><br /><table><tr><td>void* <em>ptr</em></td>
<td>A pointer to the memory to free.</td></tr>
</table>

</dd>
<dt><span class="big">deprecated alias <span class="underline">PQfreeNotify</span>;
</span></dt>
<dd><p><span class="red">Deprecated:</span><br />Use PQfreemem or free directly.
 
</p>

</dd>
<dt><span class="big">PGresult * <span class="underline">PQmakeEmptyPGresult</span>(PGconn * <em>conn</em>, ExecStatusType <em>status</em>);
</span></dt>
<dd><p>Make an empty PGresult structure with a given status.
</p>
<p>Note that anything from the PostgreSQL connection will be added in.

</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.  This can be <strong>null</strong>.</td></tr>
<tr><td>ExecStatusType <em>status</em></td>
<td>The error message to add to the PGresult structure.</td></tr>
</table>
<p><strong>Returns:</strong><br />The created PGresult structure.
 
</p>

</dd>
<dt><span class="big">uint <span class="underline">PQescapeStringConn</span>(PGconn * <em>conn</em>, char* <em>to</em>, char* <em>from</em>, uint <em>length</em>, int* <em>error</em>);
</span></dt>
<dd><p>Escape a string for use within a SQL command.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <em>to</em></td>
<td>The buffer the results will be put in.  Must be at least 2 * <em>length</em> + 1 chars long.</td></tr>
<tr><td>char* <em>from</em></td>
<td>The string to convert.</td></tr>
<tr><td>uint <em>length</em></td>
<td>The number of chars to escape.  The terminating 0 should not be included.</td></tr>
<tr><td>int* <em>error</em></td>
<td>0 on success and nonzero on failure.  Can be <strong>null</strong>.</td></tr>
</table>
<p><strong>Returns:</strong><br />The number of characters in <em>to</em>.  This doesn't include the terminating 0.
 
</p>

</dd>
<dt><span class="big">char* <span class="underline">PQescapeByteaConn</span>(PGconn * <em>conn</em>, ubyte* <em>from</em>, uint <em>from_length</em>, uint* <em>to_length</em>);
</span></dt>
<dd><p>Escape binary data for use within a SQL command.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>ubyte* <em>from</em></td>
<td>A pointer to the first byte to escape.</td></tr>
<tr><td>uint <em>from_length</em></td>
<td>The number of bytes to escape.  The terminating 0 should not be included.</td></tr>
<tr><td>uint* <em>to_length</em></td>
<td>A pointer to a variable that will hold the length of the escaped string.</td></tr>
</table>
<p><strong>Returns:</strong><br />The escaped version of bintext on success and <strong>null</strong> on failure.
 
</p>

</dd>
<dt><span class="big">deprecated uint <span class="underline">PQescapeString</span>(char* <em>to</em>, char* <em>from</em>, uint <em>length</em>);
</span></dt>
<dd><p>Escape a string for use within a SQL command.
</p>
<p><span class="red">Deprecated:</span><br />Replaced by PQescapeStringConn in PostgreSQL 8.1.4.

</p>
<strong>Params:</strong><br /><table><tr><td>char* <em>to</em></td>
<td>The buffer the results will be put in.  Must be at least 2 * <em>length</em> + 1 chars long.</td></tr>
<tr><td>char* <em>from</em></td>
<td>The string to convert.</td></tr>
<tr><td>uint <em>length</em></td>
<td>The number of chars to escape.  The terminating 0 should not be included.</td></tr>
</table>
<p><strong>Returns:</strong><br />The number of characters in <em>to</em>.
 
</p>

</dd>
<dt><span class="big">deprecated char* <span class="underline">PQescapeBytea</span>(ubyte* <em>bintext</em>, uint <em>binlen</em>, uint* <em>bytealen</em>);
</span></dt>
<dd><p>Escape binary data for use within a SQL command.
</p>
<p><span class="red">Deprecated:</span><br />Replaced by PQescapeByteaConn in PostgreSQL 8.1.4.

</p>
<strong>Params:</strong><br /><table><tr><td>ubyte* <em>bintext</em></td>
<td>A pointer to the first byte to escape.</td></tr>
<tr><td>uint <em>binlen</em></td>
<td>The number of bytes to escape.  The terminating 0 should not be included.</td></tr>
<tr><td>uint* <em>bytealen</em></td>
<td>A pointer to a variable that will hold the length of the escaped string.</td></tr>
</table>
<p><strong>Returns:</strong><br />The escaped version of <em>bintext</em>.
 
</p>

</dd>
<dt><span class="big">ubyte* <span class="underline">PQunescapeBytea</span>(char* <em>strtext</em>, uint* <em>retbuflen</em>);
</span></dt>
<dd><p>Unescape binary data.
</p>
<strong>Params:</strong><br /><table><tr><td>char* <em>strtext</em></td>
<td>The escaped binary data.</td></tr>
<tr><td>uint* <em>retbuflen</em></td>
<td>A pointer to a variable that will hold the length of the escaped string.</td></tr>
</table>
<p><strong>Returns:</strong><br />The unescaped version of <em>strtext</em>.
 
</p>

</dd>
<dt><span class="big">void <span class="underline">PQprint</span>(_iobuf * <em>fout</em>, PGresult * <em>res</em>, _PQprintOpt * <em>ps</em>);
</span></dt>
<dd><p>Print all of the rows to a stream.
</p>
<strong>Params:</strong><br /><table><tr><td>_iobuf * <em>fout</em></td>
<td>The CStream to output the information to.</td></tr>
<tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>_PQprintOpt * <em>ps</em></td>
<td>A PQprintOpt structure containing your printing options.</td></tr>
</table>

</dd>
<dt><span class="big">deprecated void <span class="underline">PQdisplayTuples</span>(PGresult * <em>res</em>, _iobuf * <em>fp</em>, int <em>fillAlign</em>, char* <em>fieldSep</em>, int <em>printHeader</em>, int <em>quiet</em>);
</span></dt>
<dd><p>Print all of the rows to a stream.
</p>
<p><span class="red">Deprecated:</span><br />Use PQprint instead.

</p>
<strong>Params:</strong><br /><table><tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>_iobuf * <em>fp</em></td>
<td>The CStream to output the information to.</td></tr>
<tr><td>int <em>fillAlign</em></td>
<td>Space fill to align columns.</td></tr>
<tr><td>char* <em>fieldSep</em></td>
<td>The character to use as a field seperator.</td></tr>
<tr><td>int <em>printHeader</em></td>
<td>Use 1 to display headers and 0 not to.</td></tr>
<tr><td>int <em>quiet</em></td>
<td>Use 0 to show row count at the end and 1 not to.</td></tr>
</table>

</dd>
<dt><span class="big">deprecated void <span class="underline">PQprintTuples</span>(PGresult * <em>res</em>, _iobuf * <em>fout</em>, int <em>printAttName</em>, int <em>terseOutput</em>, int <em>width</em>);
</span></dt>
<dd><p>Print all of the rows to a stream.
</p>
<p><span class="red">Deprecated:</span><br />Use PQprint instead.

</p>
<strong>Params:</strong><br /><table><tr><td>PGresult * <em>res</em></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>_iobuf * <em>fout</em></td>
<td>The CStream to output the information to.</td></tr>
<tr><td>int <em>printAttName</em></td>
<td>Use 1 to print attribute names and 0 not to.</td></tr>
<tr><td>int <em>terseOutput</em></td>
<td>Use 1 to show delimiter bars and 0 not to.</td></tr>
<tr><td>int <em>width</em></td>
<td>The width of the columns.  Use 0 for variable width.</td></tr>
</table>

</dd>
<dt><span class="big">int <span class="underline">lo_open</span>(PGconn * <em>conn</em>, Oid <em>lobjId</em>, int <em>mode</em>);
</span></dt>
<dd><p>Open an existing large object.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>PostgreSQL connection.</td></tr>
<tr><td>Oid <em>lobjId</em></td>
<td>Oid of the large object to open.</td></tr>
<tr><td>int <em>mode</em></td>
<td>Whether to make it readonly or not.  Uses INV_READ and INV_WRITE.</td></tr>
</table>
<p><strong>Returns:</strong><br />An integer for use with other large object functions on success or -1 on failure.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">lo_close</span>(PGconn * <em>conn</em>, int <em>fd</em>);
</span></dt>
<dd><p>Close an opened large object.
</p>
<p>This is done automatically to any large objects that are open at the end of a transaction.

</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>int <em>fd</em></td>
<td>The integer returned when the large object was opened.</td></tr>
</table>
<p><strong>Returns:</strong><br />0 on success or -1 on failure.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">lo_read</span>(PGconn * <em>conn</em>, int <em>fd</em>, byte* <em>buf</em>, uint <em>len</em>);
</span></dt>
<dd><p>Read from an open large object.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>int <em>fd</em></td>
<td>The integer returned when the large object was opened;</td></tr>
<tr><td>byte* <em>buf</em></td>
<td>The buffer that that data will be written to.</td></tr>
<tr><td>uint <em>len</em></td>
<td>The number of bytes to copy to <em>buf</em>.</td></tr>
</table>
<p><strong>Returns:</strong><br />The number of bytes read on success or a negative number on failure.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">lo_write</span>(PGconn * <em>conn</em>, int <em>fd</em>, byte* <em>buf</em>, uint <em>len</em>);
</span></dt>
<dd><p>Writes to an open large object.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>int <em>fd</em></td>
<td>The integer returned when the large object was opened.</td></tr>
<tr><td>byte* <em>buf</em></td>
<td>The buffer that the data will be read from.</td></tr>
<tr><td>uint <em>len</em></td>
<td>The number of bytes to copy from <em>buf</em>.</td></tr>
</table>
<p><strong>Returns:</strong><br />The number of bytes read on success or a negative number on failure.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">lo_lseek</span>(PGconn * <em>conn</em>, int <em>fd</em>, int <em>offset</em>, int <em>whence</em>);
</span></dt>
<dd><p>Change the location of reading and writing in an open large object.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>int <em>fd</em></td>
<td>The integer returned when the large object was opened.</td></tr>
<tr><td>int <em>offset</em></td>
<td>How far to move.</td></tr>
<tr><td>int <em>whence</em></td>
<td>Where to start counting.  Uses SEEK_SET, SEEK_CUR, and SEEK_END.</td></tr>
</table>
<p><strong>Returns:</strong><br />The new location pointer on success or -1 on failure.
 
</p>

</dd>
<dt><span class="big">Oid <span class="underline">lo_creat</span>(PGconn * <em>conn</em>, int <em>mode</em>);
</span></dt>
<dd><p>Create a new large object.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>int <em>mode</em></td>
<td>Ignored as of PostgreSQL version 8.1.</td></tr>
</table>
<p><strong>Returns:</strong><br />The Oid of the large object on success or InvalidOid on failure.
 
</p>

</dd>
<dt><span class="big">Oid <span class="underline">lo_create</span>(PGconn * <em>conn</em>, Oid <em>lobjId</em>);
</span></dt>
<dd><p>Create a new large object.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>Oid <em>lobjId</em></td>
<td>Requested Oid to assign the large object to.</td></tr>
</table>
<p><strong>Returns:</strong><br />The Oid of the large object or InvalidOid on failure.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">lo_tell</span>(PGconn * <em>conn</em>, int <em>fd</em>);
</span></dt>
<dd><p>Get the location pointer of an open large object.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>int <em>fd</em></td>
<td>The integer returned when the large object was opened.</td></tr>
</table>
<p><strong>Returns:</strong><br />The location pointer or a negative number on failure.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">lo_unlink</span>(PGconn * <em>conn</em>, Oid <em>lobjId</em>);
</span></dt>
<dd><p>Remove a large object from the database.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>lobjOid</td>
<td>the Oid of the large object to remove.</td></tr>
</table>
<p><strong>Returns:</strong><br />1 on success or -1 on failure.
 
</p>

</dd>
<dt><span class="big">Oid <span class="underline">lo_import</span>(PGconn * <em>conn</em>, char* <em>filename</em>);
</span></dt>
<dd><p>Load a large object from a file.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <em>filename</em></td>
<td>Name of the file to load.</td></tr>
</table>
<p><strong>Returns:</strong><br />The Oid of the large object or InvalidOid on failure.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">lo_export</span>(PGconn * <em>conn</em>, Oid <em>lobjId</em>, char* <em>filename</em>);
</span></dt>
<dd><p>Save a large object to a file.
</p>
<strong>Params:</strong><br /><table><tr><td>PGconn * <em>conn</em></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>lobjOid</td>
<td>Oid of the large object to save.</td></tr>
<tr><td>char* <em>filename</em></td>
<td>Name of the file to save to.</td></tr>
</table>
<p><strong>Returns:</strong><br />1 on success or -1 on failure.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQmblen</span>(char* <em>s</em>, int <em>encoding</em>);
</span></dt>
<dd><p>todo
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQdsplen</span>(char* <em>s</em>, int <em>encoding</em>);
</span></dt>
<dd><p>todo
 
</p>

</dd>
<dt><span class="big">int <span class="underline">PQenv2encoding</span>();
</span></dt>
<dd><p>todo
 
</p>

</dd>
<dt><span class="big">char* <span class="underline">PQencryptPassword</span>(char* <em>passwd</em>, char* <em>user</em>);
</span></dt>
<dd><p>todo
 
</p>

</dd>
</dl>

<hr />
<p><span class="small">Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. BSD license
 
</span></p>
</body>
</html>
