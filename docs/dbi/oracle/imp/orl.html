<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<title>dbi.oracle.imp.orl</title>
	<style type="text/css">
		.underline {
			text-decoration: underline;
		}

		.big {
			font-size: larger;
		}

		.small {
			font-size: smaller;
		}

		.red {
			color: red;
		}

		.blue {
			color: blue;
		}

		.green {
			color: green;
		}

		.yellow {
			color: yellow;
		}

		.black {
			color: black;
		}

		.white {
			color: white;
		}
	</style>
</head>
<body>
<h1>dbi.oracle.imp.orl</h1>
<!-- Generated by Ddoc from dbi\oracle\imp\orl.d -->
<p>Oracle import library.
</p>
<p>Part of the D DBI project.

</p>
<p><strong>Version:</strong><br />Oracle 10g revision 2
<br /><br />

	Import library version 0.03

</p>
<p><strong>Authors:</strong><br />The D DBI project

</p>

<dl><dt><span class="big">const uint <span class="underline">OCI_NUMBER_SIZE</span>;
</span></dt>
<dd><p>The number of bytes in an OCINumber.
</p>

</dd>
<dt><span class="big">struct <span class="underline">OCINumber</span>;
</span></dt>
<dd><p>OCI Number mapping in C.
</p>
<p>The OTS types: NUMBER, NUMERIC, INT, SHORTINT, REAL, DOUBLE PRECISION,
 FLOAT and DECIMAL are represented by <span class="underline">OCINumber</span>.
<br /><br />

 The contents of <span class="underline">OCINumber</span> is opaque to clients.
<br /><br />

 For binding variables of type <span class="underline">OCINumber</span> in OCI calls (OCIBindByName(),
 OCIBindByPos(), and OCIDefineByPos()) use the type code SQLT_VNU.
 
</p>

<dl></dl>
</dd>
<dt><span class="big">int <span class="underline">OCINumberInc</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>);
</span></dt>
<dd><p>Increment a number.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the positive OCI number to increment.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberDec</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>);
</span></dt>
<dd><p>Decrement a number.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the positive OCI number to decrement.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">void <span class="underline">OCINumberSetZero</span>(OCIError * <em>err</em>, OCINumber * <em>num</em>);
</span></dt>
<dd><p>Set a number to 0.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>number</td>
<td>A pointer to the OCI number to set to 0.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">void <span class="underline">OCINumberSetPi</span>(OCIError * <em>err</em>, OCINumber * <em>num</em>);
</span></dt>
<dd><p>Set a number to pi.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>number</td>
<td>A pointer to the OCI number to set to pi.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberAdd</span>(OCIError * <em>err</em>, OCINumber * <em>number1</em>, OCINumber * <em>number2</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Add one number to another.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number1</em></td>
<td>A pointer to the OCI number of the first operand.</td></tr>
<tr><td>OCINumber * <em>number2</em></td>
<td>A pointer to the OCI number of the second operand.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberSub</span>(OCIError * <em>err</em>, OCINumber * <em>number1</em>, OCINumber * <em>number2</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Subtract one number from another.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number1</em></td>
<td>A pointer to the OCI number of the first operand.</td></tr>
<tr><td>OCINumber * <em>number2</em></td>
<td>A pointer to the OCI number of the second operand.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberMul</span>(OCIError * <em>err</em>, OCINumber * <em>number1</em>, OCINumber * <em>number2</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Multiply one number by another.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number1</em></td>
<td>A pointer to the OCI number of the first operand.</td></tr>
<tr><td>OCINumber * <em>number2</em></td>
<td>A pointer to the OCI number of the second operand.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberDiv</span>(OCIError * <em>err</em>, OCINumber * <em>number1</em>, OCINumber * <em>number2</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Divide one number by another.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number1</em></td>
<td>A pointer to the OCI number of the first operand.</td></tr>
<tr><td>OCINumber * <em>number2</em></td>
<td>A pointer to the OCI number of the second operand.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberMod</span>(OCIError * <em>err</em>, OCINumber * <em>number1</em>, OCINumber * <em>number2</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>The remainder when one number is divided by another.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number1</em></td>
<td>A pointer to the OCI number of the first operand.</td></tr>
<tr><td>OCINumber * <em>number2</em></td>
<td>A pointer to the OCI number of the second operand.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberIntPower</span>(OCIError * <em>err</em>, OCINumber * <em>base</em>, int <em>exp</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Raise a number to an integral power.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>base</em></td>
<td>A pointer to the OCI number of the first operand.</td></tr>
<tr><td>int <em>exp</em></td>
<td>The second operand.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberShift</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, int <em>nDig</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Multiply a number by a power of 10.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number of the first operand.</td></tr>
<tr><td>int <em>nDig</em></td>
<td>The <em>number</em> of repetitions.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI <em>number</em> to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberNeg</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Negate a number.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to negate.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI <em>number</em> to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberToText</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, char* <em>fmt</em>, uint <em>fmt_length</em>, char* <em>nls_params</em>, uint <em>nls_p_length</em>, uint* <em>buf_size</em>, char* <em>buf</em>);
</span></dt>
<dd><p>Convert a number to a string.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to convert.</td></tr>
<tr><td>char* <em>fmt</em></td>
<td>The conversion format.</td></tr>
<tr><td>uint <em>fmt_length</em></td>
<td>The length of <em>fmt</em>.</td></tr>
<tr><td>char* <em>nls_params</em></td>
<td>The NLS format specification.  Use 0 for default.</td></tr>
<tr><td>uint <em>nls_p_length</em></td>
<td>The length of <em>nls_params</em>.</td></tr>
<tr><td>uint* <em>buf_size</em></td>
<td>The size of the buffer, used as both input and output.</td></tr>
<tr><td>char* <em>buf</em></td>
<td>A buffer to place the result of the conversion in.</td></tr>
</table>
<p><strong>See Also:</strong><br />Refer to the Oracle SQL Language Reference Manual for more details on <em>fmt</em> and <em>nls_params</em>.

</p>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberFromText</span>(OCIError * <em>err</em>, char* <em>str</em>, uint <em>str_length</em>, char* <em>fmt</em>, uint <em>fmt_length</em>, char* <em>nls_params</em>, uint <em>nls_p_length</em>, OCINumber * <em>number</em>);
</span></dt>
<dd><p>Convert a string to a number.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>char* <em>str</em></td>
<td>The string to convert.</td></tr>
<tr><td>uint <em>str_length</em></td>
<td>The length of <em>str</em>.</td></tr>
<tr><td>char* <em>fmt</em></td>
<td>The conversion format.</td></tr>
<tr><td>uint <em>fmt_length</em></td>
<td>The length of <em>fmt</em>.</td></tr>
<tr><td>char* <em>nls_params</em></td>
<td>The NLS format specification.  Use 0 for default.</td></tr>
<tr><td>uint <em>nls_p_length</em></td>
<td>The length of <em>nls_params</em>.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>See Also:</strong><br />Refer to the Oracle SQL Language Reference Manual for more details on <em>fmt</em> and <em>nls_params</em>.

</p>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_NUMBER_UNSIGNED</span>;
</span></dt>
<dd><p>Unsigned type -- ubX.
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_NUMBER_SIGNED</span>;
</span></dt>
<dd><p>Signed type -- sbX.
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberToInt</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, uint <em>rsl_length</em>, uint <em>rsl_flag</em>, void* <em>rsl</em>);
</span></dt>
<dd><p>Convert a number to an integer.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to convert.</td></tr>
<tr><td>uint <em>rsl_length</em></td>
<td>The <em>number</em> of bytes in <em>rsl</em>.</td></tr>
<tr><td>rsl_s_flag</td>
<td>Either OCI_NUMBER_UNSIGNED or OCI_NUMBER_SIGNED.</td></tr>
<tr><td>void* <em>rsl</em></td>
<td>A pointer to space for the result.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberFromInt</span>(OCIError * <em>err</em>, void* <em>inum</em>, uint <em>inum_length</em>, uint <em>inum_s_flag</em>, OCINumber * <em>number</em>);
</span></dt>
<dd><p>Convert an integer to a number.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>void* <em>inum</em></td>
<td>A pointer to the integer to convert.</td></tr>
<tr><td>uint <em>inum_length</em></td>
<td>The <em>number</em> of bytes in <em>inum</em>.</td></tr>
<tr><td>uint <em>inum_s_flag</em></td>
<td>Either OCI_NUMBER_UNSIGNED or OCI_NUMBER_SIGNED.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberToReal</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, uint <em>rsl_length</em>, void* <em>rsl</em>);
</span></dt>
<dd><p>Convert a number to a real.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to convert.</td></tr>
<tr><td>uint <em>rsl_length</em></td>
<td>The <em>number</em> of bytes in the result.</td></tr>
<tr><td>void* <em>rsl</em></td>
<td>A pointer to space for the result.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberToRealArray</span>(OCIError * <em>err</em>, OCINumber ** <em>number</em>, uint <em>elems</em>, uint <em>rsl_length</em>, void* <em>rsl</em>);
</span></dt>
<dd><p>Convert an array of number to an array of reals.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber ** <em>number</em></td>
<td>A pointer to the array of OCI numbers to convert.</td></tr>
<tr><td>uint <em>elems</em></td>
<td>The <em>number</em> of OCI numbers to convert.</td></tr>
<tr><td>uint <em>rsl_length</em></td>
<td>The <em>number</em> of bytes in the result.</td></tr>
<tr><td>void* <em>rsl</em></td>
<td>A pointer to space for the result.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberFromReal</span>(OCIError * <em>err</em>, void* <em>rnum</em>, uint <em>rnum_length</em>, OCINumber * <em>number</em>);
</span></dt>
<dd><p>Convert a real to a number.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>void* <em>rnum</em></td>
<td>A pointer to the real to convert.</td></tr>
<tr><td>uint <em>rnum_length</em></td>
<td>The <em>number</em> of bytes in the <em>rnum</em>.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberCmp</span>(OCIError * <em>err</em>, OCINumber * <em>number1</em>, OCINumber * <em>number2</em>, int* <em>result</em>);
</span></dt>
<dd><p>Compare two numbers.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number1</em></td>
<td>A pointer to the first OCI number.</td></tr>
<tr><td>OCINumber * <em>number2</em></td>
<td>A pointer to the second OCI number.</td></tr>
<tr><td>int* <em>result</em></td>
<td>The result.  0 if equal, negative if less than, or positive if greater than.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberSign</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, int* <em>result</em>);
</span></dt>
<dd><p>Get the sign of a number.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to check.</td></tr>
<tr><td>int* <em>result</em></td>
<td>The result.  0 if 0, -1 if negative, or 1 if positive.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberIsZero</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, int* <em>result</em>);
</span></dt>
<dd><p>Check if a number is 0.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to check.</td></tr>
<tr><td>int* <em>result</em></td>
<td>TRUE if it is or FALSE otherwise.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberIsInt</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, int* <em>result</em>);
</span></dt>
<dd><p>Check if a number is an integer.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to check.</td></tr>
<tr><td>int* <em>result</em></td>
<td>TRUE if it is or FALSE otherwise.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberAssign</span>(OCIError * <em>err</em>, OCINumber * <em>from</em>, OCINumber * <em>to</em>);
</span></dt>
<dd><p>Copy a number.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>from</em></td>
<td>A pointer to the source OCI number.</td></tr>
<tr><td>OCINumber * <em>to</em></td>
<td>A pointer to the target OCI number.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberAbs</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Get the absolute value of a number.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to take the absolute value of.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberCeil</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Round a number up.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to round.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberFloor</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Round a number down.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to round.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberSqrt</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Take the square root of a number..
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to square root.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberTrunc</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, int <em>decplace</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Truncate a number.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to truncate</td></tr>
<tr><td>int <em>decplace</em></td>
<td>The number of digits to the right of the decimal to keep.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberPower</span>(OCIError * <em>err</em>, OCINumber * <em>base</em>, OCINumber * <em>number</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Raise a number to a power.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>base</em></td>
<td>A pointer to the OCI number to raise to <em>number</em>.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number of the exponent.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberRound</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, int <em>decplace</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Round a number to a specified decimal place.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to round.</td></tr>
<tr><td>int <em>decplace</em></td>
<td>The number of digits to the right of the decimal to keep.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberPrec</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, int <em>nDigs</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Round a number to a specified decimal place.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to round.</td></tr>
<tr><td>decplace</td>
<td>The number of digits to keep.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberSin</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Take the sine of a number.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to take the sine of.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberArcSin</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Take the inverse sine of a number.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to take the inverse sine of.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberHypSin</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Take the hyperbolic sine of a number.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to take the hyperbolic sine of.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberCos</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Take the cosine of a number.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to take the cosine of.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberArcCos</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Take the inverse cosine of a number.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to take the inverse cosine of.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberHypCos</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Take the hyperbolic cosine of a number.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to take the hyperbolic cosine of.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberTan</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Take the tangent of a number.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to take the tangent of.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberArcTan</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Take the inverse tangent of a number.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to take the inverse tangent of.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberArcTan2</span>(OCIError * <em>err</em>, OCINumber * <em>number1</em>, OCINumber * <em>number2</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Take the inverse tangent of a number.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number1</em></td>
<td>A pointer to the OCI number of the numerator.</td></tr>
<tr><td>OCINumber * <em>number2</em></td>
<td>A pointer to the OCI number of the denominator.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberHypTan</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Take the hyperbolic tangent of a number.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to take the hyperbolic tangent of.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberExp</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Raise e to a power.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number of the exponent.</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberLn</span>(OCIError * <em>err</em>, OCINumber * <em>number</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Take the natural logarithm of a <em>number</em>.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to take the natural logarithm of..</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCINumberLog</span>(OCIError * <em>err</em>, OCINumber * <em>base</em>, OCINumber * <em>number</em>, OCINumber * <em>result</em>);
</span></dt>
<dd><p>Take the logarithm of a <em>number</em> in any <em>base</em>.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCINumber * <em>base</em></td>
<td>A pointer to the OCI number representing the <em>base</em>.</td></tr>
<tr><td>OCINumber * <em>number</em></td>
<td>A pointer to the OCI number to take the logarithm of..</td></tr>
<tr><td>OCINumber * <em>result</em></td>
<td>A pointer to the OCI number to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">struct <span class="underline">OCITime</span>;
</span></dt>
<dd><p>OCI time portion of date.
</p>
<p>This structure should be treated as an opaque structure as the format
 of this structure may change. Use OCIDateGetTime/OCIDateSetTime
 to manipulate time portion of OCIDate.
 
</p>

<dl><dt><span class="big">ubyte <span class="underline">OCITimeHH</span>;
</span></dt>
<dd><p>Hours; range is 0 &lt;= hours &lt;= 23.
</p>

</dd>
<dt><span class="big">ubyte <span class="underline">OCITimeMI</span>;
</span></dt>
<dd><p>Minutes; range is 0 &lt;= minutes &lt;= 59.
</p>

</dd>
<dt><span class="big">ubyte <span class="underline">OCITimeSS</span>;
</span></dt>
<dd><p>Seconds; range is 0 &lt;= seconds &lt;= 59.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">struct <span class="underline">OCIDate</span>;
</span></dt>
<dd><p>OCI date representation.
</p>
<p>This structure should be treated as an opaque structure as the format
 of this structure may change. Use OCIDateGetDate/OCIDateSetDate
 to access/initialize <span class="underline">OCIDate</span>.
<br /><br />

 For binding variables of type <span class="underline">OCIDate</span> in OCI calls (OCIBindByName(),
 OCIBindByPos(), and OCIDefineByPos()) use the type code SQLT_ODT.
 
</p>

<dl><dt><span class="big">short <span class="underline">OCIDateYYYY</span>;
</span></dt>
<dd><p>Gregorian year; range is -4712 &lt;= year &lt;= 9999.
</p>

</dd>
<dt><span class="big">ubyte <span class="underline">OCIDateMM</span>;
</span></dt>
<dd><p>Month; range is 1 &lt;= month &lt;= 12.
</p>

</dd>
<dt><span class="big">ubyte <span class="underline">OCIDateDD</span>;
</span></dt>
<dd><p>Day; range is 1 &lt;= day &lt;= 31.
</p>

</dd>
<dt><span class="big">OCITime <span class="underline">OCIDateTime</span>;
</span></dt>
<dd><p>Time.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">void <span class="underline">OCIDateGetTime</span>(OCIDate * <em>date</em>, ubyte* <em>hour</em>, ubyte* <em>min</em>, ubyte* <em>sec</em>);
</span></dt>
<dd><p>Get the time portion of a date.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIDate * <em>date</em></td>
<td>A pointer to the OCI date to get the time from.</td></tr>
<tr><td>ubyte* <em>hour</em></td>
<td>The hour portion of <em>date</em>.</td></tr>
<tr><td>ubyte* <em>min</em></td>
<td>The minute portion of <em>date</em>.</td></tr>
<tr><td>ubyte* <em>sec</em></td>
<td>The second portion of <em>date</em>.</td></tr>
</table>

</dd>
<dt><span class="big">void <span class="underline">OCIDateGetDate</span>(OCIDate * <em>date</em>, short* <em>year</em>, ubyte* <em>month</em>, ubyte* <em>day</em>);
</span></dt>
<dd><p>Get the date portion of a date.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIDate * <em>date</em></td>
<td>A pointer to the OCI date to get the time from.</td></tr>
<tr><td>short* <em>year</em></td>
<td>The year portion of <em>date</em>.</td></tr>
<tr><td>ubyte* <em>month</em></td>
<td>The month portion of <em>date</em>.</td></tr>
<tr><td>ubyte* <em>day</em></td>
<td>The day portion of <em>date</em>.</td></tr>
</table>

</dd>
<dt><span class="big">void <span class="underline">OCIDateSetTime</span>(OCIDate * <em>date</em>, ubyte <em>hour</em>, ubyte <em>min</em>, ubyte <em>sec</em>);
</span></dt>
<dd><p>Set the time portion of a date.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIDate * <em>date</em></td>
<td>A pointer to the OCI date to set the time of.</td></tr>
<tr><td>ubyte <em>hour</em></td>
<td>The hour portion of <em>date</em>.</td></tr>
<tr><td>ubyte <em>min</em></td>
<td>The minute portion of <em>date</em>.</td></tr>
<tr><td>ubyte <em>sec</em></td>
<td>The second portion of <em>date</em>.</td></tr>
</table>

</dd>
<dt><span class="big">void <span class="underline">OCIDateSetDate</span>(OCIDate * <em>date</em>, short <em>year</em>, ubyte <em>month</em>, ubyte <em>day</em>);
</span></dt>
<dd><p>Set the date portion of a date.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIDate * <em>date</em></td>
<td>A pointer to the OCI date to set the time of.</td></tr>
<tr><td>short <em>year</em></td>
<td>The year portion of <em>date</em>.</td></tr>
<tr><td>ubyte <em>month</em></td>
<td>The month portion of <em>date</em>.</td></tr>
<tr><td>ubyte <em>day</em></td>
<td>The day portion of <em>date</em>.</td></tr>
</table>

</dd>
<dt><span class="big">int <span class="underline">OCIDateAssign</span>(OCIError * <em>err</em>, OCIDate * <em>from</em>, OCIDate * <em>to</em>);
</span></dt>
<dd><p>Copy a date.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCIDate * <em>from</em></td>
<td>A pointer to the source OCI date.</td></tr>
<tr><td>OCIDate * <em>to</em></td>
<td>A pointer to the target OCI date.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCIDateToText</span>(OCIError * <em>err</em>, OCIDate * <em>date</em>, char* <em>fmt</em>, ubyte <em>fmt_length</em>, char* <em>lang_name</em>, uint <em>lang_length</em>, uint* <em>buf_size</em>, char* <em>buf</em>);
</span></dt>
<dd><p>Convert a date to a string.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCIDate * <em>date</em></td>
<td>A pointer to the OCI date to convert.</td></tr>
<tr><td>char* <em>fmt</em></td>
<td>The conversion format.  Defaults to "DD-Mon-YY."</td></tr>
<tr><td>ubyte <em>fmt_length</em></td>
<td>The length of <em>fmt</em>.</td></tr>
<tr><td>char* <em>lang_name</em></td>
<td>The language to use for names.  Defaults to the session language.</td></tr>
<tr><td>uint <em>lang_length</em></td>
<td>The length of <em>lang_name</em></td></tr>
<tr><td>uint* <em>buf_size</em></td>
<td>The size of the buffer, used as both input and output.</td></tr>
<tr><td>char* <em>buf</em></td>
<td>A buffer to place the result of the conversion in.</td></tr>
</table>
<p><strong>See Also:</strong><br />Refer to the Oracle SQL Language Reference Manual for more details on <em>fmt</em> and nls_params.

</p>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCIDateFromText</span>(OCIError * <em>err</em>, char* <em>date_str</em>, uint <em>d_str_length</em>, char* <em>fmt</em>, ubyte <em>fmt_length</em>, char* <em>lang_name</em>, uint <em>lang_length</em>, OCIDate * <em>date</em>);
</span></dt>
<dd><p>Convert a string to a date.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>char* <em>date_str</em></td>
<td>The string to convert.</td></tr>
<tr><td>uint <em>d_str_length</em></td>
<td>The length of str.</td></tr>
<tr><td>char* <em>fmt</em></td>
<td>The conversion format.  Defaults to "DD-Mon-YY."</td></tr>
<tr><td>ubyte <em>fmt_length</em></td>
<td>The length of <em>fmt</em>.</td></tr>
<tr><td>char* <em>lang_name</em></td>
<td>The language to use for names.  Defaults to the session language.</td></tr>
<tr><td>uint <em>lang_length</em></td>
<td>The length of <em>lang_name</em></td></tr>
<tr><td>OCIDate * <em>date</em></td>
<td>A pointer to the OCI date to place the result of the conversion in.</td></tr>
</table>
<p><strong>See Also:</strong><br />Refer to the Oracle SQL Language Reference Manual for more details on <em>fmt</em> and nls_params.

</p>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCIDateCompare</span>(OCIError * <em>err</em>, OCIDate * <em>date1</em>, OCIDate * <em>date2</em>, int* <em>result</em>);
</span></dt>
<dd><p>Compare two dates.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCIDate * <em>date1</em></td>
<td>A pointer to the first OCI date.</td></tr>
<tr><td>OCIDate * <em>date2</em></td>
<td>A pointer to the second OCI date.</td></tr>
<tr><td>int* <em>result</em></td>
<td>The result.  0 if equal, -1 if less than, or 1 if greater than.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCIDateAddMonths</span>(OCIError * <em>err</em>, OCIDate * <em>date</em>, int <em>num_months</em>, OCIDate * <em>result</em>);
</span></dt>
<dd><p>Add months to a date.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCIDate * <em>date</em></td>
<td>A pointer to the OCI <em>date</em> to add to.</td></tr>
<tr><td>int <em>num_months</em></td>
<td>The number of months to move.</td></tr>
<tr><td>OCIDate * <em>result</em></td>
<td>A pointer to the OCI date to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCIDateAddDays</span>(OCIError * <em>err</em>, OCIDate * <em>date</em>, int <em>num_days</em>, OCIDate * <em>result</em>);
</span></dt>
<dd><p>Add days to a date.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCIDate * <em>date</em></td>
<td>A pointer to the OCI <em>date</em> to add to.</td></tr>
<tr><td>int <em>num_days</em></td>
<td>The number of days to move.</td></tr>
<tr><td>OCIDate * <em>result</em></td>
<td>A pointer to the OCI date to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCIDateLastDay</span>(OCIError * <em>err</em>, OCIDate * <em>date</em>, OCIDate * <em>last_day</em>);
</span></dt>
<dd><p>Get the last day of the current month of a date.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCIDate * <em>date</em></td>
<td>A pointer to the OCI <em>date</em> to use.</td></tr>
<tr><td>OCIDate * <em>last_day</em></td>
<td>A pointer to the OCI date to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCIDateDaysBetween</span>(OCIError * <em>err</em>, OCIDate * <em>date1</em>, OCIDate * <em>date2</em>, int* <em>num_days</em>);
</span></dt>
<dd><p>Get the number of days between two dates.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCIDate * <em>date1</em></td>
<td>A pointer to the first OCI date.</td></tr>
<tr><td>OCIDate * <em>date2</em></td>
<td>A pointer to the second OCI date.</td></tr>
<tr><td>int* <em>num_days</em></td>
<td>The number of days between <em>date1</em> and <em>date2</em>.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCIDateZoneToZone</span>(OCIError * <em>err</em>, OCIDate * <em>date1</em>, char* <em>zon1</em>, uint <em>zon1_length</em>, char* <em>zon2</em>, uint <em>zon2_length</em>, OCIDate * <em>date2</em>);
</span></dt>
<dd><p>Change a date from one time zone to another.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCIDate * <em>date1</em></td>
<td>A pointer to the OCI date in time zone <em>zon1</em>.</td></tr>
<tr><td>char* <em>zon1</em></td>
<td>The time zone of <em>date1</em>.</td></tr>
<tr><td>uint <em>zon1_length</em></td>
<td>The length of <em>zon1</em>.</td></tr>
<tr><td>char* <em>zon2</em></td>
<td>The time zone of <em>date2</em>.</td></tr>
<tr><td>uint <em>zon2_length</em></td>
<td>The length of <em>zon2</em>.</td></tr>
<tr><td>OCIDate * <em>date2</em></td>
<td>A pointer to the OCI date to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCIDateNextDay</span>(OCIError * <em>err</em>, OCIDate * <em>date</em>, char* <em>day_p</em>, uint <em>day_length</em>, OCIDate * <em>next_day</em>);
</span></dt>
<dd><p>Find the next occurance of a day after a certain date.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCIDate * <em>date</em></td>
<td>A pointer to the OCI date to start at.</td></tr>
<tr><td>char* <em>day_p</em></td>
<td>The day to go to.</td></tr>
<tr><td>uint <em>day_length</em></td>
<td>The length of <em>day_p</em>.</td></tr>
<tr><td>OCIDate * <em>next_day</em></td>
<td>A pointer to the OCI date to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_DATE_INVALID_DAY</span>;
</span></dt>
<dd><p>Bad day.
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_DATE_DAY_BELOW_VALID</span>;
</span></dt>
<dd><p>Bad day low/high bit (1=low).
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_DATE_INVALID_MONTH</span>;
</span></dt>
<dd><p>Bad month.
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_DATE_MONTH_BELOW_VALID</span>;
</span></dt>
<dd><p>Bad month low/high bit (1=low).
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_DATE_INVALID_YEAR</span>;
</span></dt>
<dd><p>Bad year.
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_DATE_YEAR_BELOW_VALID</span>;
</span></dt>
<dd><p>Bad year low/high bit (1=low).
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_DATE_INVALID_HOUR</span>;
</span></dt>
<dd><p>Bad hour.
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_DATE_HOUR_BELOW_VALID</span>;
</span></dt>
<dd><p>Bad hour low/high bit (1=low).
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_DATE_INVALID_MINUTE</span>;
</span></dt>
<dd><p>Bad minute.
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_DATE_MINUTE_BELOW_VALID</span>;
</span></dt>
<dd><p>Bad minute low/high bit (1=low).
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_DATE_INVALID_SECOND</span>;
</span></dt>
<dd><p>Bad second.
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_DATE_SECOND_BELOW_VALID</span>;
</span></dt>
<dd><p>Bad second low/high bit (1=low).
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_DATE_DAY_MISSING_FROM_1582</span>;
</span></dt>
<dd><p>Day is one of those "missing" from 1582.
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_DATE_YEAR_ZERO</span>;
</span></dt>
<dd><p>Year may not equal zero.
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_DATE_INVALID_FORMAT</span>;
</span></dt>
<dd><p>Bad date format input.
</p>

</dd>
<dt><span class="big">int <span class="underline">OCIDateCheck</span>(OCIError * <em>err</em>, OCIDate * <em>date</em>, uint* <em>valid</em>);
</span></dt>
<dd><p>Check if a date is valid.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCIDate * <em>date</em></td>
<td>A pointer to the OCI date to check.</td></tr>
<tr><td>uint* <em>valid</em></td>
<td>An ORed combination of error bits.  The names start with OCI_DATE_.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCIDateSysDate</span>(OCIError * <em>err</em>, OCIDate * <em>sys_date</em>);
</span></dt>
<dd><p>Get the current system date.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCIDate * <em>sys_date</em></td>
<td>A pointer to the OCI date to put the result in.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">struct <span class="underline">OCIString</span>;
</span></dt>
<dd><p>The variable-length string is represented in C as a pointer to <span class="underline">OCIString</span>
 structure. The <span class="underline">OCIString</span> structure is opaque to the user. Functions are
 provided to allow the user to manipulate a variable-length string.
</p>
<p>A variable-length string can be declared as:
<br /><br />

 <span class="underline">OCIString</span>* vstr;
<br /><br />

 For binding variables of type <span class="underline">OCIString</span>* in OCI calls (OCIBindByName(),
 OCIBindByPos() and OCIDefineByPos()) use the external type code SQLT_VST.

</p>
<strong>Warning:</strong>
<span class="underline">OCIString</span> is implicitly <strong>null</strong> terminated.
 


<dl></dl>
</dd>
<dt><span class="big">int <span class="underline">OCIStringAssign</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIString * <em>rhs</em>, OCIString ** <em>lhs</em>);
</span></dt>
<dd><p>Copy a string.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCIString * <em>rhs</em></td>
<td>A pointer to the source OCI string.</td></tr>
<tr><td>OCIString ** <em>lhs</em></td>
<td>A pointer to a pointer to the target OCI string.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCIStringAssignText</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, char* <em>rhs</em>, uint <em>rhs_len</em>, OCIString ** <em>lhs</em>);
</span></dt>
<dd><p>Assign a C string to a string.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>char* <em>rhs</em></td>
<td>A pointer to the source string.</td></tr>
<tr><td>rhs_length</td>
<td>The length of <em>rhs</em>.</td></tr>
<tr><td>OCIString ** <em>lhs</em></td>
<td>A pointer to a pointer to the target OCI string.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCIStringResize</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, uint <em>new_size</em>, OCIString ** <em>str</em>);
</span></dt>
<dd><p>Resize a string.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>uint <em>new_size</em></td>
<td>The length to make <em>str</em>.</td></tr>
<tr><td>OCIString ** <em>str</em></td>
<td>A pointer to a pointer to the OCI string.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">uint <span class="underline">OCIStringSize</span>(OCIEnv * <em>env</em>, OCIString * <em>vs</em>);
</span></dt>
<dd><p>Get the size of a string.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIString * <em>vs</em></td>
<td>A pointer to the OCI string to check.</td></tr>
</table>
<p><strong>Returns:</strong><br />The length of <em>vs</em> in bytes.
 
</p>

</dd>
<dt><span class="big">char* <span class="underline">OCIStringPtr</span>(OCIEnv * <em>env</em>, OCIString * <em>vs</em>);
</span></dt>
<dd><p>Get a string in C string format.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIString * <em>vs</em></td>
<td>A pointer to the OCI string to convert.</td></tr>
</table>
<p><strong>Returns:</strong><br /><em>vs</em> as a C string.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCIStringAllocSize</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIString * <em>vs</em>, uint* <em>allocsize</em>);
</span></dt>
<dd><p>Get the allocated size of a string.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCIString * <em>vs</em></td>
<td>A pointer to the OCI string to check.</td></tr>
<tr><td>uint* <em>allocsize</em></td>
<td>The allocated size of <em>vs</em>.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">struct <span class="underline">OCIRaw</span>;
</span></dt>
<dd><p>The variable-length raw is represented in C as a pointer to <span class="underline">OCIRaw</span>
 structure. The <span class="underline">OCIRaw</span> structure is opaque to the user. Functions are
 provided to allow the user to manipulate a variable-length raw.
</p>
<p>A variable-length raw can be declared as:
<br /><br />

 <span class="underline">OCIRaw</span>* raw;
<br /><br />

 For binding variables of type <span class="underline">OCIRaw</span>* in OCI calls (OCIBindByName(),
 OCIBindByPos() and OCIDefineByPos()) use the external type code SQLT_LVB.
 
</p>

<dl></dl>
</dd>
<dt><span class="big">int <span class="underline">OCIRawAssignRaw</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIRaw * <em>rhs</em>, OCIRaw ** <em>lhs</em>);
</span></dt>
<dd><p>Copy a variable-length raw.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCIRaw * <em>rhs</em></td>
<td>A pointer to the source OCI variable-length raw.</td></tr>
<tr><td>OCIRaw ** <em>lhs</em></td>
<td>A pointer to a pointer to the target OCI variable-length raw.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCIRawAssignBytes</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, ubyte* <em>rhs</em>, uint <em>rhs_len</em>, OCIRaw ** <em>lhs</em>);
</span></dt>
<dd><p>Assign bytes to a variable-length raw.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>ubyte* <em>rhs</em></td>
<td>A pointer to the source bytes.</td></tr>
<tr><td>uint <em>rhs_len</em></td>
<td>The length of <em>rhs</em>.</td></tr>
<tr><td>OCIRaw ** <em>lhs</em></td>
<td>A pointer to a pointer to the target OCI variable-length raw.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCIRawResize</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, uint <em>new_size</em>, OCIRaw ** <em>raw</em>);
</span></dt>
<dd><p>Resize a variable-length raw.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>uint <em>new_size</em></td>
<td>The size to make <em>raw</em>.</td></tr>
<tr><td>OCIRaw ** <em>raw</em></td>
<td>A pointer to a pointer to the OCI variable-length raw to resize.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">uint <span class="underline">OCIRawSize</span>(OCIEnv * <em>env</em>, OCIRaw * <em>raw</em>);
</span></dt>
<dd><p>Get the size of a variable-length raw.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIRaw * <em>raw</em></td>
<td>A pointer to the OCI variable-length raw to check.</td></tr>
</table>
<p><strong>Returns:</strong><br />The number of bytes in <em>raw</em>.
 
</p>

</dd>
<dt><span class="big">ubyte* <span class="underline">OCIRawPtr</span>(OCIEnv * <em>env</em>, OCIRaw * <em>raw</em>);
</span></dt>
<dd><p>Return a variable-length raw as an array of bytes.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIRaw * <em>raw</em></td>
<td>A pointer to the OCI variable-length raw to return.</td></tr>
</table>
<p><strong>Returns:</strong><br /><em>raw</em> as an array of bytes.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCIRawAllocSize</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIRaw * <em>raw</em>, uint* <em>allocsize</em>);
</span></dt>
<dd><p>Get the allocated size of a variable-length raw.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCIRaw * <em>raw</em></td>
<td>A pointer to the OCI variable-length raw to check.</td></tr>
<tr><td>uint* <em>allocsize</em></td>
<td>The allocated size of <em>raw</em></td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">void <span class="underline">OCIRefClear</span>(OCIEnv * <em>env</em>, OCIRef * <em>ref</em>);
</span></dt>
<dd><p>Clear an object reference.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIRef * <em>ref</em></td>
<td>A pointer to the OCI object reference to clear.</td></tr>
</table>

</dd>
<dt><span class="big">int <span class="underline">OCIRefAssign</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIRef * <em>source</em>, OCIRef ** <em>target</em>);
</span></dt>
<dd><p>Copy an object reference.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCIRef * <em>source</em></td>
<td>A pointer to the source OCI object reference.</td></tr>
<tr><td>OCIRef ** <em>target</em></td>
<td>A pointer to a pointer to the target OCI object reference.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCIRefIsEqual</span>(OCIEnv * <em>env</em>, OCIRef * <em>x</em>, OCIRef * <em>y</em>);
</span></dt>
<dd><p>Test two object references for equality.
</p>
<p>Two <strong>null</strong> object references are not considered equal.

</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIRef * <em>x</em></td>
<td>A pointer to the first OCI object reference to test.</td></tr>
<tr><td>OCIRef * <em>y</em></td>
<td>A pointer to the second OCI object reference to test.</td></tr>
</table>
<p><strong>Returns:</strong><br />TRUE if they are equal or FALSE otherwise.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCIRefIsNull</span>(OCIEnv * <em>env</em>, OCIRef * <em>ref</em>);
</span></dt>
<dd><p>Test if an object reference is <strong>null</strong>.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIRef * <em>ref</em></td>
<td>A pointer to the OCI object reference to test.</td></tr>
</table>
<p><strong>Returns:</strong><br />TRUE if it is <strong>null</strong> or <strong>false</strong> otherwise.
 
</p>

</dd>
<dt><span class="big">uint <span class="underline">OCIRefHexSize</span>(OCIEnv * <em>env</em>, OCIRef * <em>ref</em>);
</span></dt>
<dd><p>Get the size of an object reference.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIRef * <em>ref</em></td>
<td>A pointer to the OCI object reference to test.</td></tr>
</table>
<p><strong>Returns:</strong><br />The size of <em>ref</em>.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCIRefFromHex</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCISvcCtx * <em>svc</em>, char* <em>hex</em>, uint <em>length</em>, OCIRef ** <em>ref</em>);
</span></dt>
<dd><p>Convert a hexadecimal string to an object reference.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCISvcCtx * <em>svc</em></td>
<td>OCI service context handle.</td></tr>
<tr><td>char* <em>hex</em></td>
<td>The source hexadecimal string.</td></tr>
<tr><td>hex_length</td>
<td>The <em>length</em> of <em>hex</em>.</td></tr>
<tr><td>OCIRef ** <em>ref</em></td>
<td>A pointer to a pointer to the resulting OCI object reference.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCIRefToHex</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIRef * <em>ref</em>, char* <em>hex</em>, uint* <em>hex_length</em>);
</span></dt>
<dd><p>Convert an object reference into a hexadecimal string.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCIRef * <em>ref</em></td>
<td>A pointer to the source OCI object reference.</td></tr>
<tr><td>char* <em>hex</em></td>
<td>A pointer to the resulting hexadecimal string.</td></tr>
<tr><td>uint* <em>hex_length</em></td>
<td>The length of <em>hex</em>.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">struct <span class="underline">OCIColl</span>;
</span></dt>
<dd><p>Generic collection type.
 
</p>

<dl></dl>
</dd>
<dt><span class="big">alias <span class="underline">OCIArray</span>;
</span></dt>
<dd><p>Varray collection type.
 
</p>

</dd>
<dt><span class="big">alias <span class="underline">OCITable</span>;
</span></dt>
<dd><p>Nested table collection type.
 
</p>

</dd>
<dt><span class="big">struct <span class="underline">OCIIter</span>;
</span></dt>
<dd><p>Collection iterator.
 
</p>

<dl></dl>
</dd>
<dt><span class="big">int <span class="underline">OCICollSize</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIColl * <em>coll</em>, int* <em>size</em>);
</span></dt>
<dd><p>Get the <em>size</em> of a collection.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCIColl * <em>coll</em></td>
<td>A pointer to the OCI collection to check.</td></tr>
<tr><td>int* <em>size</em></td>
<td>The current number of elements in <em>coll</em>.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCICollMax</span>(OCIEnv * <em>env</em>, OCIColl * <em>coll</em>);
</span></dt>
<dd><p>Get the maximum size of a collection.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIColl * <em>coll</em></td>
<td>A pointer to the OCI collection to check.</td></tr>
</table>
<p><strong>Returns:</strong><br />The maximum size of <em>coll</em> if there is one or 0 if there isn't.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCICollGetElem</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIColl * <em>coll</em>, int <em>index</em>, int* <em>exists</em>, void** <em>elem</em>, void** <em>elemind</em>);
</span></dt>
<dd><p>Get the pointer to an element of a collection by index.
</p>
<p>Optionally, you can get the address of the element's <strong>null</strong> indictator.

</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCIColl * <em>coll</em></td>
<td>A pointer to the OCI collection to retrieve the pointer from.</td></tr>
<tr><td>int <em>index</em></td>
<td>The index of the element to return the pointer of.</td></tr>
<tr><td>int* <em>exists</em></td>
<td>FALSE if there is nothing at <em>index</em> or TRUE if there is.</td></tr>
<tr><td>void** <em>elem</em></td>
<td>The pointer to the element at <em>index</em>.  The type is a pointer to the desired type.</td></tr>
<tr><td>void** <em>elemind</em></td>
<td>The address of the <strong>null</strong> indicator for <em>elem</em> unless <strong>null</strong> is passed.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCICollGetElemArray</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIColl * <em>coll</em>, int <em>index</em>, int* <em>exists</em>, void** <em>elem</em>, void** <em>elemind</em>, uint* <em>nelems</em>);
</span></dt>
<dd><p>Get the pointer to an array of elements of a collection by index.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCIColl * <em>coll</em></td>
<td>A pointer to the OCI collection to retrieve the pointer from.</td></tr>
<tr><td>int <em>index</em></td>
<td>The index of the first element to return the pointer of.</td></tr>
<tr><td>int* <em>exists</em></td>
<td>FALSE if there is nothing at <em>index</em> or TRUE if there is.</td></tr>
<tr><td>void** <em>elem</em></td>
<td>The pointer to the element at <em>index</em>.  The type is a pointer to the desired type.</td></tr>
<tr><td>void** <em>elemind</em></td>
<td>The address of the <strong>null</strong> indicator for <em>elem</em> unless <strong>null</strong> is passed.</td></tr>
<tr><td>uint* <em>nelems</em></td>
<td>The number of elements to retrieve.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCICollAssignElem</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, int <em>index</em>, void* <em>elem</em>, void* <em>elemind</em>, OCIColl * <em>coll</em>);
</span></dt>
<dd><p>Assign an element to a collection.
</p>
<p><em>elem</em> is assigned to <em>coll</em>[<em>index</em>] with a <strong>null</strong> indictator of <em>elemind</em>.

</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>int <em>index</em></td>
<td>The index of the element to to change.</td></tr>
<tr><td>void* <em>elem</em></td>
<td>A pointer to the source OCI element.</td></tr>
<tr><td>void* <em>elemind</em></td>
<td>The <strong>null</strong> indicator for <em>elem</em> unless <strong>null</strong> is passed.</td></tr>
<tr><td>OCIColl * <em>coll</em></td>
<td>A pointer to the target OCI collection.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCICollAssign</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIColl * <em>rhs</em>, OCIColl * <em>lhs</em>);
</span></dt>
<dd><p>Copy a collection.
</p>
<p><em>lhs</em> and <em>rhs</em> must be the same type of collection.  <em>rhs</em> must have at least as many
 elements as <em>rhs</em>.

</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCIColl * <em>rhs</em></td>
<td>A pointer to the source OCI collection.</td></tr>
<tr><td>OCIColl * <em>lhs</em></td>
<td>A pointer to the target OCI collection.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCICollAppend</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, void* <em>elem</em>, void* <em>elemind</em>, OCIColl * <em>coll</em>);
</span></dt>
<dd><p>Append an element to a collection.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>void* <em>elem</em></td>
<td>A pointer to the source OCI element.</td></tr>
<tr><td>void* <em>elemind</em></td>
<td>The <strong>null</strong> indicator for <em>elem</em> unless <strong>null</strong> is passed.</td></tr>
<tr><td>OCIColl * <em>coll</em></td>
<td>A pointer to the target OCI collection.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCICollTrim</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, int <em>trim_num</em>, OCIColl * <em>coll</em>);
</span></dt>
<dd><p>Remove elements from the end of a collection.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>int <em>trim_num</em></td>
<td>The number of OCI elemenets to remove.</td></tr>
<tr><td>OCIColl * <em>coll</em></td>
<td>A pointer to the target OCI collection.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success, OCI_INVALID_HANDLE on invalid parameters, or OCI_ERROR on error.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCICollIsLocator</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIColl * <em>coll</em>, int* <em>result</em>);
</span></dt>
<dd><p>Test if a collection is a locator.
</p>
<strong>Params:</strong><br /><table><tr><td>OCIEnv * <em>env</em></td>
<td>OCI environment handle initialized in object mode.</td></tr>
<tr><td>OCIError * <em>err</em></td>
<td>OCI error handle.</td></tr>
<tr><td>OCIColl * <em>coll</em></td>
<td>A pointer to the target OCI collection.</td></tr>
<tr><td>int* <em>result</em></td>
<td>TRUE is <em>coll</em> is a locator and FALSE if it isn't.</td></tr>
</table>
<p><strong>Returns:</strong><br />OCI_SUCCESS on success or OCI_INVALID_HANDLE on invalid parameters.
 
</p>

</dd>
<dt><span class="big">struct <span class="underline">OCIXMLType</span>;
</span></dt>
<dd><p>OCI representation of XMLType.
 
</p>

<dl></dl>
</dd>
<dt><span class="big">struct <span class="underline">OCIDOMDocument</span>;
</span></dt>
<dd><p>OCI representation of OCIDomDocument.
 
</p>

<dl></dl>
</dd>
</dl>

<hr />
<p><span class="small">Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. BSD license
 
</span></p>
</body>
</html>
