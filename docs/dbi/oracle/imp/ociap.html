<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<title>dbi.oracle.imp.ociap</title>
	<style type="text/css">
		.underline {
			text-decoration: underline;
		}

		.big {
			font-size: larger;
		}

		.small {
			font-size: smaller;
		}

		.red {
			color: red;
		}

		.blue {
			color: blue;
		}

		.green {
			color: green;
		}

		.yellow {
			color: yellow;
		}

		.black {
			color: black;
		}

		.white {
			color: white;
		}
	</style>
</head>
<body>
<h1>dbi.oracle.imp.ociap</h1>
<!-- Generated by Ddoc from dbi\oracle\imp\ociap.d -->
<p>Oracle import library.
</p>
<p>Part of the D DBI project.

</p>
<p><strong>Version:</strong><br />Oracle 10g revision 2
<br /><br />

	Import library version 0.02

</p>
<p><strong>Authors:</strong><br />The D DBI project

</p>

$(DDOC_MODULE_MEMBERS 
<dt><span class="big">alias <span class="underline">OCICallbackInBind</span>;
</span></dt>
$(DDOC_DECL_DD $(DDOC_SECTIONS 
<p>DESCRIPTION
*****************************************************************************
</p>
<strong>Note:</strong>
the descriptions of the functions are alphabetically arranged. Please
maintain the arrangement when adding a new function description. The actual
prototypes are below this comment section and do not follow any alphabetical
ordering.
<br /><br />

<br /><br />

--------------------------------OCIAttrGet------------------------------------
<br /><br />

OCIAttrGet()
Name
OCI Attribute Get
Purpose
This call is used to get a particular attribute of a handle.
Syntax
sword OCIAttrGet ( CONST dvoid    *trgthndlp,
                 ub4            trghndltyp,
                 dvoid          *attributep,
                 ub4            *sizep,
                 ub4            attrtype,
                 OCIError       *errhp );
Comments
This call is used to get a particular attribute of a handle.
See Appendix B,  "Handle Attributes",  for a list of handle types and their
readable attributes.
Parameters
trgthndlp (IN) - is the pointer to a handle type.
trghndltyp (IN) - is the handle type.
attributep (OUT) - is a pointer to the storage for an attribute value. The
attribute value is filled in.
sizep (OUT) - is the size of the attribute value.
This can be passed in as NULL for most parameters as the size is well known.
For text* parameters, a pointer to a ub4 must be passed in to get the length
of the string.
attrtype (IN) - is the type of attribute.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
Related Functions
OCIAttrSet()
<br /><br />

--------------------------------OCIAttrSet------------------------------------
<br /><br />

<br /><br />

OCIAttrSet()
Name
OCI Attribute Set
Purpose
This call is used to set a particular attribute of a handle or a descriptor.
Syntax
sword OCIAttrSet ( dvoid       *trgthndlp,
                 ub4         trghndltyp,
                 dvoid       *attributep,
                 ub4         size,
                 ub4         attrtype,
                 OCIError    *errhp );
Comments
This call is used to set a particular attribute of a handle or a descriptor.
See Appendix B for a list of handle types and their writeable attributes.
Parameters
trghndlp (IN/OUT) - the pointer to a handle type whose attribute gets
modified.
trghndltyp (IN/OUT) - is the handle type.
attributep (IN) - a pointer to an attribute value.
The attribute value is copied into the target handle. If the attribute value
is a pointer, then only the pointer is copied, not the contents of the pointer.
size (IN) - is the size of an attribute value. This can be passed in as 0 for
most attributes as the size is already known by the OCI library. For text*
attributes, a ub4 must be passed in set to the length of the string.
attrtype (IN) - the type of attribute being set.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
Related Functions
OCIAttrGet()
<br /><br />

<br /><br />

<br /><br />

--------------------------------OCIBindArrayOfStruct--------------------------
<br /><br />

<br /><br />

<br /><br />

OCIBindArrayOfStruct()
Name
OCI Bind for Array of Structures
Purpose
This call sets up the skip parameters for a static array bind.
Syntax
sword OCIBindArrayOfStruct ( OCIBind     *bindp,
                           OCIError    *errhp,
                           ub4         pvskip,
                           ub4         indskip,
                           ub4         alskip,
                           ub4         rcskip );
Comments
This call sets up the skip parameters necessary for a static array bind.
This call follows a call to OCIBindByName() or OCIBindByPos(). The bind
handle returned by that initial bind call is used as a parameter for the
OCIBindArrayOfStruct() call.
For information about skip parameters, see the section "Arrays of Structures"
on page 4-16.
Parameters
bindp (IN) - the handle to a bind structure.
errhp (IN) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
pvskip (IN) - skip parameter for the next data value.
indskip (IN) - skip parameter for the next indicator value or structure.
alskip (IN) - skip parameter for the next actual length value.
rcskip (IN) - skip parameter for the next column-level return code value.
Related Functions
OCIAttrGet()
<br /><br />

<br /><br />

--------------------------------OCIBindByName---------------------------------
<br /><br />

OCIBindByName()
Name
OCI Bind by Name
Purpose
Creates an association between a program variable and a placeholder in a SQL
statement or PL/SQL block.
Syntax
sword OCIBindByName (
              OCIStmt       *stmtp,
              OCIBind       **bindp,
              OCIError      *errhp,
              CONST OraText    *placeholder,
              sb4           placeh_len,
              dvoid         *valuep,
              sb4           value_sz,
              ub2           dty,
              dvoid         *indp,
              ub2           *alenp,
              ub2           *rcodep,
              ub4           maxarr_len,
              ub4           *curelep,
              ub4           mode );
Description
This call is used to perform a basic bind operation. The bind creates an
association between the address of a program variable and a placeholder in a
SQL statement or PL/SQL block. The bind call also specifies the type of data
which is being bound, and may also indicate the method by which data will be
provided at runtime.
This function also implicitly allocates the bind handle indicated by the bindp
parameter.
Data in an OCI application can be bound to placeholders statically or
dynamically. Binding is static when all the IN bind data and the OUT bind
buffers are well-defined just before the execute. Binding is dynamic when the
IN bind data and the OUT bind buffers are provided by the application on
demand at execute time to the client library. Dynamic binding is indicated by
setting the mode parameter of this call to OCI_DATA_AT_EXEC.
Related Functions: For more information about dynamic binding, see
the section "Runtime Data Allocation and Piecewise Operations" on
page 5-16.
Both OCIBindByName() and OCIBindByPos() take as a parameter a bind handle,
which is implicitly allocated by the bind call A separate bind handle is
allocated for each placeholder the application is binding.
Additional bind calls may be required to specify particular attributes
necessary when binding certain data types or handling input data in certain

<strong>ways:</strong>
If arrays of structures are being utilized, OCIBindArrayOfStruct() must
be called to set up the necessary skip parameters.
If data is being provided dynamically at runtime, and the application
will be using user-defined callback functions, OCIBindDynamic() must
be called to register the callbacks.
If a named data type is being bound, OCIBindObject() must be called to
specify additional necessary information.
Parameters
stmth (IN/OUT) - the statement handle to the SQL or PL/SQL statement
being processed.
bindp (IN/OUT) - a pointer to a pointer to a bind handle which is implicitly
allocated by this call.  The bind handle  maintains all the bind information
for this particular input value. The handle is feed implicitly when the
statement handle is deallocated.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
placeholder (IN) - the placeholder attributes are specified by name if
ocibindn() is being called.
placeh_len (IN) - the length of the placeholder name specified in placeholder.
valuep (IN/OUT) - a pointer to a data value or an array of data values of the
type specified in the dty parameter. An array of data values can be specified
for mapping into a PL/SQL table or for providing data for SQL multiple-row
operations. When an array of bind values is provided, this is called an array
bind in OCI terms. Additional attributes of the array bind (not bind to a
column of ARRAY type) are set up in OCIBindArrayOfStruct() call.
For a REF, named data type  bind, the valuep parameter is used only for IN
bind data. The pointers to OUT buffers are set in the pgvpp parameter
initialized by OCIBindObject(). For named data type and REF binds, the bind
values are unpickled into the Object Cache. The OCI object navigational calls
can then be used to navigate the objects and the refs in the Object Cache.
If the OCI_DATA_AT_EXEC mode is specified in the mode parameter, valuep
is ignored for all data types. OCIBindArrayOfStruct() cannot be used and
OCIBindDynamic() must be invoked to provide callback functions if desired.
value_sz (IN) - the size of a data value. In the case of an array bind, this is
the maximum size of any element possible with the actual sizes being specified
in the alenp parameter.
If the OCI_DATA_AT_EXEC mode is specified, valuesz defines the maximum
size of the data that can be ever provided at runtime for data types other than
named data types or REFs.
dty (IN) - the data type of the value(s) being bound. Named data types
(SQLT_NTY) and REFs (SQLT_REF) are valid only if the application has been
initialized in object mode. For named data types, or REFs, additional calls
must be made with the bind handle to set up the datatype-specific attributes.
indp (IN/OUT) - pointer to an indicator variable or array. For scalar data
types, this is a pointer to sb2 or an array of sb2s. For named data types,
this pointer is ignored and the actual pointer to the indicator structure or
an array of indicator structures is initialized by OCIBindObject().
Ignored for dynamic binds.
See the section "Indicator Variables" on page 2-43 for more information about
indicator variables.
alenp (IN/OUT) - pointer to array of actual lengths of array elements. Each
element in alenp is the length of the data in the corresponding element in the
bind value array before and after the execute. This parameter is ignored for
dynamic binds.
rcodep (OUT) - pointer to array of column level return codes. This parameter
is ignored for dynamic binds.
maxarr_len (IN) - the maximum possible number of elements of type dty in a
PL/SQL binds. This parameter is not required for non-PL/SQL binds. If
maxarr_len is non-zero, then either OCIBindDynamic() or
OCIBindArrayOfStruct() can be invoked to set up additional bind attributes.
curelep(IN/OUT) - a pointer to the actual number of elements. This parameter
is only required for PL/SQL binds.
mode (IN) - the valid modes for this parameter are:
OCI_DEFAULT. This is default mode.
OCI_DATA_AT_EXEC. When this mode is selected, the value_sz
parameter defines the maximum size of the data that can be ever
provided at runtime. The application must be ready to provide the OCI
library runtime IN data buffers at any time and any number of times.
Runtime data is provided in one of the two ways:
callbacks using a user-defined function which must be registered
with a subsequent call to OCIBindDynamic().
a polling mechanism using calls supplied by the OCI. This mode
is assumed if no callbacks are defined.
For more information about using the OCI_DATA_AT_EXEC mode, see
the section "Runtime Data Allocation and Piecewise Operations" on
page 5-16.
When the allocated buffers are not required any more, they should be
freed by the client.
Related Functions
OCIBindDynamic(), OCIBindObject(), OCIBindArrayOfStruct(), OCIAttrGet()
<br /><br />

<br /><br />

<br /><br />

-------------------------------OCIBindByPos-----------------------------------
<br /><br />

<br /><br />

OCIBindByPos()
Name
OCI Bind by Position
Purpose
Creates an association between a program variable and a placeholder in a SQL
statement or PL/SQL block.
Syntax
sword OCIBindByPos (
              OCIStmt      *stmtp,
              OCIBind      **bindp,
              OCIError     *errhp,
              ub4          position,
              dvoid        *valuep,
              sb4          value_sz,
              ub2          dty,
              dvoid        *indp,
              ub2          *alenp,
              ub2          *rcodep,
              ub4          maxarr_len,
              ub4          *curelep,
              ub4          mode);
<br /><br />

Description
This call is used to perform a basic bind operation. The bind creates an
association between the address of a program variable and a placeholder in a
SQL statement or PL/SQL block. The bind call also specifies the type of data
which is being bound, and may also indicate the method by which data will be
provided at runtime.
This function also implicitly allocates the bind handle indicated by the bindp
parameter.
Data in an OCI application can be bound to placeholders statically or
dynamically. Binding is static when all the IN bind data and the OUT bind
buffers are well-defined just before the execute. Binding is dynamic when the
IN bind data and the OUT bind buffers are provided by the application on
demand at execute time to the client library. Dynamic binding is indicated by
setting the mode parameter of this call to OCI_DATA_AT_EXEC.
Related Functions: For more information about dynamic binding, see
the section "Runtime Data Allocation and Piecewise Operations" on
page 5-16
Both OCIBindByName() and OCIBindByPos() take as a parameter a bind handle,
which is implicitly allocated by the bind call A separate bind handle is
allocated for each placeholder the application is binding.
Additional bind calls may be required to specify particular attributes
necessary when binding certain data types or handling input data in certain

<strong>ways:</strong>
If arrays of structures are being utilized, OCIBindArrayOfStruct() must
be called to set up the necessary skip parameters.
If data is being provided dynamically at runtime, and the application
will be using user-defined callback functions, OCIBindDynamic() must
be called to register the callbacks.
If a named data type is being bound, OCIBindObject() must be called to
specify additional necessary information.
Parameters
stmth (IN/OUT) - the statement handle to the SQL or PL/SQL statement
being processed.
bindp (IN/OUT) - a pointer to a pointer to a bind handle which is implicitly
allocated by this call.  The bind handle  maintains all the bind information
for this particular input value. The handle is feed implicitly when the
statement handle is deallocated.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
position (IN) - the placeholder attributes are specified by position if
ocibindp() is being called.
valuep (IN/OUT) - a pointer to a data value or an array of data values of the
type specified in the dty parameter. An array of data values can be specified
for mapping into a PL/SQL table or for providing data for SQL multiple-row
operations. When an array of bind values is provided, this is called an array
bind in OCI terms. Additional attributes of the array bind (not bind to a
column of ARRAY type) are set up in OCIBindArrayOfStruct() call.
For a REF, named data type  bind, the valuep parameter is used only for IN
bind data. The pointers to OUT buffers are set in the pgvpp parameter
initialized by OCIBindObject(). For named data type and REF binds, the bind
values are unpickled into the Object Cache. The OCI object navigational calls
can then be used to navigate the objects and the refs in the Object Cache.
If the OCI_DATA_AT_EXEC mode is specified in the mode parameter, valuep
is ignored for all data types. OCIBindArrayOfStruct() cannot be used and
OCIBindDynamic() must be invoked to provide callback functions if desired.
value_sz (IN) - the size of a data value. In the case of an array bind, this is
the maximum size of any element possible with the actual sizes being specified
in the alenp parameter.
If the OCI_DATA_AT_EXEC mode is specified, valuesz defines the maximum
size of the data that can be ever provided at runtime for data types other than
named data types or REFs.
dty (IN) - the data type of the value(s) being bound. Named data types
(SQLT_NTY) and REFs (SQLT_REF) are valid only if the application has been
initialized in object mode. For named data types, or REFs, additional calls
must be made with the bind handle to set up the datatype-specific attributes.
indp (IN/OUT) - pointer to an indicator variable or array. For scalar data
types, this is a pointer to sb2 or an array of sb2s. For named data types,
this pointer is ignored and the actual pointer to the indicator structure or
an array of indicator structures is initialized by OCIBindObject(). Ignored
for dynamic binds.
See the section "Indicator Variables" on page 2-43 for more information about
indicator variables.
alenp (IN/OUT) - pointer to array of actual lengths of array elements. Each
element in alenp is the length of the data in the corresponding element in the
bind value array before and after the execute. This parameter is ignored for
dynamic binds.
rcodep (OUT) - pointer to array of column level return codes. This parameter
is ignored for dynamic binds.
maxarr_len (IN) - the maximum possible number of elements of type dty in a
PL/SQL binds. This parameter is not required for non-PL/SQL binds. If
maxarr_len is non-zero, then either OCIBindDynamic() or
OCIBindArrayOfStruct() can be invoked to set up additional bind attributes.
curelep(IN/OUT) - a pointer to the actual number of elements. This parameter
is only required for PL/SQL binds.
mode (IN) - the valid modes for this parameter are:
OCI_DEFAULT. This is default mode.
OCI_DATA_AT_EXEC. When this mode is selected, the value_sz
parameter defines the maximum size of the data that can be ever
provided at runtime. The application must be ready to provide the OCI
library runtime IN data buffers at any time and any number of times.
Runtime data is provided in one of the two ways:
callbacks using a user-defined function which must be registered
with a subsequent call to OCIBindDynamic() .
a polling mechanism using calls supplied by the OCI. This mode
is assumed if no callbacks are defined.
For more information about using the OCI_DATA_AT_EXEC mode, see
the section "Runtime Data Allocation and Piecewise Operations" on
page 5-16.
When the allocated buffers are not required any more, they should be
freed by the client.
Related Functions
OCIBindDynamic(), OCIBindObject(), OCIBindArrayOfStruct(), OCIAttrGet()
<br /><br />

<br /><br />

<br /><br />

-------------------------------OCIBindDynamic---------------------------------
<br /><br />

OCIBindDynamic()
Name
OCI Bind Dynamic Attributes
Purpose
This call is used to register user callbacks for dynamic data allocation.
Syntax
sword OCIBindDynamic( OCIBind     *bindp,
                    OCIError    *errhp,
                    dvoid       *ictxp,
                    <span class="underline">OCICallbackInBind</span>         (icbfp)(
                                dvoid            *ictxp,
                                OCIBind          *bindp,
                                ub4              iter,
                                ub4              index,
                                dvoid            **bufpp,
                                ub4              *alenp,
                                ub1              *piecep,
                                dvoid            **indp ),
                    dvoid       *octxp,
                    OCICallbackOutBind         (ocbfp)(
                                dvoid            *octxp,
                                OCIBind          *bindp,
                                ub4              iter,
                                ub4              index,
                                dvoid            **bufp,
                                ub4              **alenpp,
                                ub1              *piecep,
                                dvoid            **indpp,
                                ub2              **rcodepp)   );
Comments
This call is used to register user-defined callback functions for providing
data for an UPDATE or INSERT if OCI_DATA_AT_EXEC mode was specified in a
previous call to OCIBindByName() or OCIBindByPos().
The callback function pointers must return OCI_CONTINUE if it the call is
successful. Any return code other than OCI_CONTINUE signals that the client
wishes to abort processing immediately.
For more information about the OCI_DATA_AT_EXEC mode, see the section
"Runtime Data Allocation and Piecewise Operations" on page 5-16.
Parameters
bindp (IN/OUT) - a bind handle returned by a call to OCIBindByName() or
OCIBindByPos().
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
ictxp (IN) - the context pointer required by the call back function icbfp.
icbfp (IN) - the callback function which returns a pointer to the IN bind
value or piece at run time. The callback takes in the following parameters.
ictxp (IN/OUT) - the context pointer for this callback function.
bindp (IN) - the bind handle passed in to uniquely identify this bind
variable.
iter (IN) - 1-based execute iteration value.
index (IN) - index of the current array, for an array bind. 1 based not
greater than curele parameter of the bind call.
index (IN) - index of the current array, for an array bind. This parameter
is 1-based, and may not be greater than curele parameter of the bind call.
bufpp (OUT) - the pointer to the buffer.
piecep (OUT) - which piece of the bind value. This can be one of the
following values - OCI_ONE_PIECE, OCI_FIRST_PIECE,
OCI_NEXT_PIECE and OCI_LAST_PIECE.
indp (OUT) - contains the indicator value. This is apointer to either an
sb2 value or a pointer to an indicator structure for binding named data
types.
indszp (OUT) - contains the indicator value size. A pointer containing
the size of either an sb2 or an indicator structure pointer.
octxp (IN) - the context pointer required by the callback function ocbfp.
ocbfp (IN) - the callback function which returns a pointer to the OUT bind
value or piece at run time. The callback takes in the following parameters.
octxp (IN/OUT) - the context pointer for this call back function.
bindp (IN) - the bind handle passed in to uniquely identify this bind
variable.
iter (IN) - 1-based execute iteration value.
index (IN) - index of the current array, for an array bind. This parameter
is 1-based, and must not be greater than curele parameter of the bind call.
bufpp (OUT) - a pointer to a buffer to write the bind value/piece.
buflp (OUT) - returns the buffer size.
alenpp (OUT) - a pointer to a storage for OCI to fill in the size of the bind
value/piece after it has been read.
piecep (IN/OUT) - which piece of the bind value. It will be set by the
library to be one of the following values - OCI_ONE_PIECE or
OCI_NEXT_PIECE. The callback function can leave it unchanged or set
it to OCI_FIRST_PIECE or OCI_LAST_PIECE. By default -
OCI_ONE_PIECE.
indpp (OUT) - returns a pointer to contain the indicator value which
either an sb2 value or a pointer to an indicator structure for named data
types.
indszpp (OUT) - returns a pointer to return the size of the indicator
value which is either size of an sb2 or size of an indicator structure.
rcodepp (OUT) - returns a pointer to contains the return code.
Related Functions
OCIAttrGet()
<br /><br />

<br /><br />

---------------------------------OCIBindObject--------------------------------
<br /><br />

<br /><br />

OCIBindObject()
Name
OCI Bind Object
Purpose
This function sets up additional attributes which are required for a named
data type (object)  bind.
Syntax
sword OCIBindObject ( OCIBind          *bindp,
                    OCIError         *errhp,
                    CONST OCIType    *type,
                    dvoid            **pgvpp,
                    ub4              *pvszsp,
                    dvoid            **indpp,
                    ub4              *indszp, );
Comments
This function sets up additional attributes which binding a named data type
or a REF. An error will be returned if this function is called when the OCI
environment has been initialized in non-object mode.
This call takes as a paramter a type descriptor object (TDO) of datatype
OCIType for the named data type being defined.  The TDO can be retrieved
with a call to OCITypeByName().
If the OCI_DATA_AT_EXEC mode was specified in ocibindn() or ocibindp(), the
pointers to the IN buffers are obtained either using the callback icbfp
registered in the OCIBindDynamic() call or by the OCIStmtSetPieceInfo() call.
The buffers are dynamically allocated for the OUT data and the pointers to
these buffers are returned either by calling ocbfp() registered by the
OCIBindDynamic() or by setting the pointer to the buffer in the buffer passed
in by OCIStmtSetPieceInfo() called when OCIStmtExecute() returned
OCI_NEED_DATA. The memory of these client library- allocated buffers must be
freed when not in use anymore by using the OCIObjectFreee() call.
Parameters
bindp ( IN/OUT) - the bind handle returned by the call to OCIBindByName()
or OCIBindByPos().
errhp ( IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
type ( IN) - points to the TDO which describes the type of the program
variable being bound. Retrieved by calling OCITypeByName().
pgvpp ( IN/OUT) - points to a pointer to the program variable buffer. For an
array, pgvpp points to an array of pointers. When the bind variable is also an
OUT variable, the OUT Named Data Type value or REF is allocated
(unpickled) in the Object Cache, and a pointer to the value or REF is returned,
At the end of execute, when all OUT values have been received, pgvpp points
to an array of pointer(s) to these newly allocated named data types in the
object cache.
pgvpp is ignored if the OCI_DATA_AT_EXEC mode is set. Then the Named
Data Type buffers are requested at runtime. For static array binds, skip
factors may be specified using the OCIBindArrayOfStruct() call. The skip
factors are used to compute the address of the next pointer to the value, the
indicator structure and their sizes.
pvszsp ( IN/OUT) - points to the size of the program variable. The size of the
named data type is not required on input. For an array, pvszsp is an array of
ub4s. On return, for OUT bind variables, this points to size(s) of the Named
Data Types and REFs received. pvszsp is ignored if the OCI_DATA_AT_EXEC
mode is set. Then the size of the buffer is taken at runtime.
indpp ( IN/OUT) - points to a pointer to the program variable buffer
containing the parallel indicator structure. For an array, points to an array
of pointers. When the bind variable is also an OUT bind variable, memory is
allocated in the object cache, to store the unpickled OUT indicator values. At
the end of the execute when all OUT values have been received, indpp points
to the pointer(s) to these newly allocated indicator structure(s).
indpp is ignored if the OCI_DATA_AT_EXEC mode is set. Then the indicator
is requested at runtime.
indszp ( IN/OUT) - points to the size of the IN indicator structure program
variable. For an array, it is an array of sb2s. On return for OUT bind
variables, this points to size(s) of the received OUT indicator structures.
indszp is ignored if the OCI_DATA_AT_EXEC mode is set. Then the indicator
size is requested at runtime.
Related Functions
OCIAttrGet()
<br /><br />

<br /><br />

<br /><br />

----------------------------------OCIBreak------------------------------------
<br /><br />

<br /><br />

OCIBreak()
Name
OCI Break
Purpose
This call performs an immediate (asynchronous) abort of any currently
executing OCI function that is associated with a server .
Syntax
sword OCIBreak ( dvoid      *hndlp,
                 OCIError   *errhp);
Comments
This call performs an immediate (asynchronous) abort of any currently
executing OCI function that is associated with a server. It is normally used
to stop a long-running OCI call being processed on the server.
This call can take either the service context handle or the server context
handle as a parameter to identify the function to be aborted.
Parameters
hndlp (IN) - the service context handle or the server context handle.
errhp (IN) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
Related Functions
<br /><br />

-----------------------------OCIConnectionPoolCreate --------------------------

<strong>Name:</strong>
OCIConnectionPoolCreate


<strong>Purpose:</strong>
Creates the connections in the pool


<strong>Syntax:</strong>
OCIConnectionPoolCreate (OCIEnv *envhp, OCIError *errhp, OCICPool *poolhp,
                         OraText **poolName, sb4 *poolNameLen,
                         CONST Oratext *dblink, sb4 dblinkLen,
                         ub4 connMin, ub4 connMax, ub4 connIncr,
                         CONST OraText *poolUsername, sb4 poolUserLen,
                         CONST OraText *poolPassword, sb4 poolPassLen,
                         ub4 mode)

<strong>Comments:</strong>
This call is used to create a connection pool. conn_min connections
to the database are started on calling OCIConnectionPoolCreate.


$(DDOC_SECTION <strong>Parameters:</strong>
envhp (IN/OUT)  - A pointer to the environment where the Conencton Pool
                  is to be created
errhp (IN/OUT)  - An error handle which can be passed to OCIErrorGet().
poolhp (IN/OUT) - An uninitialiazed pool handle.
poolName (OUT) - The connection pool name.
poolNameLen (OUT) - The length of the connection pool name
dblink (IN/OUT) - Specifies the database(server) to connect. This will also
                  be used as the default pool name.
dblinkLen (IN)  - The length of the string pointed to by dblink.
connMin (IN)    - Specifies the minimum number of connections in the
                  Connection Pool at any instant.
                  connMin number of connections are started when
                  OCIConnectionPoolCreate() is called.
connMax (IN)    - Specifies the maximum number of connections that can be
                  opened to the database. Once this value is reached, no
                  more connections are opened.
connIncr (IN)   - Allows application to set the next increment for
                  connections to be opened to the database if the current
                  number of connections are less than conn_max.
poolUsername (IN/OUT) - Connection pooling requires an implicit proxy
                         session and this attribute provides a username
                         for that session.
poolUserLen (IN) - This represents the length of pool_username.
poolPassword (IN/OUT) - The password for the parameter pool_username passed
                        above.
poolPassLen (IN) - This represents the length of pool_password.
<br /><br />

mode (IN) - The modes supported are OCI_DEFAULT and
OCI_CPOOL_REINITIALIZE
<br /><br />

Related Functions
OCIConnectionPoolDestroy()
<br /><br />

<ins><pre class="d_code">
----------------------------OCIConnectionPoolDestroy-------------------------
</pre></ins>
<strong>Name:</strong>
OCIConnectionPoolDestroy


<strong>Purpose:</strong>
Terminates the connections in the pool


<strong>Syntax:</strong>
OCIConnectionPoolDestroy (OCICPool *poolhp, OCIError *errhp, ub4 mode)


<strong>Comments:</strong>
On calling OCIConnectionPoolDestroy, all the open connections in the pool
are closed and the pool is destroyed.


$(DDOC_SECTION <strong>Parameters:</strong>
poolhp (IN/OUT) - An initialiazed pool handle.
errhp (IN/OUT)  - An error handle which can be passed to OCIErrorGet().
mode (IN)       - Currently, OCIConnectionPoolDestroy() will support only
                  the OCI_DEFAULT mode.
<br /><br />

Related Functions:
OCIConnectionPoolCreate()
<br /><br />

<ins><pre class="d_code">----------------------------OCISessionPoolCreate-----------------------------
</pre></ins>
<strong>Name:</strong>
OCISessionPoolCreate


<strong>Purpose:</strong>
Creates the sessions in the session pool.


<strong>Syntax:</strong>
sword OCISessionPoolCreate (OCIEnv *envhp, OCIError *errhp, OCISpool *spoolhp,
                      OraText **poolName, ub4 *poolNameLen,
                      CONST OraText *connStr, ub4 connStrLen,
                      ub4 sessMin, ub4 sessMax, ub4 sessIncr,
                      OraText *userid,  ub4 useridLen,
                      OraText *password, ub4 passwordLen,
                      ub4 mode)


<strong>Comments:</strong>
When OCISessionPoolCreate is called, a session pool is initialized for
the associated environment and the database specified by the
connStr parameter. This pool is named uniquely and the name
is returned to the user in the poolname parameter.


<strong>Parameters:</strong>
envhp (IN/OUT) - A pointer to the environment handle in which the session
                 pool needs to be created.
errhp (IN/OUT) - An error handle which can be passed to OCIErrorGet().
spoolhp (IN/OUT) - A pointer to the session pool handle that is created.
poolName (OUT) - Session pool name returned to the user.
poolNameLen (OUT) - Length of the PoolName
connStr (IN) - The TNS alias of the database to connect to.
connStrLen (IN) - Length of the connStr.
sessMin (IN) - Specifies the minimum number of sessions in the Session Pool.
               These are the number of sessions opened in the beginning, if
               in Homogeneous mode. Else, the parameter is ignored.
sessMax (IN) - Specifies the maximum number of sessions in the Session Pool.
               Once this value is reached, no more sessions are opened,
               unless the OCI_ATTR_SPOOL_FORCEGET is set.
userid (IN) - Specifies the userid with which to start up the sessions.
useridLen (IN) - Length of userid.
password (IN) - Specifies the password for the corresponding userid.
passwordLen (IN) - Specifies the length of the password
mode(IN) - May be OCI_DEFAULT, OCI_SPC_SPOOL_REINITIALIZE, or
           OCI_SPC_SPOOL_HOMOGENEOUS.


$(DDOC_RETURNS SUCCESS - If pool could be allocated and created successfully.
ERROR - If above conditions could not be met.
<br /><br />

Related Functions:
OCISessionPoolDestroy()
<ins><pre class="d_code">-----------------------------OCISessionPoolDestroy---------------------------
</pre></ins>
<strong>Name:</strong>
OCISessionPoolDestroy


<strong>Purpose:</strong>
Terminates all the sessions in the session pool.


<strong>Syntax:</strong>
sword OCISessionPoolDestroy (OCISPool *spoolhp, OCIError *errhp, ub4 mode)


<strong>Comments:</strong>
spoolhp (IN/OUT) - The pool handle of the session pool to be destroyed.
errhp (IN/OUT) - An error handle which can be passed to OCIErrorGet().
mode (IN) - Currently only OCI_DEFAULT mode is supported.


<p><strong>Returns:</strong><br />SUCCESS - All the sessions could be closed.
ERROR - If the above condition is not met.
<br /><br />

Related Functions:
OCISessionPoolCreate()
<ins><pre class="d_code">-------------------------------OCISessionGet---------------------------------
</pre></ins>
<strong>Name:</strong>
OCISessionGet


<strong>Purpose:</strong>
Get a session. This could be from a session pool, connection pool or
a new standalone session.


<strong>Syntax:</strong>
sword OCISessionGet(OCIenv *envhp, OCIError *errhp, OCISvcCtx **svchp,
                    OCIAuthInfo *authhp,
                    OraText *poolName, ub4 poolName_len,
                    CONST OraText *tagInfo, ub4 tagInfo_len,
                    OraText **retTagInfo, ub4 *retTagInfo_len,
                    boolean *found,
                    ub4 mode)


<strong>Comments:</strong>
envhp (IN/OUT) - OCI environment handle.
errhp (IN/OUT) - OCI error handle to be passed to OCIErrorGet().
svchp (IN/OUT) - Address of an OCI service context pointer. This will be
                 filled with a server and session handle, attached to the
                 pool.
authhp (IN/OUT) - OCI Authentication Information handle.
poolName (IN) - This indicates the session/connection pool to get the
                session/connection from in the OCI_SPOOL/OCI_CPOOL mode.
                In the OCI_DEFAULT mode it refers to the connect string.
poolName_len (IN) - length of poolName.
tagInfo (IN) - indicates the tag of the session that the user wants. If the
                   user wants a default session, he must specify a NULL here.
                   Only used for Session Pooling.
tagInfo_len (IN) - the length of tagInfo.
retTagInfo (OUT) - This indicates the type of session that is returned to
                   the user. Only used for Session Pooling.
retTagInfo_len (OUT) - the length of retTagInfo.
found (OUT) - set to <strong>true</strong> if the user gets a session he had requested, else
              set to <strong>false</strong>. Only used for Session Pooling.
mode (IN) - The supported modes are OCI_DEFAULT, OCI_CRED_PROXY and
            OCI_GET_SPOOL_MATCHANY, OCI_SPOOL and OCI_CPOOL. OCI_SPOOL and
            OCI_CPOOL are mutually exclusive.


<p><strong>Returns:</strong><br />SUCCESS -  if a session was successfully returned into svchp.
SUCCESS_WITH_INFO - if a session was successfully returned into svchp and the
                    total number of sessions &gt; maxsessions. Only valid for
                    Session Pooling.
ERROR - If a session could not be retrieved.
<br /><br />

Related Functions:
OCISessionRelease()
<ins><pre class="d_code">---------------------------OCISessionRelease---------------------------------
</pre></ins>
<strong>Name:</strong>
OCISessionRelease


<strong>Purpose:</strong>
Release the session.


<strong>Syntax:</strong>
sword OCISessionRelease ( OCISvcCtx *svchp, OCIError *errhp,
                          OraText *tag, ub4 tag_len,
                          ub4 mode);


<strong>Comments:</strong>
svchp (IN/OUT) - The service context associated with the session/connection.
errhp (IN/OUT) - OCI error handle to be passed to OCIErrorGet().
tag (IN) - Only used for Session Pooling.
           This parameter will be ignored unless mode OCI_RLS_SPOOL_RETAG is
           specified. In this case, the session is labelled with this tag and
           returned to the pool. If this is NULL, then the session is untagged.
tag_len (IN) - Length of the tag. This is ignored unless mode
               OCI_RLS_SPOOL_RETAG is set.
mode (IN) - The supported modes are OCI_DEFAULT, OCI_RLS_SPOOL_DROPSESS,
            OCI_RLS_SPOOL_RETAG. The last 2 are only valid for Session Pooling.
            When OCI_RLS_SPOOL_DROPSESS is specified, the session
            will be removed from the session pool. If OCI_RLS_SPOOL_RETAG
            is set, the tag on the session will be altered. If this mode is
            not set, the tag and tag_len parameters will be ignored.


<p><strong>Returns:</strong><br />ERROR - If the session could not be released successfully.
SUCCESS - In all other cases.
<br /><br />

Related Functions:
OCISessionGet().
<ins><pre class="d_code">------------------------------OCIDateTimeAssign --------------------------
sword OCIDateTimeAssign(dvoid *hndl, OCIError *err, CONST OCIDateTime *from,
                        OCIDateTime *to);
</pre></ins>
<strong>NAME:</strong>
OCIDateTimeAssign - OCIDateTime Assignment

<strong>PARAMETERS:</strong>
hndl (IN) - Session/Env handle.
err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
from (IN) - datetime to be assigned
to (OUT) - lhs of assignment

<strong>DESCRIPTION:</strong>
Performs date assignment. The type of the output will be same as that
        of input
<br /><br />

------------------------------OCIDateTimeCheck----------------------------
sword OCIDateTimeCheck(dvoid *hndl, OCIError *err, CONST OCIDateTime *date,
                 ub4 *valid );

<strong>NAME:</strong>
OCIDateTimeCheck - OCIDateTime CHecK if the given date is valid

<strong>PARAMETERS:</strong>
hndl (IN) - Session/Env handle.
err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
date (IN) - date to be checked
valid (OUT) -  returns zero for a valid date, otherwise
                the ORed combination of all error bits specified below:
   Macro name                   Bit number      Error
   ----------                   ----------      -----
   OCI_DATE_INVALID_DAY         0x1             Bad day
   OCI_DATE_DAY_BELOW_VALID     0x2             Bad DAy Low/high bit (1=low)
   OCI_DATE_INVALID_MONTH       0x4             Bad MOnth
   OCI_DATE_MONTH_BELOW_VALID   0x8             Bad MOnth Low/high bit (1=low)
   OCI_DATE_INVALID_YEAR        0x10            Bad YeaR
   OCI_DATE_YEAR_BELOW_VALID    0x20            Bad YeaR Low/high bit (1=low)
   OCI_DATE_INVALID_HOUR        0x40            Bad HouR
   OCI_DATE_HOUR_BELOW_VALID    0x80            Bad HouR Low/high bit (1=low)
   OCI_DATE_INVALID_MINUTE      0x100           Bad MiNute
   OCI_DATE_MINUTE_BELOW_VALID  0x200           Bad MiNute Low/high bit (1=low)
   OCI_DATE_INVALID_SECOND      0x400           Bad SeCond
   OCI_DATE_SECOND_BELOW_VALID  0x800           bad second Low/high bit (1=low)
   OCI_DATE_DAY_MISSING_FROM_1582 0x1000        Day is one of those "missing"
                                                from 1582
   OCI_DATE_YEAR_ZERO           0x2000          Year may not equal zero
   OCI_DATE_INVALID_TIMEZONE    0x4000          Bad Timezone
   OCI_DATE_INVALID_FORMAT      0x8000          Bad date format input
<br /><br />

   So, for example, if the date passed in was 2/0/1990 25:61:10 in
   (month/day/year hours:minutes:seconds format), the error returned
   would be OCI_DATE_INVALID_DAY | OCI_DATE_DAY_BELOW_VALID |
   OCI_DATE_INVALID_HOUR | OCI_DATE_INVALID_MINUTE


<strong>DESCRIPTION:</strong>
Check if the given date is valid.

<p><strong>Returns:</strong><br />OCI_SUCCESS if the function completes successfully.
        OCI_INVALID_HANDLE if 'err' is NULL.
        OCI_ERROR if
          'date' and 'valid' pointers are NULL pointers
<br /><br />

------------------------------- OCIDateTimeCompare----------------------------
sword OCIDateTimeCompare(dvoid *hndl, OCIError *err, CONST OCIDateTime *date1,
                     CONST OCIDateTime *date2,  sword *result );
</p>
<strong>NAME:</strong>
OCIDateTimeCompare - OCIDateTime CoMPare dates

<strong>PARAMETERS:</strong>
hndl (IN) - Session/Env handle.
err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
date1, date2 (IN) - dates to be compared
result (OUT) - comparison result, 0 if equal, -1 if date1 &lt; date2,
                1 if date1 &gt; date2

<strong>DESCRIPTION:</strong>
The function OCIDateCompare compares two dates. It returns -1 if
date1 is smaller than date2, 0 if they are equal, and 1 if date1 is
greater than date2.

<p><strong>Returns:</strong><br />OCI_SUCCESS if the function completes successfully.
        OCI_INVALID_HANDLE if 'err' is NULL.
        OCI_ERROR if
          invalid date
          input dates are not mutually comparable
<br /><br />

------------------------------OCIDateTimeConvert----------------------
sword OCIDateTimeConvert(dvoid *hndl, OCIError *err, OCIDateTime *indate,
                                OCIDateTime *outdate);
</p>
<strong>NAME:</strong>
OCIDateTimeConvert - Conversion between different DATETIME types

<strong>PARAMETERS:</strong>
hndl (IN) - Session/Env handle.
err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
indate (IN) - pointer to input date
outdate (OUT) - pointer to output datetime

<strong>DESCRIPTION:</strong>
Converts one datetime type to another. The result type is
       the type of the 'outdate' descriptor.

<p><strong>Returns:</strong><br />OCI_SUCCESS if the function completes successfully.
        OCI_INVALID_HANDLE if 'err' is NULL.
        OCI_ERROR if
            conversion not possible.
<br /><br />

---------------------------- OCIDateTimeFromText-----------------------
sword OCIDateTimeFromText(dvoid *hndl, OCIError *err, CONST OraText *date_str,
             size_t d_str_length, CONST OraText *fmt, ub1 fmt_length,
             CONST OraText *lang_name, size_t lang_length, OCIDateTime *date );
</p>
<strong>NAME:</strong>
OCIDateTimeFromText - OCIDateTime convert String FROM Date

<strong>PARAMETERS:</strong>
hndl (IN) - Session/Env handle. If Session Handle is passed, the
                    conversion takes place in session NLS_LANGUAGE and
                    session NLS_CALENDAR, otherwise the default is used.
err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
date_str (IN) - input string to be converted to Oracle date
d_str_length (IN) - size of the input string, if the length is -1
                then 'date_str' is treated as a <strong>null</strong> terminated  string
fmt (IN) - conversion format; if 'fmt' is a <strong>null</strong> pointer, then
                the string is expected to be in the default format for
                the datetime type.
fmt_length (IN) - length of the 'fmt' parameter
lang_name (IN) - language in which the names and abbreviations of
                days and months are specified, if <strong>null</strong> i.e. (OraText *)0,
                the default language of session is used,
lang_length (IN) - length of the 'lang_name' parameter
date (OUT) - given string converted to date

<strong>DESCRIPTION:</strong>
Converts the given string to Oracle datetime type set in the
        OCIDateTime descriptor according to the specified format. Refer to
        "TO_DATE" conversion function described in "Oracle SQL Language
        Reference Manual" for a description of format.

<p><strong>Returns:</strong><br />OCI_SUCCESS if the function completes successfully.
        OCI_INVALID_HANDLE if 'err' is NULL.
        OCI_ERROR if
          invalid format
          unknown language
          invalid input string
<br /><br />

--------------------------- OCIDateTimeGetDate-------------------------
sword OCIDateTimeGetDate(dvoid *hndl, OCIError *err,  CONST OCIDateTime *date,
                           sb2 *year, ub1 *month, ub1 *day );
</p>
<strong>NAME:</strong>
OCIDateTimeGetDate - OCIDateTime Get Date (year, month, day)
                                portion of DATETIME.

<strong>PARAMETERS:</strong>
hndl (IN) - Session/Env handle.
err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
datetime (IN) - Pointer to OCIDateTime
year      (OUT) - year value
month     (OUT) - month value
day       (OUT) - day value
<br /><br />

--------------------------- OCIDateTimeGetTime ------------------------
sword OCIDateTimeGetTime(dvoid *hndl, OCIError *err, OCIDateTime *datetime,
                 ub1 *hour, ub1 *minute, ub1 *sec, ub4 *fsec);

<strong>NAME:</strong>
OCIDateTimeGetTime - OCIDateTime Get Time (hour, min, second,
                        fractional second)  of DATETIME.

<strong>PARAMETERS:</strong>
hndl (IN) - Session/Env handle.
err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
datetime (IN) - Pointer to OCIDateTime
hour      (OUT) - hour value
minute       (OUT) - minute value
sec       (OUT) - second value
fsec      (OUT) - Fractional Second value
<br /><br />

--------------------------- OCIDateTimeGetTimeZoneOffset ----------------------
sword OCIDateTimeGetTimeZoneOffset(dvoid *hndl,OCIError *err,CONST
              OCIDateTime *datetime,sb1 *hour,sb1  *minute);


<strong>NAME:</strong>
OCIDateTimeGetTimeZoneOffset - OCIDateTime Get TimeZone (hour, minute)
                         portion of DATETIME.

<strong>PARAMETERS:</strong>
hndl (IN) - Session/Env handle.
err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
datetime (IN) - Pointer to OCIDateTime
hour      (OUT) - TimeZone Hour value
minute     (OUT) - TimeZone Minute value
<br /><br />

--------------------------- OCIDateTimeSysTimeStamp---------------------
sword OCIDateTimeSysTimeStamp(dvoid *hndl, OCIError *err,
              OCIDateTime *sys_date );


<strong>NAME:</strong>
OCIDateTimeSysTimeStamp - Returns system date/time as a TimeStamp with
                      timezone

<strong>PARAMETERS:</strong>
hndl (IN) - Session/Env handle.
err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
sys_date (OUT) - Pointer to output timestamp


<strong>DESCRIPTION:</strong>
Gets the system current date and time as a timestamp with timezone

<p><strong>Returns:</strong><br />OCI_SUCCESS if the function completes successfully.
        OCI_INVALID_HANDLE if 'err' is NULL.
<br /><br />

<br /><br />

------------------------------OCIDateTimeIntervalAdd----------------------
sword OCIDateTimeIntervalAdd(dvoid *hndl, OCIError *err, OCIDateTime *datetime,
         OCIInterval *inter, OCIDateTime *outdatetime);
</p>
<strong>NAME:</strong>
OCIDateTimeIntervalAdd - Adds an interval to datetime

<strong>PARAMETERS:</strong>
hndl (IN) - Session/Env handle.
err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
datetime (IN) - pointer to input datetime
inter    (IN) - pointer to interval
outdatetime (IN) - pointer to output datetime. The output datetime
                                will be of same type as input datetime

<strong>DESCRIPTION:</strong>
Adds an interval to a datetime to produce a resulting datetime

<p><strong>Returns:</strong><br />OCI_SUCCESS if the function completes successfully.
        OCI_INVALID_HANDLE if 'err' is NULL.
        OCI_ERROR if:
                resulting date is before Jan 1, -4713
                resulting date is after Dec 31, 9999
<br /><br />

------------------------------OCIDateTimeIntervalSub----------------------
sword OCIDateTimeIntervalSub(dvoid *hndl, OCIError *err, OCIDateTime *datetime,
              OCIInterval *inter, OCIDateTime *outdatetime);
</p>
<strong>NAME:</strong>
OCIDateTimeIntervalSub - Subtracts an interval from a datetime

<strong>PARAMETERS:</strong>
hndl (IN) - Session/Env handle.
err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
datetime (IN) - pointer to input datetime
inter    (IN) - pointer to interval
outdatetime (IN) - pointer to output datetime. The output datetime
                                will be of same type as input datetime

<strong>DESCRIPTION:</strong>
Subtracts an interval from a datetime and stores the result in a
        datetime

<p><strong>Returns:</strong><br />OCI_SUCCESS if the function completes successfully.
        OCI_INVALID_HANDLE if 'err' is NULL.
        OCI_ERROR if:
                resulting date is before Jan 1, -4713
                resulting date is after Dec 31, 9999
<br /><br />

--------------------------- OCIDateTimeConstruct-------------------------
sword OCIDateTimeConstruct(dvoid  *hndl,OCIError *err,OCIDateTime *datetime,
               sb2 year,ub1 month,ub1 day,ub1 hour,ub1 min,ub1 sec,ub4 fsec,
               OraText  *timezone,size_t timezone_length);

</p>
<strong>NAME:</strong>
OCIDateTimeConstruct - Construct an OCIDateTime. Only the relevant
       fields for the OCIDateTime descriptor types are used.

<strong>PARAMETERS:</strong>
hndl (IN) - Session/Env handle.
        err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
        datetime (IN) - Pointer to OCIDateTime
        year      (IN) - year value
        month     (IN) - month value
        day       (IN) - day value
        hour      (IN) - hour value
        min       (IN) - minute value
        sec       (IN) - second value
        fsec      (IN) - Fractional Second value
        timezone  (IN) - Timezone string
        timezone_length(IN) - Length of timezone string


<strong>DESCRIPTION:</strong>
Constructs a DateTime descriptor. The type of the datetime is the
       type of the OCIDateTime descriptor. Only the relevant fields based
       on the type are used. For Types with timezone, the date and time
       fields are assumed to be in the local time of the specified timezone.
       If timezone is not specified, then session default timezone is
       assumed.

<p><strong>Returns:</strong><br />OCI_SUCCESS if the function completes successfully.
        OCI_ERROR if datetime is not valid.
<br /><br />

------------------------------OCIDateTimeSubtract-----------------------
sword OCIDateTimeSubtract(dvoid *hndl, OCIError *err, OCIDateTime *indate1,
                OCIDateTime *indate2, OCIInterval *inter);
</p>
<strong>NAME:</strong>
OCIDateTimeSubtract - subtracts two datetimes to return an interval

<strong>PARAMETERS:</strong>
hndl (IN) - Session/Env handle.
err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
indate1(IN) - pointer to subtrahend
indate2(IN) - pointer to minuend
inter  (OUT) - pointer to output interval

<strong>DESCRIPTION:</strong>
Takes two datetimes as input and stores their difference in an
        interval. The type of the interval is the type of the 'inter'
        descriptor.

<p><strong>Returns:</strong><br />OCI_SUCCESS if the function completes successfully.
        OCI_INVALID_HANDLE if 'err' is NULL.
        OCI_ERROR if
           datetimes are not comparable.
<br /><br />

--------------------------- OCIDateTimeToText--------------------------
sword OCIDateTimeToText(dvoid *hndl, OCIError *err, CONST OCIDateTime *date,
                        CONST OraText *fmt, ub1 fmt_length, ub1 fsprec,
                        CONST OraText *lang_name, size_t lang_length,
                        ub4 *buf_size, OraText *buf );
</p>
<strong>NAME:</strong>
OCIDateTimeToText - OCIDateTime convert date TO String

<strong>PARAMETERS:</strong>
hndl (IN) - Session/Env handle. If Session Handle is passed, the
                    conversion takes place in session NLS_LANGUAGE and
                    session NLS_CALENDAR, otherwise the default is used.
err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
date (IN) - Oracle datetime to be converted
fmt (IN) - conversion format, if <strong>null</strong> string pointer (OraText*)0, then
                the date is converted to a character string in the
                default format for that type.
fmt_length (IN) - length of the 'fmt' parameter
fsprec (IN) - specifies the fractional second precision in which the
               fractional seconds is returned.
lang_name (IN) - specifies the language in which the names and
                abbreviations of months and days are returned;
                default language of session is used if 'lang_name'
                is <strong>null</strong> i.e. (OraText *)0
lang_length (IN) - length of the 'nls_params' parameter
buf_size (IN/OUT) - size of the buffer; size of the resulting string
                is returned via this parameter
buf (OUT) - buffer into which the converted string is placed

<strong>DESCRIPTION:</strong>
Converts the given date to a string according to the specified format.
        Refer to "TO_DATE" conversion function described in
        "Oracle SQL Language Reference Manual" for a description of format
        and NLS arguments. The converted <strong>null</strong>-terminated date string is
        stored in the buffer 'buf'.

<p><strong>Returns:</strong><br />OCI_SUCCESS if the function completes successfully.
        OCI_INVALID_HANDLE if 'err' is NULL.
        OCI_ERROR if
          buffer too small
          invalid format
          unknown language
          overflow error
<br /><br />

----------------------------OCIDateTimeGetTimeZoneName------------------------
sword OCIDateTimeGetTimeZoneName(dvoid *hndl,
                                 OCIError *err,
                                 CONST OCIDateTime *datetime,
                                 ub1 *buf,
                                 ub4 *buflen);
NAME OCIDateTimeGetTimeZoneName - OCI DateTime Get the Time Zone Name
</p>
<strong>PARAMETERS:</strong>
hndl (IN)      - Session/Env handle.
err (IN/OUT)   - error handle. If there is an error, it is
                 recorded in 'err' and this function returns OCI_ERROR.
                 The error recorded in 'err' can be retrieved by calling
                 OCIErrorGet().
datetime (IN)   - Pointer to an OCIDateTime.
buf (OUT)       - User allocated storage for name string.
buflen (IN/OUT) - length of buf on input, length of name on out

<strong>DESCRIPTION:</strong>
Returns either the timezone region name or the absolute hour and minute
        offset. If the DateTime was created with a region id then the region
        name will be returned in the buf.  If the region id is zero, then the
        hour and minute offset is returned as "[-]HH:MM".

<p><strong>Returns:</strong><br />OCI_SUCCESS if the function completes successfully.
       OCI_INVALID_HANDLE if 'err' is NULL.
       OCI_ERROR if
         buffer too small
         error retrieving timezone data
         invalid region
         invalid LdiDateTime type
<br /><br />

---------------------------------OCIDateTimeToArray----------------------------
sword OCIDateTimeToArray(dvoid *hndl,
                         OCIError *err,
                         CONST OCIDateTime *datetime,
                         CONST OCIInterval *reftz,
                         ub1 *outarray,
                         ub4 *len
                         ub1 *fsprec);
NAME OCIDateTimeToArray - OCI DateTime convert To Array format
</p>
<strong>PARAMETERS:</strong>
hndl (IN)      - Session/Env handle.
err (IN/OUT)   - error handle. If there is an error, it is
                 recorded in 'err' and this function returns OCI_ERROR.
                 The error recorded in 'err' can be retrieved by calling
                 OCIErrorGet().
datetime (IN)   - Pointer to OCIDateTime to be converted.
outarray (OUT)  - Result array storage
len (OUT)        - pointer to  length of outarray.
fsprec (IN)     - Number of fractional seconds digits.

<strong>DESCRIPTION:</strong>
Returns an array representing the input DateTime descriptor.

<p><strong>Returns:</strong><br />OCI_SUCCESS if the function completes successfully.
       OCI_INVALID_HANDLE if 'err' is NULL.
       OCI_ERROR if
         buffer too small
         error retrieving timezone data
         invalid region
         invalid LdiDateTime type
<br /><br />

--------------------------------OCIDateTimeFromArray---------------------------
sword OCIDateTimeFromArray(dvoid *hndl,
                         OCIError *err,
                         ub1 *inarray,
                         ub4 len
                         ub1 type
                         OCIDateTime *datetime,
                         OCIInterval *reftz,
                         ub1 fsprec);
NAME OCIDateTimeFromArray - OCI DateTime convert From Array format
</p>
<strong>PARAMETERS:</strong>
hndl (IN)      - Session/Env handle.
err (IN/OUT)   - error handle. If there is an error, it is
                 recorded in 'err' and this function returns OCI_ERROR.
                 The error recorded in 'err' can be retrieved by calling
                 OCIErrorGet().
inarray (IN)   - Pointer to input array representtion of DateTime
len (IN)       - len of inarray.
type (IN)      - One of SQLT_DATE, SQLT_TIME, SQLT_TIME_TZ, SQLT_TIMESTAMP,
                 SQLT_TIMESTAMP_TZ, or SQLT_TIMESTAMP_LTZ.
datetime (OUT) - Pointer to the result OCIDateTime.
reftz (IN)     - timezone interval used with SQLT_TIMESTAMP_LTZ.
fsprec (IN)    - fractionl seconds digits of precision (0-9).

<strong>DESCRIPTION:</strong>
Returns a pointer to an OCIDateTime of type type converted from
        the inarray.

<p><strong>Returns:</strong><br />OCI_SUCCESS if the function completes successfully.
       OCI_INVALID_HANDLE if 'err' is NULL.
       OCI_ERROR if
         buffer too small
         error retrieving timezone data
         invalid region
         invalid LdiDateTime type
<br /><br />

----------------------------------OCIRowidToChar-----------------------------
Name
OCIRowidToChar
<br /><br />

Purpose
Converts physical/logical (universal) ROWID to chracter extended (Base 64)
representation into user provided buffer outbfp of length outbflp. After
execution outbflp contains amount of bytes converted.In case of truncation
error, outbflp contains required size to make this conversion successful
and returns ORA-1405.
<br /><br />

Syntax
sword OCIRowidToChar( OCIRowid *rowidDesc,
                      OraText *outbfp,
                      ub2 *outbflp,
                      OCIError *errhp)
<br /><br />

Comments
After this conversion, ROWID in character format can be bound using
OCIBindByPos or OCIBindByName call and used to query a row at a
desired ROWID.
<br /><br />

Parameters
rowidDesc (IN)   - rowid DESCriptor which is allocated from OCIDescritorAlloc
                   and populated by a prior SQL statement execution
outbfp (OUT)     - pointer to the buffer where converted rowid in character
                   representation is stored after successful execution.
outbflp (IN/OUT) - pointer to output buffer length variable.
                   Before execution (IN mode) *outbflp contains the size of
                   outbfp, after execution (OUT mode) *outbflp contains amount
                   of bytes converted. In an event of truncation during
                   conversion *outbflp contains the required length to make
                   conversion successful.
errhp (IN/OUT)   - an error handle which can be passed to OCIErrorGet() for
                   diagnostic information in the event of an error.
<br /><br />

------------------------------OCIDefineArrayOfStruct--------------------------
<br /><br />

<br /><br />

OCIDefineArrayOfStruct()
Name
OCI Define for Array of Structures
Purpose
This call specifies additional attributes necessary for a static array define.
Syntax
sword OCIDefineArrayOfStruct ( OCIDefine   *defnp,
                             OCIError    *errhp,
                             ub4         pvskip,
                             ub4         indskip,
                             ub4         rlskip,
                             ub4         rcskip );
Comments
This call specifies additional attributes necessary for an array define,
used in an array of structures (multi-row, multi-column) fetch.
For more information about skip parameters, see the section "Skip Parameters"
on page 4-17.
Parameters
defnp (IN) - the handle to the define structure which was returned by a call
to OCIDefineByPos().
errhp (IN) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
pvskip (IN) - skip parameter for the next data value.
indskip (IN) - skip parameter for the next indicator location.
rlskip (IN) - skip parameter for the next return length value.
rcskip (IN) - skip parameter for the next return code.
Related Functions
OCIAttrGet()
<br /><br />

<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCIDefineByPos()
Name
OCI Define By Position
Purpose
Associates an item in a select-list with the type and output data buffer.
Syntax
sb4 OCIDefineByPos (
              OCIStmt     *stmtp,
              OCIDefine   **defnp,
              OCIError    *errhp,
              ub4         position,
              dvoid       *valuep,
              sb4         value_sz,
              ub2         dty,
              dvoid       *indp,
              ub2         *rlenp,
              ub2         *rcodep,
              ub4         mode );
Comments
This call defines an output buffer which will receive data retreived from
Oracle. The define is a local step which is necessary when a SELECT statement
returns data to your OCI application.
This call also implicitly allocates the define handle for the select-list item.
Defining attributes of a column for a fetch is done in one or more calls. The
first call is to OCIDefineByPos(), which defines the minimal attributes
required to specify the fetch.
This call takes as a parameter a define handle, which must have been
previously allocated with a call to OCIHandleAlloc().
Following the call to OCIDefineByPos() additional define calls may be
necessary for certain data types or fetch modes:
A call to OCIDefineArrayOfStruct() is necessary to set up skip parameters
for an array fetch of multiple columns.
A call to OCIDefineObject() is necessary to set up the appropriate
attributes of a named data type fetch. In this case the data buffer pointer
in ocidefn() is ignored.
Both OCIDefineArrayOfStruct() and OCIDefineObject() must be called
after ocidefn() in order to fetch multiple rows with a column of named
data types.
For a LOB define, the buffer pointer must be a lob locator of type
OCILobLocator , allocated by the OCIDescAlloc() call. LOB locators, and not
LOB values, are always returned for a LOB column. LOB values can then be
fetched using OCI LOB calls on the fetched locator.
For NCHAR (fixed and varying length), the buffer pointer must point to an
array of bytes sufficient for holding the required NCHAR characters.
Nested table columns are defined and fetched like any other named data type.
If the mode parameter is this call is set to OCI_DYNAMIC_FETCH, the client
application can fetch data dynamically at runtime.
Runtime data can be provided in one of two ways:
callbacks using a user-defined function which must be registered with a
subsequent call to OCIDefineDynamic(). When the client library needs a
buffer to return the fetched data, the callback will be invoked and the
runtime buffers provided will return a piece or the whole data.
a polling mechanism using calls supplied by the OCI. This mode is
assumed if no callbacks are defined. In this case, the fetch call returns the
OCI_NEED_DATA error code, and a piecewise polling method is used
to provide the data.
Related Functions: For more information about using the
OCI_DYNAMIC_FETCH mode, see the section "Runtime Data
Allocation and Piecewise Operations" on page 5-16 of Volume 1..
For more information about the define step, see the section "Defining"
on page 2-30.
Parameters
stmtp (IN) - a handle to the requested SQL query operation.
defnp (IN/OUT) - a pointer to a pointer to a define handle which is implicitly
allocated by this call.  This handle is used to  store the define information
for this column.
errhp (IN) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
position (IN) - the position of this value in the select list. Positions are
1-based and are numbered from left to right. For example, in the SELECT
statement
SELECT empno, ssn, mgrno FROM employees;
empno is at position 1, ssn is at position 2, and mgrno is at position 3.
valuep (IN/OUT) - a pointer to a buffer or an array of buffers of the type
specified in the dty parameter. A number of buffers can be specified when
results for more than one row are desired in a single fetch call.
value_sz (IN) - the size of each valuep buffer in bytes. If the data is stored
internally in VARCHAR2 format, the number of characters desired, if different
from the buffer size in bytes, may be additionally specified by the using
OCIAttrSet().
In an NLS conversion environment, a truncation error will be generated if the
number of bytes specified is insufficient to handle the number of characters
desired.
dty (IN) - the data type. Named data type (SQLT_NTY) and REF (SQLT_REF)
are valid only if the environment has been intialized with in object mode.
indp - pointer to an indicator variable or array. For scalar data types,
pointer to sb2 or an array of sb2s. Ignored for named data types. For named
data types, a pointer to a named data type indicator structure or an array of
named data type indicator structures is associated by a subsequent
OCIDefineObject() call.
See the section "Indicator Variables" on page 2-43 for more information about
indicator variables.
rlenp (IN/OUT) - pointer to array of length of data fetched. Each element in
rlenp is the length of the data in the corresponding element in the row after
the fetch.
rcodep (OUT) - pointer to array of column-level return codes
mode (IN) - the valid modes are:
OCI_DEFAULT. This is the default mode.
OCI_DYNAMIC_FETCH. For applications requiring dynamically
allocated data at the time of fetch, this mode must be used. The user may
additionally call OCIDefineDynamic() to set up a callback function that
will be invoked to receive the dynamically allocated buffers and to set
up the memory allocate/free callbacks and the context for the callbacks.
valuep and value_sz are ignored in this mode.
Related Functions
OCIDefineArrayOfStruct(), OCIDefineDynamic(), OCIDefineObject()
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCIDefineDynamic()
Name
OCI Define Dynamic Fetch Attributes
Purpose
This call is used to set the additional attributes required if the
OCI_DYNAMIC_FETCH mode was selected in OCIDefineByPos().
Syntax
sword OCIDefineDynamic( OCIDefine   *defnp,
                      OCIError    *errhp,
                      dvoid       *octxp,
                      OCICallbackDefine (ocbfp)(
                                  dvoid             *octxp,
                                  OCIDefine         *defnp,
                                  ub4               iter,
                                  dvoid             **bufpp,
                                  ub4               **alenpp,
                                  ub1               *piecep,
                                  dvoid             **indpp,
                                  ub2               **rcodep)  );
Comments
This call is used to set the additional attributes required if the
OCI_DYNAMIC_FETCH mode has been selected in a call to
OCIDefineByPos().
When the OCI_DYNAMIC_FETCH mode is selected, buffers will be
dynamically allocated for REF, and named data type, values to receive the
data. The pointers to these buffers will be returned.
If OCI_DYNAMIC_FETCH mode was selected, and the call to
OCIDefineDynamic() is skipped, then the application can fetch data piecewise
using OCI calls.
For more information about OCI_DYNAMIC_FETCH mode, see the section
"Runtime Data Allocation and Piecewise Operations" on page 5-16.
Parameters
defnp (IN/OUT) - the handle to a define structure returned by a call to
OCIDefineByPos().
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
octxp (IN) - points to a context for the callback function.
ocbfp (IN) - points to a callback function. This is invoked at runtime to get
a pointer to the buffer into which the fetched data or a piece of it will be
retreived. The callback also specifies the indicator, the return code and the
lengths of the data piece and indicator. The callback has the following
</p>
<strong>parameters:</strong>
octxp (IN) - a context pointer passed as an argument to all the callback
functions.
defnp (IN) - the define handle.
iter (IN) - which row of this current fetch.
bufpp (OUT) - returns a pointer to a buffer to store the column value, ie.
bufp points to some appropriate storage for the column value.
alenpp (OUT) - returns a pointer to the length of the buffer. *alenpp
contains the size of the buffer after return from callback. Gets set to
actual data size after fetch.
piecep (IN/OUT) - returns a piece value, as follows:
The IN value can be OCI_ONE_PIECE, OCI_FIRST_PIECE or
OCI_NEXT_PIECE.
The OUT value can be OCI_ONE_PIECE if the IN value was
OCI_ONE_PIECE.
The OUT value can be OCI_ONE_PIECE or OCI_FIRST_PIECE if
the IN value was OCI_FIRST_PIECE.
The OUT value can only be OCI_NEXT_PIECE or
OCI_LAST_PIECE if the IN value was OCI_NEXT_PIECE.
indpp (IN) - indicator variable pointer
rcodep (IN) - return code variable pointer
Related Functions
OCIAttrGet()
OCIDefineObject()
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCIDefineObject()
Name
OCI Define Named Data Type attributes
Purpose
Sets up additional attributes necessary for a Named Data Type define.
Syntax
sword OCIDefineObject ( OCIDefine       *defnp,
                      OCIError        *errhp,
                      CONST OCIType   *type,
                      dvoid           **pgvpp,
                      ub4             *pvszsp,
                      dvoid           **indpp,
                      ub4             *indszp );
Comments
This call sets up additional attributes necessary for a Named Data Type define.
An error will be returned if this function is called when the OCI environment
has been initialized in non-Object mode.
This call takes as a paramter a type descriptor object (TDO) of datatype
OCIType for the named data type being defined.  The TDO can be retrieved
with a call to OCITypeByName().
See the description of OCIInitialize() on page 13 - 43 for more information
about initializing the OCI process environment.
Parameters
defnp (IN/OUT) - a define handle previously allocated in a call to
OCIDefineByPos().
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
type (IN, optional) - points to the Type Descriptor Object (TDO) which
describes the type of the program variable. Only used for program variables
of type SQLT_NTY. This parameter is optional, and may be passed as NULL
if it is not being used.
pgvpp (IN/OUT) - points to a pointer to a program variable buffer. For an
array, pgvpp points to an array of pointers. Memory for the fetched named data
type instance(s) is dynamically allocated in the object cache. At the end of
the fetch when all the values have been received, pgvpp points to the
pointer(s) to these newly allocated named data type instance(s). The
application must call OCIObjectMarkDel() to deallocate the named data type
instance(s) when they are no longer needed.
pvszsp (IN/OUT) - points to the size of the program variable. For an array, it
is an array of ub4s. On return points to the size(s) of unpickled fetched
values.
indpp (IN/OUT) - points to a pointer to the program variable buffer
containing the parallel indicator structure. For an array, points to an array
of pointers. Memory is allocated to store the indicator structures in the
object cache. At the end of the fetch when all values have been received,
indpp points to the pointer(s) to these newly allocated indicator structure(s).
indszp (IN/OUT) - points to the size(s) of the indicator structure program
variable. For an array, it is an array of ub4s. On return points to the size(s)
of the unpickled fetched indicator values.
Related Functions
OCIAttrGet()
<br /><br />

<br /><br />

<br /><br />

OCIDescAlloc()
Name
OCI Get DESCriptor or lob locator
Purpose
Allocates storage to hold certain data types. The descriptors can be used as
bind or define variables.
Syntax
sword OCIDescAlloc ( CONST dvoid   *parenth,
                   dvoid         **descpp,
                   ub4           type,
                   size_t        xtramem_sz,
                   dvoid         **usrmempp);
Comments
Returns a pointer to an allocated and initialized structure, corresponding to
the type specified in type. A non-NULL descriptor or LOB locator is returned
on success. No diagnostics are available on error.
This call returns OCI_SUCCESS if successful, or OCI_INVALID_HANDLE if
an out-of-memory error occurs.
Parameters
parenth (IN) - an environment handle.
descpp (OUT) - returns a descriptor or LOB locator of desired type.
type (IN) - specifies the type of descriptor or LOB locator to be allocated.
The specific types are:
OCI_DTYPE_SNAP - specifies generation of snapshot descriptor of C
type - OCISnapshot
OCI_DTYPE_LOB - specifies generation of a LOB data type locator of C
type - OCILobLocator
OCI_DTYPE_RSET - specifies generation of a descriptor of C type
OCIResult that references a result set (a number of rows as a result of a
query). This descriptor is bound to a bind variable of data type
SQLT_RSET (result set). The descriptor has to be converted into a
statement handle using a function - OCIResultSetToStmt() - which can
then be passed to OCIDefineByPos() and OCIStmtFetch() to retrieve the
rows of the result set.
OCI_DTYPE_ROWID - specifies generation of a ROWID descriptor of C
type OCIRowid.
OCI_DTYPE_COMPLEXOBJECTCOMP - specifies generation of a
complex object retrieval descriptor of C type
OCIComplexObjectComp.
xtramemsz (IN) - specifies an amount of user memory to be allocated for use
by the application.
usrmempp (OUT) - returns a pointer to the user memory of size xtramemsz
allocated by the call for the user.
Related Functions
OCIDescFree()
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCIDescFree()
Name
OCI Free DESCriptor
Purpose
Deallocates a previously allocated descriptor.
Syntax
sword OCIDescFree ( dvoid    *descp,
                  ub4      type);
Comments
This call frees up storage associated with the descriptor, corresponding to the
type specified in type. Returns OCI_SUCCESS or OCI_INVALID_HANDLE.
All descriptors must be explicitly deallocated. OCI will not deallocate a
descriptor if the environment handle is deallocated.
Parameters
descp (IN) - an allocated descriptor.
type (IN) - specifies the type of storage to be freed. The specific types are:
OCI_DTYPE_SNAP - snapshot descriptor
OCI_DTYPE_LOB - a LOB data type descriptor
OCI_DTYPE_RSET - a descriptor that references a result set (a number
of rows as a result of a query).
OCI_DTYPE_ROWID - a ROWID descriptor
OCI_DTYPE_COMPLEXOBJECTCOMP - a complex object retrieval
descriptor
Related Functions
OCIDescAlloc()
<br /><br />

<br /><br />

<br /><br />

OCIDescribeAny()
Name
OCI DeSCribe Any
Purpose
Describes existing schema objects.
Syntax
sword OCIDescribeAny ( OCISvcCtx     *svchp,
                     OCIError      *errhp,
                     dvoid         *objptr,
                     ub4           objnm_len,
                     ub1           objptr_typ,
                     ub1           info_level,
                     ub1           objtype,
                     OCIDesc       *dschp );
Comments
This is a generic describe call that describes existing schema objects: tables,
views, synonyms, procedures, functions, packages, sequences, and types. As a
result of this call, the describe handle is populated with the object-specific
attributes which can be obtained through an OCIAttrGet() call.
An OCIParamGet() on the describe handle returns a parameter descriptor for a
specified position. Parameter positions begin with 1. Calling OCIAttrGet() on
the parameter descriptor returns the specific attributes of a stored procedure
or function parameter or a table column descriptor as the case may be.
These subsequent calls do not need an extra round trip to the server because
the entire schema object description cached on the client side by
OCIDescribeAny(). Calling OCIAttrGet() on the describe handle can also return
the total number of positions.
See the section "Describing" on page 2-33 for more information about describe
operations.
Parameters
TO BE UPDATED
svchp (IN/OUT) - a service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
objptr (IN) - the name of the object (a <strong>null</strong>-terminated string) to be
described. Only procedure or function names are valid when connected to an
Oracle7 Server.
objptr_len (IN) - the length of the string. Must be non-zero.
objptr_typ (IN) - Must be OCI_OTYPE_NAME, OCI_OTYPE_REF, or OCI_OTYPE_PTR.
info_level (IN) - reserved for future extensions. Pass OCI_DEFAULT.
objtype (IN/OUT) - object type.
dschp (IN/OUT) - a describe handle that is populated with describe
information about the object after the call.
Related Functions
OCIAttrGet()
<br /><br />

<br /><br />

<br /><br />

OCIEnvCreate()
Name
OCI ENVironment CREATE
Purpose
This function creates and initializes an environment for the rest of
the OCI functions to work under.  This call is a replacement for both
the OCIInitialize and OCIEnvInit calls.
Syntax
sword OCIEnvCreate  ( OCIEnv        **envhpp,
                      ub4           mode,
                      CONST dvoid   *ctxp,
                      CONST dvoid   *(*malocfp)
                                    (dvoid *ctxp,
                                        size_t size),
                      CONST dvoid   *(*ralocfp)
                                    (dvoid *ctxp,
                                       dvoid *memptr,
                                       size_t newsize),
                      CONST void    (*mfreefp)
                                    ( dvoid *ctxp,
                                       dvoid *memptr))
                      size_t    xtramemsz,
                      dvoid     **usrmempp ;
<br /><br />

Comments
This call creates an environment for all the OCI calls using the modes
specified by the user. This call can be used instead of the two calls
OCIInitialize and OCIEnvInit. This function returns an environment handle
which is then used by the remaining OCI functions. There can be multiple
environments in OCI each with its own environment modes.  This function
also performs any process level initialization if required by any mode.
For example if the user wants to initialize an environment as OCI_THREADED,
then all libraries that are used by OCI are also initialized in the
threaded mode.
<br /><br />

This call should be invoked before anny other OCI call and should be used
instead of the OCIInitialize and OCIEnvInit calls. This is the recommended
call, although OCIInitialize and OCIEnvInit calls will still be supported
for backward compatibility.
<br /><br />

envpp (OUT) - a pointer to a handle to the environment.
mode (IN) - specifies initialization of the mode. The valid modes are:
OCI_DEFAULT - default mode.
OCI_THREADED - threaded environment. In this mode, internal data
structures are protected from concurrent accesses by multiple threads.
OCI_OBJECT - will use navigational object interface.
ctxp (IN) - user defined context for the memory call back routines.
malocfp (IN) - user-defined memory allocation function. If mode is
OCI_THREADED, this memory allocation routine must be thread safe.
ctxp - context pointer for the user-defined memory allocation function.
size - size of memory to be allocated by the user-defined memory
allocation function
ralocfp (IN) - user-defined memory re-allocation function. If mode is
OCI_THREADED, this memory allocation routine must be thread safe.
ctxp - context pointer for the user-defined memory reallocation
function.
memp - pointer to memory block
newsize - new size of memory to be allocated
mfreefp (IN) - user-defined memory free function. If mode is
OCI_THREADED, this memory free routine must be thread safe.
ctxp - context pointer for the user-defined memory free function.
memptr - pointer to memory to be freed
xtramemsz (IN) - specifies the amount of user memory to be allocated.
usrmempp (OUT) - returns a pointer to the user memory of size xtramemsz
allocated by the call for the user.
<br /><br />

Example
<br /><br />

Related Functions
OCIInitialize, OCIEnvInit
<br /><br />

OCIEnvNlsCreate()
Name
OCI ENVironment CREATE with NLS info
Purpose
This function does almost everything OCIEnvCreate does, plus enabling setting
of charset and ncharset programmatically, except OCI_UTF16 mode.
Syntax
sword OCIEnvNlsCreate(OCIEnv        **envhpp,
                      ub4           mode,
                      dvoid         *ctxp,
                      dvoid         *(*malocfp)
                                    (dvoid *ctxp,
                                        size_t size),
                      dvoid         *(*ralocfp)
                                    (dvoid *ctxp,
                                       dvoid *memptr,
                                       size_t newsize),
                      void          (*mfreefp)
                                    (dvoid *ctxp,
                                       dvoid *memptr),
                      size_t        xtramemsz,
                      dvoid         **usrmempp,
                      ub2           charset,
                      ub2           ncharset)
Comments
The charset and ncharset must be both zero or non-zero.
The parameters have the same meaning as the ones in OCIEnvCreate().
When charset or ncharset is non-zero, the corresponding character set will
be used to replace the ones specified in NLS_LANG or NLS_NCHAR. Moreover,
OCI_UTF16ID is allowed to be set as charset and ncharset.
On the other hand, OCI_UTF16 mode is deprecated with this function.
Applications can achieve the same effects by setting
both charset and ncharset as OCI_UTF16ID.
<br /><br />

<br /><br />

OCIEnvInit()
Name
OCI INITialize environment
Purpose
This call initializes the OCI environment handle.
Syntax
sword OCIEnvInit ( OCIEnv    **envp,
                 ub4       mode,
                 size_t    xtramemsz,
                 dvoid     **usrmempp );
Comments
Initializes the OCI environment handle. No changes are done on an initialized
handle. If OCI_ERROR or OCI_SUCCESS_WITH_INFO is returned, the
environment handle can be used to obtain ORACLE specific errors and
diagnostics.
This call is processed locally, without a server round-trip.
Parameters
envpp (OUT) - a pointer to a handle to the environment.
mode (IN) - specifies initialization of an environment mode. The only valid
mode is OCI_DEFAULT for default mode
xtramemsz (IN) - specifies the amount of user memory to be allocated.
usrmempp (OUT) - returns a pointer to the user memory of size xtramemsz
allocated by the call for the user.
Example
See the description of OCISessionBegin() on page 13-84 for an example showing
the use of OCIEnvInit().
Related Functions
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCIErrorGet()
Name
OCI Get Diagnostic Record
Purpose
Returns an error message in the buffer provided and an ORACLE error.
Syntax
sword OCIErrorGet ( dvoid      *hndlp,
                  ub4        recordno,
                  OraText       *sqlstate,
                  ub4        *errcodep,
                  OraText       *bufp,
                  ub4        bufsiz,
                  ub4        type );
Comments
Returns an error message in the buffer provided and an ORACLE error.
Currently does not support SQL state. This call can be called a multiple
number of times if there are more than one diagnostic record for an error.
The error handle is originally allocated with a call to OCIHandleAlloc().
Parameters
hndlp (IN) - the error handle, in most cases, or the environment handle (for
errors on OCIEnvInit(), OCIHandleAlloc()).
recordno (IN) - indicates the status record from which the application seeks
info. Starts from 1.
sqlstate (OUT) - Not supported in Version 8.0.
errcodep (OUT) - an ORACLE Error is returned.
bufp (OUT) - the error message text is returned.
bufsiz (IN) - the size of the buffer provide to get the error message.
type (IN) - the type of the handle.
Related Functions
OCIHandleAlloc()
<br /><br />

OCIExtractInit
Name
OCI Extract Initialize
Purpose
This function initializes the parameter manager.
Syntax
sword OCIExtractInit(dvoid *hndl, OCIError *err);
Comments
It must be called before calling any other parameter manager routine. The NLS
information is stored inside the parameter manager context and used in
subsequent calls to OCIExtract routines.
Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR
Parameters
hndl (IN/OUT) - The OCI environment or session handle.
err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
               err and this function returns OCI_ERROR. Diagnostic information
               can be obtained by calling OCIErrorGet().
Related Functions
OCIExtractTerm()
<br /><br />

OCIExtractTerm
Name
OCI Extract Terminate
Purpose
This function releases all dynamically allocated storage and may perform
other internal bookkeeping functions.
Syntax
sword OCIExtractTerm(dvoid *hndl, OCIError *err);
Comments
It must be called when the parameter manager is no longer being used.
Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR
Parameters
hndl (IN/OUT) - The OCI environment or session handle.
err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
               err and this function returns OCI_ERROR. Diagnostic information
               can be obtained by calling OCIErrorGet().
Related Functions
OCIExtractInit()
<br /><br />

OCIExtractReset
Name
OCI Extract Reset
Purpose
The memory currently used for parameter storage, key definition storage, and
parameter value lists is freed and the structure is reinitialized.
Syntax
sword OCIExtractReset(dvoid *hndl, OCIError *err);
Comments
Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR
Parameters
hndl (IN/OUT) - The OCI environment or session handle.
err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
               err and this function returns OCI_ERROR. Diagnostic information
               can be obtained by calling OCIErrorGet().
Related Functions
<br /><br />

OCIExtractSetNumKeys
Name
OCI Extract Set Number of Keys
Purpose
Informs the parameter manager of the number of keys that will be registered.
Syntax
sword OCIExtractSetNumKeys(dvoid *hndl, OCIError *err, uword numkeys);
Comments
This routine must be called prior to the first call of OCIExtractSetKey().
Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR
Parameters
hndl (IN/OUT) - The OCI environment or session handle.
err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
               err and this function returns OCI_ERROR. Diagnostic information
               can be obtained by calling OCIErrorGet().
numkeys (IN) - The number of keys that will be registered with
               OCIExtractSetKey().
Related Functions
OCIExtractSetKey()
<br /><br />

OCIExtractSetKey
Name
OCI Extract Set Key definition
Purpose
Registers information about a key with the parameter manager.
Syntax
sword OCIExtractSetKey(dvoid *hndl, OCIError *err, CONST OraText *name,
                       ub1 type, ub4 flag, CONST dvoid *defval,
                       CONST sb4 *intrange, CONST OraText *CONST *strlist);
Comments
This routine must be called after calling OCIExtractSetKey() and before
calling OCIExtractFromFile() or OCIExtractFromStr().
Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR
Parameters
hndl (IN/OUT) - The OCI environment or session handle.
err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
               err and this function returns OCI_ERROR. Diagnostic information
               can be obtained by calling OCIErrorGet().
name (IN) - The name of the key.
type (IN) - The type of the key (OCI_EXTRACT_TYPE_INTEGER,
            OCI_EXTRACT_TYPE_OCINUM, OCI_EXTRACT_TYPE_STRING, or
            OCI_EXTRACT_TYPE_BOOLEAN).
flag (IN) - Set to OCI_EXTRACT_MULTIPLE if the key can take multiple values
            or 0 otherwise.
defval (IN) - Set to the default value for the key.  May be NULL if there is
               no default.  A string default must be a (text*) type, an
               integer default must be an (sb4*) type, and a boolean default
               must be a (ub1*) type.
intrange (IN) - Starting and ending values for the allowable range of integer
                values.  May be NULL if the key is not an integer type or if
                all integer values are acceptable.
strlist (IN) - List of all acceptable text strings for the key.  May be NULL
               if the key is not a string type or if all text values are
               acceptable.
Related Functions
OCIExtractSetNumKeys()
<br /><br />

OCIExtractFromFile
Name
OCI Extract parameters From File
Purpose
The keys and their values in the given file are processed.
Syntax
sword OCIExtractFromFile(dvoid *hndl, OCIError *err, ub4 flag,
                         OraText *filename);
Comments
Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR
Parameters
hndl (IN/OUT) - The OCI environment or session handle.
err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
               err and this function returns OCI_ERROR. Diagnostic information
               can be obtained by calling OCIErrorGet().
flag (IN) - Zero or has one or more of the following bits set:
           OCI_EXTRACT_CASE_SENSITIVE, OCI_EXTRACT_UNIQUE_ABBREVS, or
           OCI_EXTRACT_APPEND_VALUES.
filename (IN) - Null-terminated filename string.
Related Functions
<br /><br />

OCIExtractFromStr
Name
OCI Extract parameters From String
Purpose
The keys and their values in the given string are processed.
Syntax
sword OCIExtractFromStr(dvoid *hndl, OCIError *err, ub4 flag, OraText *input);
Comments
Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR
Parameters
hndl (IN/OUT) - The OCI environment or session handle.
err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
               err and this function returns OCI_ERROR. Diagnostic information
               can be obtained by calling OCIErrorGet().
flag (IN) - Zero or has one or more of the following bits set:
           OCI_EXTRACT_CASE_SENSITIVE, OCI_EXTRACT_UNIQUE_ABBREVS, or
           OCI_EXTRACT_APPEND_VALUES.
input (IN) - Null-terminated input string.
Related Functions
<br /><br />

OCIExtractToInt
Name
OCI Extract To Integer
Purpose
Gets the integer value for the specified key.
Syntax
sword OCIExtractToInt(dvoid *hndl, OCIError *err, OraText *keyname,
                      uword valno, sb4 *retval);
Comments
The valno'th value (starting with 0) is returned.
Returns OCI_SUCCESS, OCI_INVALID_HANDLE, OCI_NO_DATA, or OCI_ERROR.
OCI_NO_DATA means that there is no valno'th value for this key.
Parameters
hndl (IN) - The OCI environment or session handle.
err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
               err and this function returns OCI_ERROR. Diagnostic information
               can be obtained by calling OCIErrorGet().
keyname (IN) - Key name.
valno (IN) - Which value to get for this key.
retval (OUT) - The actual integer value.
Related Functions
<br /><br />

OCIExtractToBool
Name
OCI Extract To Boolean
Purpose
Gets the boolean value for the specified key.
Syntax
sword OCIExtractToBool(dvoid *hndl, OCIError *err, OraText *keyname,
                       uword valno, ub1 *retval);
Comments
The valno'th value (starting with 0) is returned.
Returns OCI_SUCCESS, OCI_INVALID_HANDLE, OCI_NO_DATA, or OCI_ERROR.
OCI_NO_DATA means that there is no valno'th value for this key.
Parameters
hndl (IN) - The OCI environment or session handle.
err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
               err and this function returns OCI_ERROR. Diagnostic information
               can be obtained by calling OCIErrorGet().
keyname (IN) - Key name.
valno (IN) - Which value to get for this key.
retval (OUT) - The actual boolean value.
Related Functions
<br /><br />

OCIExtractToStr
Name
OCI Extract To String
Purpose
Gets the string value for the specified key.
Syntax
sword OCIExtractToStr(dvoid *hndl, OCIError *err, OraText *keyname,
                      uword valno, OraText *retval, uword buflen);
Comments
The valno'th value (starting with 0) is returned.
Returns OCI_SUCCESS, OCI_INVALID_HANDLE, OCI_NO_DATA, or OCI_ERROR.
OCI_NO_DATA means that there is no valno'th value for this key.
Parameters
hndl (IN) - The OCI environment or session handle.
err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
               err and this function returns OCI_ERROR. Diagnostic information
               can be obtained by calling OCIErrorGet().
keyname (IN) - Key name.
valno (IN) - Which value to get for this key.
retval (OUT) - The actual <strong>null</strong>-terminated string value.
buflen (IN) - The length of the buffer for retval.
Related Functions

</p>
<strong>Note:</strong>
The following OCIExtract functions are unavailable in this release
<br /><br />

OCIExtractToOCINum
Name
OCI Extract To OCI Number
Purpose
Gets the OCINumber value for the specified key.
Syntax
sword OCIExtractToOCINum(dvoid *hndl, OCIError *err, OraText *keyname,
                         uword valno, OCINumber *retval);
Comments
The valno'th value (starting with 0) is returned.
Returns OCI_SUCCESS, OCI_INVALID_HANDLE, OCI_NO_DATA, or OCI_ERROR.
OCI_NO_DATA means that there is no valno'th value for this key.
Parameters
hndl (IN) - The OCI environment or session handle.
err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
               err and this function returns OCI_ERROR. Diagnostic information
               can be obtained by calling OCIErrorGet().
keyname (IN) - Key name.
valno (IN) - Which value to get for this key.
retval (OUT) - The actual OCINumber value.
Related Functions
<br /><br />

OCIExtractToList
Name
OCI Extract To parameter List
Purpose
Generates a list of parameters from the parameter structures that are stored
in memory.
Syntax
sword OCIExtractToList(dvoid *hndl, OCIError *err, uword *numkeys);
Comments
Must be called before OCIExtractValues() is called.
Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR
Parameters
hndl (IN) - The OCI environment or session handle.
err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
               err and this function returns OCI_ERROR. Diagnostic information
               can be obtained by calling OCIErrorGet().
numkeys (OUT) - Number of distinct keys stored in memory.
Related Functions
OCIExtractFromList()
<br /><br />

OCIExtractFromList
Name
OCI Extract From parameter List
Purpose
Generates a list of values for the a parameter in the parameter list.
Syntax
sword OCIExtractFromList(dvoid *hndl, OCIError *err, uword index,
                         OraText *name, ub1 *type, uword *numvals,
                         dvoid*** values);
Comments
Parameters are specified by an index. OCIExtractToList() must be called prior
to calling this routine to generate the parameter list from the parameter
structures that are stored in memory.
Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR
Parameters
hndl (IN) - The OCI environment or session handle.
err (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
               err and this function returns OCI_ERROR. Diagnostic information
               can be obtained by calling OCIErrorGet().
name (OUT) - Name of the key for the current parameter.
type (OUT) - Type of the current parameter (OCI_EXTRACT_TYPE_STRING,
             OCI_EXTRACT_TYPE_INTEGER, OCI_EXTRACT_TYPE_OCINUM, or
             OCI_EXTRACT_TYPE_BOOLEAN)
numvals (OUT) - Number of values for this parameter.
values (OUT) - The values for this parameter.
Related Functions
OCIExtractToList()
<br /><br />

<br /><br />

***********************  OCIFileClose() ***********************************
<br /><br />

Name
 OCIFileClose - Oracle Call Interface FILE i/o CLOSE
<br /><br />

Purpose
 Close a previously opened file.
<br /><br />

Syntax
 sword OCIFileClose ( dvoid             *hndl,
                      OCIError          *err,
                      OCIFileObject     *filep )
<br /><br />

Comments
 This function will close a previously opened file. If the function succeeds
 then OCI_SUCCESS will be returned, else OCI_ERROR.
<br /><br />

Parameters
 hndl  (IN) - the OCI environment or session handle.
 err (OUT) - the OCI error handle
 filep (IN) - the OCIFile file object
<br /><br />

Related Functions
 OCIFileOpen.
<br /><br />

<br /><br />

<br /><br />

******************** OCIFileExists() **************************************
<br /><br />

Name
 OCIFileExists - Oracle Call Interface FILE i/o EXIST
<br /><br />

Purpose
 Check to see if the file exists.
<br /><br />

Syntax
 sword OCIFileExists ( dvoid           *hndl,
                      OCIError         *err,
                      OraText          *filename,
                      OraText          *path,
                      ub1              *flag )
<br /><br />

Comments
 This function will set the flag to TRUE if the file exists else it will
 be set to FALSE.
 The function will return OCI_ERROR if any error is encountered, else
 it will return OCI_ERROR.
<br /><br />

Parameters
 hndl(IN) - OCI environment or session handle
 err(OUT) - OCI error handle
 filename(IN) - filename
 path(IN) - path of the file
 flag(OUT) - whether the file exists or not
<br /><br />

Related Functions.
 None.
<br /><br />

<br /><br />

*************************** OCIFileFlush() ******************************
<br /><br />

<br /><br />

Name
 OCIFileFlush - Oracle Call Interface File i/o FLUSH
<br /><br />

Purpose
 Flush the buffers associated with the file to the disk.
<br /><br />

Syntax
 sword OCIFileFlush ( dvoid             *hndl,
                      OCIError          *err,
                      OCIFileObject     *filep )
<br /><br />

Comments
 The function will return OCI_ERROR if any error is encountered, else
 it will return OCI_ERROR.
<br /><br />

Parameters
 hndl (IN) - the OCI environment or session handle.
 err (OUT) - the OCI error handle
 filep (IN) - the OCIFile file object
<br /><br />

Related Functions
 OCIFileOpen, OCIFileWrite
<br /><br />

<br /><br />

<br /><br />

************************** OCIFileGetLength() ****************************
<br /><br />

Name
 OCIFileGetLength - Oracle Call Interface FILE i/o GET file LENGTH
<br /><br />

Purpose
 Get the length of a file.
<br /><br />

Syntax
 OCIFileGetLength(dvoid           *hndl,
                  OCIError        *err,
                  OraText         *filename,
                  OraText         *path,
                  ubig_ora        *lenp )
<br /><br />

Comments
 The length of the file will be returned in lenp.
 The function will return OCI_ERROR if any error is encountered, else
 it will return OCI_ERROR.
<br /><br />

Parameters
 hndl (IN) - the OCI environment or session handle.
 err (OUT) - the OCI error handle.  If  there is an error, it is recorded
 in err and this function returns OCI_ERROR.  Diagnostic information can be
 obtained by calling OCIErrorGet().
 filename (IN) - file name.
 path (IN) - path of the file.
 lenp (OUT) - On output, it is the length of the file in bytes.
 is the number of bytes in the file.
<br /><br />

Related Functions
 None.
<br /><br />

<br /><br />

<br /><br />

******************************* OCIFileInit() *****************************
<br /><br />

Name
 OCIFileInit - Oracle Call Interface FILE i/o INITialize
<br /><br />

Purpose
 Initialize the OCI File I/O package and create the OCIFile context.
<br /><br />

Syntax
 sword OCIFileInit ( dvoid *hndl,
                     OCIError *err)
<br /><br />

Comments
 This function should be called before any of the OCIFile functions are
 used.
 The function will return OCI_ERROR if any error is encountered, else
 it will return OCI_ERROR.
<br /><br />

Parameters
 hndl(IN) - OCI environment or session handle.
 err(OUT) - OCI error structure.
<br /><br />

Related Functions
 OCIFileTerm
<br /><br />

<br /><br />

<br /><br />

******************************** OCIFileOpen() *****************************
<br /><br />

Name
 OCIFileOpen - Oracle Call Interface File i/o OPEN
<br /><br />

Purpose
     Open a file.
<br /><br />

Syntax
 sword OCIFileOpen ( dvoid               *hndl,
                     OCIError            *err,
                     OCIFileObject      **filep,
                     OraText             *filename,
                     OraText             *path,
                     ub4                  mode,
                     ub4                  create,
                     ub4                  type )
<br /><br />

Comments
 OCIFileOpen returns a handle to the open file in filep if the file is
 successfully opened.
 If one wants to use the standard file objects (stdin, stdout &amp; stderr)
 then OCIFileOpen whould be called with the type filed containing the
 appropriate type (see the parameter type). If any of the standard files
 are specified then filename, path, mode and create are ignored.
 The function will return OCI_ERROR if any error is encountered, else
 it will return OCI_ERROR.
<br /><br />

Parameters
 hndl (OUT) - the OCI environment or session handle.
 err (OUT) - the OCI error handle.  If  there is an error, it is recorded
 in err and this function returns OCI_ERROR.  Diagnostic information can be
 obtained by calling OCIErrorGet().
 filep (OUT) - the file object to be returned.
 filename (IN) - file name (NULL terminated string).
 path (IN) - path of the file (NULL terminated string).
 mode - mode in which to open the file (valid modes are OCI_FILE_READONLY,
 OCI_FILE_WRITEONLY, OCI_FILE_READ_WRITE).
 create - should the file be created if it does not exist. Valid values

<strong>are:</strong>
OCI_FILE_TRUNCATE - create a file regardless of whether or not it exists.
                        If the file already exists overwrite it.
     OCI_FILE_EXIST - open it if it exists, else fail.
     OCI_FILE_EXCL - fail if the file exists, else create.
     OCI_FILE_CREATE - open the file if it exists, and create it if it doesn't.
     OCI_FILE_APPEND - set the file pointer to the end of the file prior to
                      writing(this flag can be OR'ed with OCI_FILE_EXIST or
                      OCI_FILE_CREATE).
type - file type. Valid values are OCI_FILE_TEXT, OCI_FILE_BIN,
       OCI_FILE_STDIN, OCI_FILE_STDOUT and OCI_FILE_STDERR.
       If any of the standard files are specified then filename, path, mode
       and create are ignored.
<br /><br />

Related Functions.
 OCIFileClose
<br /><br />

<br /><br />

<br /><br />

************************* OCIFileRead() ************************************
<br /><br />

Name
 OCIFileRead - Oracle Call Interface FILE i/o READ
<br /><br />

Purpose
 Read from a file into a buffer.
<br /><br />

Syntax
 sword OCIFileRead ( dvoid            *hndl,
                     OCIError         *err,
                     OCIFileObject    *filep,
                     dvoid            *bufp,
                     ub4               bufl,
                     ub4              *bytesread )
<br /><br />

Comments
 Upto bufl bytes from the file will be read into bufp. The user should
 allocate memory for the buffer.
 The number of bytes read would be in bytesread.
 The function will return OCI_ERROR if any error is encountered, else
 it will return OCI_ERROR.
<br /><br />

Parameters
 hndl (IN) - the OCI environment or session handle.
 err (OUT) - the OCI error handle.  If  there is an error, it is recorded
 in err and this function returns OCI_ERROR.  Diagnostic information can be
 obtained by calling OCIErrorGet().
 filep (IN/OUT) - a File Object that uniquely references the file.
 bufp (IN) - the pointer to a buffer into which the data will be read. The
 length of the allocated memory is assumed to be bufl.
 bufl - the length of the buffer in bytes.
 bytesread (OUT) - the number of bytes read.
<br /><br />

Related Functions
 OCIFileOpen, OCIFileSeek, OCIFileWrite
<br /><br />

<br /><br />

<br /><br />

***************************** OCIFileSeek() ******************************
<br /><br />

Name
 OCIFileSeek - Oracle Call Interface FILE i/o SEEK
<br /><br />

Purpose
 Perfom a seek to a byte position.
<br /><br />

Syntax
 sword OCIFileSeek ( dvoid           *hndl,
                     OCIError        *err,
                     OCIFileObject   *filep,
                     uword            origin,
                     ubig_ora         offset,
                     sb1              dir)
<br /><br />

Comments
 The function will return OCI_ERROR if any error is encountered, else
 it will return OCI_ERROR.
<br /><br />

Parameters
 hndl (IN) - the OCI environment or session handle.
 err (OUT) - the OCI error handle.  If  there is an error, it is recorded
 in err and this function returns OCI_ERROR.  Diagnostic information can be
 obtained by calling OCIErrorGet().
 filep (IN/OUT) - a file handle that uniquely references the file.
 origin - The starting point we want to seek from. NOTE: The starting
 point may be OCI_FILE_SEEK_BEGINNING (beginning), OCI_FILE_SEEK_CURRENT
 (current position), or OCI_FILE_SEEK_END (end of file).
 offset - The number of bytes from the origin we want to start reading from.
 dir - The direction we want to go from the origin. NOTE: The direction
 can be either OCI_FILE_FORWARD or OCI_FILE_BACKWARD.
<br /><br />

Related Function
 OCIFileOpen, OCIFileRead, OCIFileWrite
<br /><br />

<br /><br />

<br /><br />

************************** OCIFileTerm() **********************************
<br /><br />

Name
 OCIFileTerm - Oracle Call Interface FILE i/o TERMinate
<br /><br />

Purpose
 Terminate the OCI File I/O package and destroy the OCI File context.
<br /><br />

Syntax
 sword OCIFileTerm ( dvoid *hndl,
                     OCIError *err )
<br /><br />

Comments
 After this function has been called no OCIFile function should be used.
 The function will return OCI_ERROR if any error is encountered, else
 it will return OCI_ERROR.
<br /><br />

Parameters
 hndl(IN) - OCI environment or session handle.
 err(OUT) - OCI error structure.
<br /><br />

Related Functions
 OCIFileInit
<br /><br />

<br /><br />

******************************** OCIFileWrite() ****************************
<br /><br />

Name
 OCIFileWrite - Oracle Call Interface FILE i/o WRITE
<br /><br />

Purpose
  Write data from buffer into a file.
<br /><br />

Syntax
 sword OCIFileWrite ( dvoid            *hndl,
                      OCIError         *err,
                      OCIFileObject    *filep,
                      dvoid            *bufp,
                      ub4               buflen
                      ub4              *byteswritten )
<br /><br />

Comments
 The number of bytes written will be in *byteswritten.
 The function will return OCI_ERROR if any error is encountered, else
 it will return OCI_ERROR.
<br /><br />

Parameters
 hndl (IN) - the OCI environment or session handle.
 err (OUT) - the OCI error handle.  If  there is an error, it is recorded
 in err and this function returns OCI_ERROR.  Diagnostic information can be
 obtained by calling OCIErrorGet().
 filep (IN/OUT) - a file handle that uniquely references the file.
 bufp (IN) - the pointer to a buffer from which the data will be written.
 The length of the allocated memory is assumed to be the value passed
 in bufl.
 bufl - the length of the buffer in bytes.
 byteswritten (OUT) - the number of bytes written.
<br /><br />

Related Functions
 OCIFileOpen, OCIFileSeek, OCIFileRead
<br /><br />

<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCIHandleAlloc()
Name
OCI Get HaNDLe
Purpose
This call returns a pointer to an allocated and initialized handle.
Syntax
sword OCIHandleAlloc ( CONST dvoid   *parenth,
                     dvoid         **hndlpp,
                     ub4           type,
                     size_t        xtramem_sz,
                     dvoid         **usrmempp);
Comments
Returns a pointer to an allocated and initialized structure, corresponding to
the type specified in type. A non-NULL handle is returned on success. Bind
handle and define handles are allocated with respect to a statement handle. All
other handles are allocated with respect to an environment handle which is
passed in as a parent handle.
No diagnostics are available on error. This call returns OCI_SUCCESS if
successful, or OCI_INVALID_HANDLE if an out-of-memory error occurs.
Handles must be allocated using OCIHandleAlloc() before they can be passed
into an OCI call.
Parameters
parenth (IN) - an environment or a statement handle.
hndlpp (OUT) - returns a handle to a handle type.
type (IN) - specifies the type of handle to be allocated. The specific types

<strong>are:</strong>
OCI_HTYPE_ERROR - specifies generation of an error report handle of
C type OCIError
OCI_HTYPE_SVCCTX - specifies generation of a service context handle
of C type OCISvcCtx
OCI_HTYPE_STMT - specifies generation of a statement (application
request) handle of C type OCIStmt
OCI_HTYPE_BIND - specifies generation of a bind information handle
of C type OCIBind
OCI_HTYPE_DEFINE - specifies generation of a column definition
handle of C type OCIDefine
OCI_HTYPE_DESCRIBE  - specifies generation of a select list
description handle of C type OCIDesc
OCI_HTYPE_SERVER - specifies generation of a server context handle
of C type OCIServer
OCI_HTYPE_SESSION - specifies generation of an authentication
context handle of C type OCISession
OCI_HTYPE_TRANS - specifies generation of a transaction context
handle of C type OCITrans
OCI_HTYPE_COMPLEXOBJECT - specifies generation of a complex
object retrieval handle of C type OCIComplexObject
OCI_HTYPE_SECURITY - specifies generation of a security handle of C
type OCISecurity
xtramem_sz (IN) - specifies an amount of user memory to be allocated.
usrmempp (OUT) - returns a pointer to the user memory of size xtramemsz
allocated by the call for the user.
Related Functions
OCIHandleFree()
<br /><br />

<br /><br />

<br /><br />

OCIHandleFree()
Name
OCI Free HaNDLe
Purpose
This call explicitly deallocates a handle.
Syntax
sword OCIHandleFree ( dvoid     *hndlp,
                    ub4       type);
Comments
This call frees up storage associated with a handle, corresponding to the type
specified in the type parameter.
This call returns either OCI_SUCCESS or OCI_INVALID_HANDLE.
All handles must be explicitly deallocated. OCI will not deallocate a child
handle if the parent is deallocated.
Parameters
hndlp (IN) - an opaque pointer to some storage.
type (IN) - specifies the type of storage to be allocated. The specific types

<strong>are:</strong>
OCI_HTYPE_ENV - an environment handle
OCI_HTYPE_ERROR - an error report handle
OCI_HTYPE_SVCCTX - a service context handle
OCI_HTYPE_STMT - a statement (application request) handle
OCI_HTYPE_BIND - a bind information handle
OCI_HTYPE_DEFINE - a column definition handle
OCI_HTYPE_DESCRIBE  - a select list description handle
OCI_HTYPE_SERVER - a server handle
OCI_HTYPE_SESSION - a user authentication handle
OCI_HTYPE_TRANS - a transaction handle
OCI_HTYPE_COMPLEXOBJECT - a complex object retrieval handle
OCI_HTYPE_SECURITY - a security handle
Related Functions
OCIHandleAlloc()
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCIInitialize()
Name
OCI Process Initialize
Purpose
Initializes the OCI process environment.
Syntax
sword OCIInitialize ( ub4           mode,
                    CONST dvoid   *ctxp,
                    CONST dvoid   *(*malocfp)
                                  ( dvoid *ctxp,
                                    size_t size ),
                    CONST dvoid   *(*ralocfp)
                                  ( dvoid *ctxp,
                                    dvoid *memp,
                                    size_t newsize ),
                    CONST void    (*mfreefp)
                                  ( dvoid *ctxp,
                                    dvoid *memptr ));
Comments
This call initializes the OCI process environment.
OCIInitialize() must be invoked before any other OCI call.
Parameters
mode (IN) - specifies initialization of the mode. The valid modes are:
OCI_DEFAULT - default mode.
OCI_THREADED - threaded environment. In this mode, internal data
structures are protected from concurrent accesses by multiple threads.
OCI_OBJECT - will use navigational object interface.
ctxp (IN) - user defined context for the memory call back routines.
malocfp (IN) - user-defined memory allocation function. If mode is
OCI_THREADED, this memory allocation routine must be thread safe.
ctxp - context pointer for the user-defined memory allocation function.
size - size of memory to be allocated by the user-defined memory
allocation function
ralocfp (IN) - user-defined memory re-allocation function. If mode is
OCI_THREADED, this memory allocation routine must be thread safe.
ctxp - context pointer for the user-defined memory reallocation
function.
memp - pointer to memory block
newsize - new size of memory to be allocated
mfreefp (IN) - user-defined memory free function. If mode is
OCI_THREADED, this memory free routine must be thread safe.
ctxp - context pointer for the user-defined memory free function.
memptr - pointer to memory to be freed
Example
See the description of OCIStmtPrepare() on page 13-96 for an example showing
the use of OCIInitialize().
Related Functions
<br /><br />

-------------------------------OCITerminate------------------------------------
<br /><br />

OCITerminate()
Name
OCI process Terminate
Purpose
Do cleanup before process termination
Syntax
sword OCITerminate (ub4 mode);
<br /><br />

Comments
This call performs  OCI related clean up before the OCI process terminates.
If the process is running in shared mode then the OCI process is disconnected
from the shared memory subsystem.
<br /><br />

OCITerminate() should be the last OCI call in any process.
<br /><br />

Parameters
mode (IN) - specifies different termination modes.
<br /><br />

OCI_DEFAULT - default mode.
<br /><br />

Example
<br /><br />

Related Functions
OCIInitialize()
<br /><br />

------------------------ OCIAppCtxSet--------------------------------------
Name
OCI Application context Set
Purpose
Set an attribute and its value for a particular application context
     namespace
Syntax
 (sword) OCIAppCtxSet((void *) sesshndl, (dvoid *)nsptr,(ub4) nsptrlen,
                     (dvoid *)attrptr, (ub4) attrptrlen, (dvoid *)valueptr,
                     (ub4) valueptrlen,  errhp, (ub4)mode);
<br /><br />

Comments
Please note that the information set on the session handle is sent to the server during the next OCIStatementExecute or OCISessionBegin.
<br /><br />

This information is cleared from the session handle, once the information
 has been sent over to the server,and should be setup again if needed.
<br /><br />

Parameters
 sesshndl   (IN/OUT) - Pointer to a session handle
 nsptr      (IN)     - Pointer to namespace string
 nsptrlen   (IN)     - length of the nsptr
 attrptr    (IN)     - Pointer to attribute string
 attrptrlen (IN)     - length of the attrptr
 valueptr   (IN)     - Pointer to value string
 valueptrlen(IN)     - length of the valueptr
 errhp      (OUT)    - Error from the API
 mode       (IN)     - mode of operation (OCI_DEFAULT)
<br /><br />

Returns
 error if any
Example
<br /><br />

Related Functions
   OCIAppCtxClearAll
<br /><br />

<br /><br />

------------------------ OCIAppCtxClearAll---------------------------------
Name
 OCI Application Context Clear all attributes in a namespace
Purpose
 To clear the  values all attributes in a namespace
Syntax
 (sword) OCIAppCtxClearAll((void *) sesshndl, (dvoid *)nsptr, (ub4) nsptrlen,
              (OCIError *)errhp, (ub4)mode);
<br /><br />

Comments
This will clean up the context information on the server side during the next piggy-back to the server.
<br /><br />

Parameters
 sesshndl (IN/OUT) - Pointer to a session handle
 nsptr    (IN)     - Pointer to namespace string where the values of all
                     attributes are cleared
 nsptrlen (IN)     - length of the nsptr
 errhp    (OUT)    - Error from the API
 mode     (IN)     - mode of operation (OCI_DEFAULT)
Example
<br /><br />

Returns
 error if any
<br /><br />

Related Functions
 OCIAppCtxSet
---------------------- OCIIntervalAssign ---------------------------------
sword OCIIntervalAssign(dvoid *hndl, OCIError *err,
                    CONST OCIInterval *inpinter, OCIInterval *outinter );
<br /><br />

  DESCRIPTION
    Copies one interval to another to create a replica
  PARAMETERS
     hndl (IN) - Session/Env handle.
    err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
    (IN)  inpinter - Input Interval
    (OUT) outinter - Output Interval
  RETURNS
     OCI_INVALID_HANDLE if 'err' is NULL.
     OCI_SUCCESS otherwise
<br /><br />

 ---------------------- OCIIntervalCheck ------------------------------------
sword OCIIntervalCheck(dvoid *hndl, OCIError *err, CONST OCIInterval *interval,
                         ub4 *valid );
<br /><br />

  DESCRIPTION
    Checks the validity of an interval
  PARAMETERS
     hndl (IN) - Session/Env handle.
    err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
    (IN)  interval - Interval to be checked
    (OUT) valid     - Zero if the interval is valid, else returns an Ored
        combination of the following codes.
<br /><br />

   Macro name                   Bit number      Error
   ----------                   ----------      -----
   OCI_INTER_INVALID_DAY         0x1           Bad day
   OCI_INTER_DAY_BELOW_VALID     0x2           Bad DAy Low/high bit (1=low)
   OCI_INTER_INVALID_MONTH       0x4           Bad MOnth
   OCI_INTER_MONTH_BELOW_VALID   0x8           Bad MOnth Low/high bit (1=low)
   OCI_INTER_INVALID_YEAR        0x10          Bad YeaR
   OCI_INTER_YEAR_BELOW_VALID    0x20          Bad YeaR Low/high bit (1=low)
   OCI_INTER_INVALID_HOUR        0x40          Bad HouR
   OCI_INTER_HOUR_BELOW_VALID    0x80          Bad HouR Low/high bit (1=low)
   OCI_INTER_INVALID_MINUTE      0x100         Bad MiNute
   OCI_INTER_MINUTE_BELOW_VALID  0x200         Bad MiNute Low/high bit(1=low)
   OCI_INTER_INVALID_SECOND      0x400         Bad SeCond
   OCI_INTER_SECOND_BELOW_VALID  0x800         bad second Low/high bit(1=low)
   OCI_INTER_INVALID_FRACSEC     0x1000        Bad Fractional second
   OCI_INTER_FRACSEC_BELOW_VALID 0x2000        Bad fractional second Low/High
<br /><br />

<br /><br />

  RETURNS
    OCI_SUCCESS if interval is okay
    OCI_INVALID_HANDLE if 'err' is NULL.
<br /><br />

 ---------------------- OCIIntervalCompare -----------------------------------
sword OCIIntervalCompare(dvoid *hndl, OCIError *err, OCIInterval *inter1,
                        OCIInterval *inter2, sword *result );
<br /><br />

  DESCRIPTION
        Compares two intervals, returns 0 if equal, -1 if inter1 &lt; inter2,
        1 if inter1 &gt; inter2
  PARAMETERS
     hndl (IN) - Session/Env handle.
     err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
     inter1  (IN)   - Interval to be compared
     inter2  (IN)   - Interval to be compared
     result  (OUT)  -   comparison result, 0 if equal, -1 if inter1 &lt; inter2,
                        1 if inter1 &gt; inter2
<br /><br />

  RETURNS
     OCI_SUCCESS on success
     OCI_INVALID_HANDLE if 'err' is NULL.
     OCI_ERROR if
        the two input datetimes are not mutually comparable.
<br /><br />

---------------------- OCIIntervalDivide ------------------------------------
sword OCIIntervalDivide(dvoid *hndl, OCIError *err, OCIInterval *dividend,
                OCINumber *divisor, OCIInterval *result );
<br /><br />

  DESCRIPTION
     Divides an interval by an Oracle Number to produce an interval
  PARAMETERS
        hndl (IN) - Session/Env handle.
     err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
     dividend  (IN)   - Interval to be divided
     divisor   (IN)   - Oracle Number dividing `dividend'
     result    (OUT)  - resulting interval (dividend / divisor)
  RETURNS
     OCI_SUCCESS on success
     OCI_INVALID_HANDLE if 'err' is NULL.
<br /><br />

 ---------------------- OCIIntervalFromNumber --------------------
sword OCIIntervalFromNumber(dvoid *hndl, OCIError *err,
               OCIInterval *inter, OCINumber *number);
  DESCRIPTION
    Converts an interval to an Oracle Number
  PARAMETERS
     hndl (IN) - Session/Env handle.
    err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
    (OUT)  interval - Interval to be converted
    (IN) number - Oracle number result  (in years for YEARMONTH interval
                     and in days for DAYSECOND)
  RETURNS
    OCI_SUCCESS on success
    OCI_INVALID_HANDLE if 'err' is NULL.
    OCI_ERROR on error.
  NOTES
    Fractional portions of the date (for instance, minutes and seconds if
    the unit chosen is hours) will be included in the Oracle number produced.
    Excess precision will be truncated.
<br /><br />

 ---------------------- OCIIntervalFromText ---------------------------------
sword OCIIntervalFromText( dvoid *hndl, OCIError *err, CONST OraText *inpstr,
                size_t str_len, OCIInterval *result );
<br /><br />

  DESCRIPTION
    Given an interval string produce the interval represented by the string.
    The type of the interval is the type of the 'result' descriptor.
  PARAMETERS
<br /><br />

     hndl (IN) - Session/Env handle.
     err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
    (IN)  inpstr - Input string
    (IN)  str_len - Length of input string
    (OUT) result - Resultant interval
  RETURNS
    OCI_SUCCESS on success
    OCI_INVALID_HANDLE if 'err' is NULL.
    OCI_ERROR if
        there are too many fields in the literal string
        the year is out of range (-4713 to 9999)
        if the month is out of range (1 to 12)
        if the day of month is out of range (1 to 28...31)
        if hour is not in range (0 to 23)
        if hour is not in range (0 to 11)
        if minute is not in range (0 to 59)
        if seconds in minute not in range (0 to 59)
        if seconds in day not in range (0 to 86399)
        if the interval is invalid
<br /><br />

<br /><br />

 ---------------------- OCIIntervalGetDaySecond --------------------
<br /><br />

  DESCRIPTION
     Gets values of day second interval
  PARAMETERS
        hndl (IN) - Session/Env handle.
        err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
        day     (OUT) - number of days
        hour    (OUT) - number of hours
        min     (OUT) - number of mins
        sec     (OUT) - number of secs
        fsec    (OUT) - number of fractional seconds
        result     (IN)  - resulting interval
  RETURNS
        OCI_SUCCESS on success
        OCI_INVALID_HANDLE if 'err' is NULL.
<br /><br />

<br /><br />

 ---------------------- OCIIntervalGetYearMonth --------------------
<br /><br />

  DESCRIPTION
     Gets year month from an interval
  PARAMETERS
        hndl (IN) - Session/Env handle.
        err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
        year    (OUT)   - year value
        month   (OUT)   - month value
        result     (IN)  - resulting interval
  RETURNS
        OCI_SUCCESS on success
        OCI_INVALID_HANDLE if 'err' is NULL.
<br /><br />

<br /><br />

<br /><br />

-------------------------- OCIIntervalAdd ------------------------------
sword OCIIntervalAdd(dvoid *hndl, OCIError *err, OCIInterval *addend1,
                        OCIInterval *addend2, OCIInterval *result );
NAME OCIIntervalAdd - Adds two intervals
PARAMETERS
hndl (IN) - Session/Env handle.
err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
addend1  (IN)   - Interval to be added
addend2  (IN)   - Interval to be added
result   (OUT)  - resulting interval (addend1 + addend2)
DESCRIPTION
     Adds two intervals to produce a resulting interval
RETURNS
     OCI_SUCCESS on success
     OCI_ERROR if:
        the two input intervals are not mutually comparable.
        the resulting year would go above SB4MAXVAL
        the resulting year would go below SB4MINVAL
     OCI_INVALID_HANDLE if 'err' is NULL.
NOTES
     The two input intervals must be mutually comparable
<br /><br />

 ---------------------- OCIIntervalSubtract -------------------------------
sword OCIIntervalSubtract(dvoid *hndl, OCIError *err, OCIInterval *minuend,
                            OCIInterval *subtrahend, OCIInterval *result );
NAME - OCIIntervalSubtract - subtracts two intervals
PARAMETERS
hndl (IN) - Session/Env handle.
err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
minuend    (IN)   - interval to be subtracted from
subtrahend (IN)   - interval subtracted from minuend
result     (OUT)  - resulting interval (minuend - subtrahend)
DESCRIPTION
     Subtracts two intervals and stores the result in an interval
RETURNS
        OCI_SUCCESS on success
        OCI_INVALID_HANDLE if 'err' is NULL.
        OCI_ERROR if:
           the two input intervals are not mutually comparable.
           the resulting leading field would go below SB4MINVAL
           the resulting leading field would go above SB4MAXVAL
<br /><br />

---------------------- OCIIntervalMultiply ---------------------------------
sword OCIIntervalMultiply(dvoid *hndl, OCIError *err, CONST OCIInterval *inter,
                        OCINumber *nfactor, OCIInterval *result );
<br /><br />

  DESCRIPTION
     Multiplies an interval by an Oracle Number to produce an interval
  PARAMETERS
        hndl (IN) - Session/Env handle.
     err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
     inter  (IN)   - Interval to be multiplied
     nfactor  (IN)   - Oracle Number to be multiplied
     result   (OUT)  - resulting interval (ifactor * nfactor)
  RETURNS
     OCI_SUCCESS on success
     OCI_INVALID_HANDLE if 'err' is NULL.
     OCI_ERROR if:
        the resulting year would go above SB4MAXVAL
        the resulting year would go below SB4MINVAL
<br /><br />

<br /><br />

 ---------------------- OCIIntervalSetDaySecond --------------------
<br /><br />

  DESCRIPTION
     Sets day second interval
  PARAMETERS
        hndl (IN) - Session/Env handle.
        err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
        day     (IN) - number of days
        hour    (IN) - number of hours
        min     (IN) - number of mins
        sec     (IN) - number of secs
        fsec    (IN) - number of fractional seconds
        result     (OUT)  - resulting interval
  RETURNS
        OCI_SUCCESS on success
        OCI_INVALID_HANDLE if 'err' is NULL.
<br /><br />

<br /><br />

 ---------------------- OCIIntervalSetYearMonth --------------------
<br /><br />

  DESCRIPTION
     Sets year month interval
  PARAMETERS
        hndl (IN) - Session/Env handle.
        err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
        year    (IN)   - year value
        month   (IN)   - month value
        result     (OUT)  - resulting interval
  RETURNS
        OCI_SUCCESS on success
        OCI_INVALID_HANDLE if 'err' is NULL.
<br /><br />

<br /><br />

----------------------- OCIIntervalToNumber ---------------------------------
sword OCIIntervalToNumber(dvoid *hndl, OCIError *err, CONST OCIInterval *inter,
                          OCINumber *number);
<br /><br />

  DESCRIPTION
    Converts an interval to an Oracle Number
  PARAMETERS
     hndl (IN) - Session/Env handle.
    err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
    (IN)  inter - Interval to be converted
    (OUT) number - Oracle number result  (in years for YEARMONTH interval
                     and in days for DAYSECOND)
  RETURNS
    OCI_INVALID_HANDLE if 'err' is NULL.
    OCI_SUCCESS on success
  NOTES
    Fractional portions of the date (for instance, minutes and seconds if
    the unit chosen is hours) will be included in the Oracle number produced.
    Excess precision will be truncated.
<br /><br />

------------------------------- OCIIntervalToText -------------------------
sword OCIIntervalToText( dvoid *hndl, OCIError *err, CONST OCIInterval *inter,
                        ub1 lfprec, ub1 fsprec, OraText *buffer,
                        size_t buflen, size_t *resultlen );
<br /><br />

  DESCRIPTION
    Given an interval, produces a string representing the interval.
  PARAMETERS
     hndl (IN) - Session/Env handle.
    err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
    (IN)  inter - Interval to be converted
    (IN)  lfprec  - Leading field precision. Number of digits used to
                represent the leading field.
    (IN)  fsprec  - Fractional second precision of the interval. Number of
                digits used to represent the fractional seconds.
    (OUT) buffer - buffer to hold result
    (IN)  buflen - length of above buffer
    (OUT) resultlen - length of result placed into buffer
<br /><br />

  RETURNS
    OCI_SUCCESS on success
    OCI_INVALID_HANDLE if 'err' is NULL.
    OCI_ERROR
        if the buffer is not large enough to hold the result
  NOTES
    The interval literal will be output as `year' or `[year-]month' for
    YEAR-MONTH intervals and as `seconds' or `minutes[:seconds]' or
    `hours[:minutes[:seconds]]' or `days[ hours[:minutes[:seconds]]]' for
    DAY-TIME intervals (where optional fields are surrounded by brackets).
<br /><br />

 ---------------------- OCIIntervalFromTZ --------------------
sword OCIIntervalFromTZ(dvoid *hndl, OCIError *err, CONST oratext *inpstring,
                        size_t str_len, OCIInterval *result);
<br /><br />

  DESCRIPTION
    Retuns an OCI_DTYPE_INTERVAL_DS OCIInterval with the region id (if
    the region is specified in the input string) set and the current
    absolute offset or an absolut offset with the region id set to 0.
  PARAMETERS
    hndl (IN) - Session/Env handle.
    err (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
    inpstring (IN) - pointer to the input string
    str_len (IN) - inpstring length
    result - Output Interval
  RETURNS
     OCI_SUCCESS on success
     OCI_INVALID_HANDLE if 'err' is NULL.
     OCI_ERROR on error
        Bad interval type
        Timezone errors
  NOTES
     The input string must be of the form [+/-]TZH:TZM or 'TZR [TZD]'
<br /><br />

 ----------------------- OCIKerbAttrSet ---------------------
sword OCIKerbAttrSet(OCISession *trgthndlp, ub4 auth_mode,
                     ub1 *ftgt_ticket, ub4 ftgt_ticket_len,
                     ub1 *ftgt_sesskey, ub4 ftgt_sesskey_len,
                     ub2 ftgt_keytype, ub4 ftgt_ticket_flags,
                     sb4 ftgt_auth_time, sb4 ftgt_start_time,
                     sb4 ftgt_end_time, sb4 ftgt_renew_time,
                     text *ftgt_principal, ub4 ftgt_principal_len,
                     text *ftgt_realm, ub4 ftgt_realm_len,
                     OCIError *errhp);
<br /><br />

  DESCRIPTION
    This call sets the attributes required for Kerberos authentication
    on the user handle.
<br /><br />

  PARAMETERS
    trgthndlp (IN) - The pointer to a user handle.
    auth_mode (IN) - Indicates what type of Kerberos credentials should
                    be set. Options are:
<br /><br />

                    OCI_KERBCRED_PROXY
                                         - Set Kerberos credentials for use with
                                           proxy authentication.
                    OCI_KERBCRED_CLIENT_IDENTIFIER
                                         - Set Kerberos credentials for use
                                           with secure client identifier.
<br /><br />

    ftgt_ticket (IN) - Forwardable Ticket Granting Ticket (FTGT).
    ftgt_ticket_len (IN) - Length of FTGT.
    ftgt_sesskey(IN) - Session Key associated with FTGT.
    ftgt_sesskey_len (IN) - Length of session key.
    ftgt_keytype (IN) -  Type of encryption key used to encrypt FTGT.
    ftgt_ticket_flags (IN) - Flags associated with  encryption of FTGT.
    ftgt_auth_time (IN) - Authentication time compatible with that in FTGT.
    ftgt_start_time (IN) - Start time compatible with that indicated in FTGT.
    ftgt_end_time (IN) - End time compatible with that indicated in FTGT.
    ftgt_renew_time (IN) - Renew time compatible with that indicated in FTGT.
    ftgt_principal (IN) - Client principal name from FTGT.
    ftgt_principal_len (IN) - Length of client principal name.
    ftgt_realm (IN) - Client realm name from FTGT.
    ftgt_realm_len (IN) - Client realm name length.
    errhp (IN/OUT) - error handle. If there is an error, it is
                recorded in 'err' and this function returns OCI_ERROR.
                The error recorded in 'err' can be retrieved by calling
                OCIErrorGet().
  RETURNS
     OCI_SUCCESS on success
     OCI_ERROR on error
  NOTES
<br /><br />

OCILdaToSvcCtx()
Name
OCI toggle version 7 Lda_Def to SerVice context handle
Purpose
Converts a V7 Lda_Def to a V8 service context handle.
Syntax
sword OCILdaToSvcCtx ( OCISvcCtx  **svchpp,
                     OCIError   *errhp,
                     Lda_Def    *ldap );
Comments
Converts a V7 Lda_Def to a V8 service context handle. The action of this call
can be reversed by passing the resulting service context handle to the
OCISvcCtxToLda() function.
Parameters
svchpp (IN/OUT) - the service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
ldap (IN/OUT) - the V7 logon data area returned by OCISvcCtxToLda() from
this service context.
Related Functions
OCISvcCtxToLda()
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCILobAppend()
<br /><br />

Name
OCI Lob APpend
<br /><br />

Purpose
Appends a LOB value at the end of another LOB.
<br /><br />

Syntax
sword OCILobAppend ( OCISvcCtx        *svchp,
                   OCIError         *errhp,
                   OCILobLocator    *dst_locp,
                   OCILobLocator    *src_locp );
Comments
Appends a LOB value at the end of LOB. The data is
copied from the source to the destination at the end of the destination. The
source and the destination must already exist. The destination LOB is
extended to accommodate the newly written data.
<br /><br />

It is an error to extend the destination LOB beyond the maximum length
allowed or to try to copy from a NULL LOB.
<br /><br />

Parameters
svchp (IN) - the service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
dst_locp (IN/OUT) - a locator uniquely referencing the destination LOB.
src_locp (IN/OUT) - a locator uniquely referencing the source LOB.
<br /><br />

Related Functions
OCILobTrim()
OCIErrorGet()
OCILobWrite()
OCILobCopy()
<br /><br />

<br /><br />

<br /><br />

OCILobAssign()
<br /><br />

Name
OCI Lob ASsiGn
<br /><br />

Purpose
Assigns one LOB/FILE locator to another.
<br /><br />

Syntax
sword OCILobAssign ( OCIEnv                *envhp,
                     OCIError              *errhp,
                     CONST OCILobLocator   *src_locp,
                     OCILobLocator         **dst_locpp );
<br /><br />

Comments
Assign source locator to destination locator.  After the assignment, both
locators refer to the same LOB data.  For internal LOBs, the source locator's
LOB data gets copied to the destination locator's LOB data only when the
destination locator gets stored in the table.  Therefore, issuing a flush of
the object containing the destination locator will copy the LOB data. For
FILEs only the locator that refers to the OS file is copied to the table. The
OS file is not copied.

<strong>Note:</strong>
The only difference between this and OCILobLocatorAssign is that this
takes an environment handle whereas OCILobLocatorAssign takes an OCI service
handle
<br /><br />

Parameters
envhp (IN/OUT) - OCI environment handle initialized in object mode.
errhp (IN/OUT) - The OCI error handle. If there is an error, it is recorded
in errhp and this function returns OCI_ERROR. Diagnostic information can be
obtained by calling OCIErrorGet().
src_locp (IN) - LOB locator to copy from.
dst_locpp (IN/OUT) - LOB locator to copy to.  The caller must allocate space
for the OCILobLocator by calling OCIDescriptorAlloc().
<br /><br />

See also
OCIErrorGet()
OCILobIsEqual()
OCILobLocatorIsInit()
OCILobLocatorAssign()
<br /><br />

<br /><br />

OCILobCharSetForm()
<br /><br />

Name
OCI Lob Get Character Set Form
<br /><br />

Purpose
Gets the LOB locator's character set fpr,, if any.
<br /><br />

Syntax
sword OCILobCharSetForm ( OCIEnv                    *envhp,
                          OCIError                  *errhp,
                          CONST OCILobLocator       *locp,
                          ub1                       *csfrm );
<br /><br />

Comments
Returns the character set form of the input LOB locator in the csfrm output
parameter.
<br /><br />

Parameters
envhp (IN/OUT) - OCI environment handle initialized in object mode.
errhp (IN/OUT) - error handle. The OCI error handle. If there is an error, it
is recorded in err and this function returns OCI_ERROR. Diagnostic
information can be obtained by calling OCIErrorGet().
locp (IN) - LOB locator for which to get the character set form.
csfrm(OUT) - character set form of the input LOB locator.  If the input
locator is for a BLOB or a BFILE, csfrm is set to 0 since there is no concept
of a character set for binary LOBs/FILEs.  The caller must allocate space for
the csfrm (ub1) and not write into the space.
See also
OCIErrorGet(), OCILobCharSetId(), OCILobLocatorIsInit
<br /><br />

<br /><br />

<br /><br />

OCILobCharSetId()
<br /><br />

Name
OCI Lob get Character Set IDentifier
<br /><br />

Purpose
Gets the LOB locator's character set ID, if any.
<br /><br />

Syntax
sword OCILobCharSetId ( OCIEnv                    *envhp,
                        OCIError                  *errhp,
                        CONST OCILobLocator       *locp,
                        ub2                       *csid );
<br /><br />

Comments
Returns the character set ID of the input LOB locator in the cid output
parameter.
<br /><br />

Parameters
envhp (IN/OUT) - OCI environment handle initialized in object mode.
errhp (IN/OUT) - error handle. The OCI error handle. If there is an error, it
is recorded in err and this function returns OCI_ERROR. Diagnostic
information can be obtained by calling OCIErrorGet().
locp (IN) - LOB locator for which to get the character set ID.
csid (OUT) - character set ID of the input LOB locator.  If the input locator
is for a BLOB or a BFILE, csid is set to 0 since there is no concept of a
character set for binary LOBs/FILEs.  The caller must allocate space for the
character set id of type ub2 and not write into the space.
<br /><br />

See also
OCIErrorGet(), OCILobCharSetForm(), OCILobLocatorIsInit()
<br /><br />

<br /><br />

<br /><br />

OCILobCopy()
<br /><br />

Name
OCI Lob Copy
<br /><br />

Purpose
Copies a portion of a LOB value into another LOB value.
<br /><br />

Syntax
sword OCILobCopy ( OCISvcCtx        *svchp,
                   OCIError         *errhp,
                   OCILobLocator    *dst_locp,
                   OCILobLocator    *src_locp,
                   ub4              amount,
                   ub4              dst_offset,
                   ub4              src_offset );
<br /><br />

Comments
Copies a portion of a LOB value into another LOB as specified. The data
is copied from the source to the destination. The source (src_locp) and the
destination (dlopb) LOBs must already exist.
If the data already exists at the destination's start position, it is
overwritten with the source data. If the destination's start position is
beyond the end of the current data, a hole is created from the end of the data
to the beginning of the newly written data from the source. The destination
LOB is extended to accommodate the newly written data if it extends
beyond the current length of the destination LOB.
It is an error to extend the destination LOB beyond the maximum length
allowed or to try to copy from a NULL LOB.
Parameters
svchp (IN) - the service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
dst_locp (IN/OUT) - a locator uniquely referencing the destination LOB.
src_locp (IN/OUT) - a locator uniquely referencing the source LOB.
amount (IN) - the number of character or bytes, as appropriate, to be copied.
dst_offset (IN) - this is the absolute offset for the destination LOB.
For character LOBs it is the number of characters from the beginning of the
LOB at which to begin writing. For binary LOBs it is the number of bytes from
the beginning of the lob from which to begin reading. The offset starts at 1.
src_offset (IN) - this is the absolute offset for the source LOB.
For character LOBs it is the number of characters from the beginning of the
LOB, for binary LOBs it is the number of bytes. Starts at 1.
<br /><br />

See Also
OCIErrorGet(), OCILobAppend(), OCILobWrite(), OCILobTrim()
<br /><br />

OCILobCreateTemporary()
<br /><br />

Name
OCI Lob Create Temporary
<br /><br />

Purpose
Create a Temporary Lob
<br /><br />

Syntax
sword OCILobCreateTemporary(OCISvcCtx          *svchp,
                            OCIError           *errhp,
                            OCILobLocator      *locp,
                            ub2                 csid,
                            ub1                 csfrm,
                            ub1                 lobtype,
                            boolean             cache,
                            OCIDuration         duration);
<br /><br />

<br /><br />

Comments
svchp (IN) - the service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
locp (IN/OUT) - a locator which points to the temporary Lob
csid (IN) - the character set id
csfrm(IN) - the character set form
lobtype (IN) - the lob type - one of the three constants OCI_TEMP_BLOB,
               OCI_TEMP_CLOB and OCI_TEMP_NCLOB
cache(IN)-  TRUE if the temporary LOB goes through the cache; FALSE, if not.
duration(IN)- duration of the temporary LOB; Can be a valid duration id or one
              of the values: OCI_DURATION_SESSION, OCI_DURATION_CALL

<strong>Note:</strong>
OCI_DURATION_TRANSACTION is NOT supported in 8.1
Related functions
OCILobFreeTemporary()
OCILobIsTemporary()
<br /><br />

OCILobDisableBuffering()
<br /><br />

Name
OCI Lob Disable Buffering
<br /><br />

Purpose
Disable lob buffering for the input locator.
<br /><br />

<br /><br />

Syntax
sword OCILobDisableBuffering ( OCISvcCtx      *svchp,
                               OCIError       *errhp,
                               OCILobLocator  *locp);
<br /><br />

Comments
<br /><br />

Disable lob buffering for the input locator.  The next time data is
read/written from/to the lob through the input locator, the lob
buffering subsystem is *not* used.  Note that this call does *not*
implicitly flush the changes made in the buffering subsystem.  The
user must explicitly call OCILobFlushBuffer() to do this.
<br /><br />

Parameters
svchp (IN) - the service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
locp (IN/OUT) - a locator uniquely referencing the LOB.
<br /><br />

Related Functions
OCILobEnableBuffering()
OCIErrorGet()
OCILobFlushBuffer()
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCILobEnableBuffering()
<br /><br />

Name
OCI Lob Enable Buffering
<br /><br />

Purpose
Enable lob buffering for the input locator.
<br /><br />

<br /><br />

Syntax
sword OCILobEnableBuffering ( OCISvcCtx      *svchp,
                              OCIError       *errhp,
                              OCILobLocator  *locp);
<br /><br />

Comments
<br /><br />

Enable lob buffering for the input locator.  The next time data is
read/written from/to the lob through the input locator, the lob
buffering subsystem is used.
<br /><br />

Once lob buffering is enabled for a locator, if that locator is passed to
one of the following routines, an error is returned:
        OCILobCopy, OCILobAppend, OCILobErase, OCILobGetLength, OCILobTrim
<br /><br />

Parameters
svchp (IN) - the service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
locp (IN/OUT) - a locator uniquely referencing the LOB.
<br /><br />

Related Functions
OCILobDisableBuffering()
OCIErrorGet()
OCILobWrite()
OCILobRead()
OCILobFlushBuffer()
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCILobErase()
<br /><br />

Name
OCI Lob ERase
<br /><br />

Purpose
Erases a specified portion of the LOB data starting at a specified offset.
<br /><br />

Syntax
sword OCILobErase ( OCISvcCtx       *svchp,
                  OCIError        *errhp,
                  OCILobLocator   *locp,
                  ub4             *amount,
                  ub4             offset );
<br /><br />

Comments
Erases a specified portion of the LOB data starting at a specified offset.
The actual number of characters/bytes erased is returned. The actual number
of characters/bytes and the requested number of characters/bytes will differ
if the end of the LOB data is reached before erasing the requested number of
characters/bytes.
If a section of data from the middle of the LOB data is erased, a hole is
created. When data from that hole is read, 0's are returned. If the LOB is
NULL, this routine will indicate that 0 characters/bytes were erased.
<br /><br />

Parameters
svchp (IN) - the service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
locp (IN/OUT) - the LOB for which to erase a section of data.
amount (IN/OUT) - On IN, the number of characters/bytes to erase. On OUT,
the actual number of characters/bytes erased.
offset (IN) - absolute offset from the beginning of the LOB data from which
to start erasing data. Starts at 1.
<br /><br />

See Also
OCIErrorGet(), OCILobRead(), OCILobWrite()
<br /><br />

OCILobOpen()
<br /><br />

Name
OCI Lob Open
<br /><br />

Purpose
Opens an internal or external Lob.
<br /><br />

Syntax
sword OCILobOpen( OCISvcCtx        *svchp,
                  OCIError         *errhp,
                  OCILobLocator    *locp,
                  ub1               mode );
<br /><br />

Comments
It is an error if the same lob is opened more than once in
the same transaction. Lobs are opened implicitly if they are
not opened before using them. A LOB has to be closed before
the transaction commits else the transaction is rolled back.
Open locators are closed if the transaction aborts. Multiple
users can open the same lob on different locators.
Parameters
svchp (IN) - the service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
locp (IN/OUT) - locator points to the LOB to be opened
mode (IN) - mode in which to open the lob. The valid modes are
read-only - OCI_FILE_READONLY, read-write - OCI_FILE_READWRITE
<br /><br />

OCILobClose()
<br /><br />

Name
OCI Lob Close
<br /><br />

Purpose
Closes an open internal or external Lob.
<br /><br />

Syntax
sword OCILobClose( OCISvcCtx        *svchp,
                   OCIError         *errhp,
                   OCILobLocator    *locp );
<br /><br />

<br /><br />

Comments
It is an error if the lob is not open at this time. All LOBs
that have been opened in a transaction have to be closed
before the transaction commits, else the transaction gets
rolled back.
<br /><br />

Parameters
svchp (IN) - the service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
locp  (IN)  - A locator that was opened using OCILobOpen()
<br /><br />

<br /><br />

OCILobFileClose()
<br /><br />

Name
OCI Lob File CLoSe
<br /><br />

Purpose
Closes a previously opened FILE.
<br /><br />

Syntax
sword OCILobFileClose ( OCISvcCtx            *svchp,
                        OCIError             *errhp,
                        OCILobLocator        *filep );
<br /><br />

Comments
Closes a previously opened FILE. It is an error if this function is called for
an internal LOB. No error is returned if the FILE exists but is not opened.
Parameters
svchp (IN) - the service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
filep (IN/OUT) - a pointer to a FILE locator to be closed.
<br /><br />

See Also
OCIErrorGet(), OCILobFileOpen(), OCILobFileCloseAll(), OCILobFileIsOpen(),
OCILobFileExists(), CREATE DIRECTORY DDL
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCILobFileCloseAll()
<br /><br />

Name
OCI LOB FILE Close All
<br /><br />

Purpose
Closes all open FILEs on a given service context.
<br /><br />

Syntax
sword OCILobFileCLoseAll ( OCISvcCtx *svchp,
                           OCIError  *errhp );
<br /><br />

Comments
Closes all open FILEs on a given service context.
<br /><br />

Parameters
svchp (IN) - the service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
<br /><br />

See also
OCILobFileClose(),
OCIErrorGet(), OCILobFileOpen(), OCILobFileIsOpen(),
OCILobFileExists(), CREATE DIRECTORY DDL
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCILobFileExists()
<br /><br />

Name
OCI LOB FILE exists
<br /><br />

Purpose
Tests to see if the FILE exists on the server
<br /><br />

Syntax
sword OCILobFileExists ( OCISvcCtx     *svchp,
                         OCIError      *errhp,
                         OCILobLocator *filep,
                         boolean       *flag );
<br /><br />

Comments
Checks to see if a FILE exists for on the server.
<br /><br />

Parameters
svchp (IN) - the OCI service context handle.
errhp (IN/OUT) - error handle. The OCI error handle. If there is an error,
it is recorded in err and this function returns OCI_ERROR. Diagnostic
information can be obtained by calling OCIErrorGet().
filep (IN) - pointer to the FILE locator that refers to the file.
flag (OUT) - returns TRUE if the FILE exists; FALSE if it does not.
<br /><br />

See also
OCIErrorGet, CREATE DIRECTORY (DDL)
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCILobFileGetName()
<br /><br />

Name
OCI LOB FILE Get file Name
<br /><br />

Purpose
Gets the FILE locator's directory alias and file name.
<br /><br />

Syntax
sword OCILobFileGetName ( OCIEnv                   *envhp,
                          OCIError                 *errhp,
                          CONST OCILobLocator      *filep,
                          OraText                     *dir_alias,
                          ub2                      *d_length,
                          OraText                     *filename,
                          ub2                      *f_length );
<br /><br />

Comments
Returns the directory alias and file name associated with this file locator.
<br /><br />

Parameters
envhp (IN/OUT) - OCI environment handle initialized in object mode.
errhp (IN/OUT) -The OCI error handle. If there is an error, it is recorded in
errhp and this function returns OCI_ERROR. Diagnostic information can be
obtained by calling OCIErrorGet().
filep (IN) - FILE locator for which to get the directory alias and file name.
dir_alias (OUT) - buffer into which the directory alias name is placed. The
caller must allocate enough space for the directory alias name and must not
write into the space.
d_length (IN/OUT)
        - IN: length of the input dir_alias string;
        - OUT: length of the returned dir_alias string.
filename (OUT) - buffer into which the file name is placed. The caller must
allocate enough space for the file name and must not write into the space.
f_length (IN/OUT)
        - IN: length of the input filename string;
         - OUT: lenght of the returned filename string.
<br /><br />

See also
OCILobFileSetName(), OCIErrorGet()
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCILobFileIsOpen()
<br /><br />

Name
OCI LOB FILE Is Open?
<br /><br />

Purpose
Tests to see if the FILE is open
<br /><br />

Syntax
sword OCILobFileIsOpen ( OCISvcCtx *svchp,
                         OCIError  *errhp,
                         OCILobLocator *filep,
                         boolean       *flag );
<br /><br />

Comments
Checks to see if the FILE on the server is open for a given LobLocator.
<br /><br />

Parameters
svchp (IN) - the OCI service context handle.
errhp (IN/OUT) - error handle. The OCI error handle. If there is an error, it
is recorded in err and this function returns OCI_ERROR. Diagnostic
information can be obtained by calling OCIErrorGet().
filep (IN) - pointer to the FILE locator being examined. If the input file
locator was never passed to OCILobFileOpen(), the file is considered not to
be opened by this locator. However, a different locator may have opened the
file. More than one file opens can be performed on the same file using
different locators.
flag (OUT) - returns TRUE if the FILE is opened using this locator; FALSE if
it is not.
<br /><br />

See also
OCIErrorGet, OCILobFileOpen, OCILobFileClose, OCILobFileCloseAll, CREATE
DIRECTORY SQL command
<br /><br />

<br /><br />

OCILobFileOpen()
<br /><br />

Name
OCI LOB FILE open
<br /><br />

Purpose
Opens a FILE for read-only access
<br /><br />

Syntax
sword OCILobFileOpen ( OCISvcCtx            *svchp,
                     OCIError             *errhp,
                     OCILobLocator        *filep,
                     ub1                  mode );
<br /><br />

Comments
Opens a FILE. The FILE can be opened for read-only access only. FILEs may not
be written to throough ORACLE.
<br /><br />

Parameters
svchp (IN) - the service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
filep (IN/OUT) - the FILE to open. Error if the locator does not refer to a
FILE.
mode (IN) - mode in which to open the file. The only valid mode is
read-only - OCI_FILE_READONLY.
<br /><br />

See Also
OCILobFileClose, OCIErrorGet, OCILobFileCloseAll, OCILobFileIsOpen,
OCILobFileSetName, CREATE DIRECTORY
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCILobFileSetName()
<br /><br />

Name
OCI Lob File Set NaMe
<br /><br />

Purpose
Sets directory alias and file name in the FILE locator.
<br /><br />

Syntax
sword OCILobFileSetName ( OCIEnv             *envhp,
                          OCIError           *errhp,
                          OCILobLocator      **filepp,
                          OraText               *dir_alias,
                          ub2                d_length,
                          OraText               *filename,
                          ub2                f_length );
Comments
Sets the directory alias and file name in the LOB file locator.
Parameters
envhp (IN/OUT) - OCI environment handle initialized in object mode.
errhp (IN/OUT) - The OCI error handle. If there is an error, it is recorded
in errhp and this function returns OCI_ERROR. Diagnostic information can be
obtained by calling OCIErrorGet().
filepp (IN/OUT) - FILE locator for which to set the directory alias name.
The caller must have already allocated space for the locator by calling
OCIDescriptorAlloc().
dir_alias (IN) - buffer that contains the directory alias name to set in the
locator.
d_length (IN) - length of the input dir_alias parameter.
filename (IN) - buffer that contains the file name is placed.
f_length (IN) - length of the input filename parameter.
See also
OCILobFileGetName, OCIErrorGet, CREATE DIRECTORY
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCILobFlushBuffer()
<br /><br />

Name
OCI Lob Flush all Buffers for this lob.
<br /><br />

Purpose
Flush/write all buffers for this lob to the server.
<br /><br />

<br /><br />

Syntax
sword OCILobFlushBuffer ( OCISvcCtx       *svchp,
                          OCIError        *errhp,
                          OCILobLocator   *locp,
                          ub4              flag);
<br /><br />

Comments
<br /><br />

Flushes to the server, changes made to the buffering subsystem that
are associated with the lob referenced by the input locator.  This
routine will actually write the data in the buffer to the lob in
the database.  Lob buffering must have already been enabled for the
input lob locator.
<br /><br />

This routine, by default, does not free the buffer resources for
reallocation to another buffered LOB operation. However, if you
want to free the buffer explicitly, you can set the flag parameter
to OCI_LOB_BUFFER_FREE.
<br /><br />

Parameters
svchp (IN/OUT) - the service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
locp (IN/OUT) - a locator uniquely referencing the LOB.
flag    (IN)     - to indicate if the buffer resources need to be freed
                   after a flush. Default value is OCI_LOB_BUFFER_NOFREE.
                   Set it to OCI_LOB_BUFFER_FREE if you want the buffer
                   resources to be freed.
Related Functions
OCILobEnableBuffering()
OCILobDisableBuffering()
OCIErrorGet()
OCILobWrite()
OCILobRead()
<br /><br />

<br /><br />

OCILobFreeTemporary()
<br /><br />

Name
OCI Lob Free Temporary
<br /><br />

Purpose
Free a temporary LOB
<br /><br />

Syntax
sword OCILobFreeTemporary(OCISvcCtx          *svchp,
                          OCIError           *errhp,
                          OCILobLocator      *locp);
<br /><br />

Comments
  Frees the contents of the temporary Lob this locator is pointing to. Note
  that the locator itself is not freed until a OCIDescriptorFree is done.
<br /><br />

Parameters
svchp (IN/OUT) - the service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
locp (IN/OUT) - a locator uniquely referencing the LOB
<br /><br />

Related functions
OCILobCreateTemporary()
OCILobIsTemporary()
<br /><br />

<br /><br />

Name
OCI Lob/File Get Chunk Size
<br /><br />

Purpose
When creating the table, the user can specify the chunking factor, which can
be a multiple of Oracle blocks. This corresponds to the chunk size used by the
LOB data layer when accessing/modifying the LOB value. Part of the chunk is
used to store system-related information and the rest stores the LOB value.
This function returns the amount of space used in the LOB chunk to store
the LOB value.
<br /><br />

Syntax
sword OCILobGetChunkSize ( OCISvcCtx      *svchp,
                           OCIError       *errhp,
                           OCILobLocator  *locp,
                           ub4            *chunksizep );
<br /><br />

Comments
 Performance will be improved if the user issues read/write
requests using a multiple of this chunk size. For writes, there is an added
benefit since LOB chunks are versioned and, if all writes are done on chunk
basis, no extra/excess versioning is done nor duplicated. Users could batch
up the write until they have enough for a chunk instead of issuing several
write calls for the same chunk.
<br /><br />

Parameters
svchp (IN) - the service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
locp (IN/OUT) - a LOB locator that uniquely references the LOB. For internal
LOBs, this locator must be a locator that was obtained from the server
specified by svchp. For FILEs, this locator can be initialized by a Select or
OCILobFileSetName.
chunksizep (OUT) - On output, it is the length of the LOB if not NULL - for
character LOBs it is the number of characters, for binary LOBs it is the
number of bytes in the LOB.
<br /><br />

Related Functions
<br /><br />

OCILobGetLength()
<br /><br />

Name
OCI Lob/File Length
<br /><br />

Purpose
Gets the length of a LOB/FILE.
<br /><br />

Syntax
sword OCILobGetLength ( OCISvcCtx      *svchp,
                        OCIError       *errhp,
                        OCILobLocator  *locp,
                        ub4            *lenp );
<br /><br />

Comments
Gets the length of a LOB/FILE. If the LOB/FILE is NULL, the length is
undefined.
<br /><br />

Parameters
svchp (IN) - the service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
locp (IN/OUT) - a LOB locator that uniquely references the LOB. For internal
LOBs, this locator must be a locator that was obtained from the server
specified by svchp. For FILEs, this locator can be initialized by a Select or
OCILobFileSetName.
lenp (OUT) - On output, it is the length of the LOB if not NULL - for
character LOBs it is the number of characters, for binary LOBs it is the
number of bytes in the LOB.
<br /><br />

Related Functions
OCIErrorGet, OCIFileSetName
<br /><br />

<br /><br />

<br /><br />

OCILobIsEqual()
<br /><br />

Name
<br /><br />

OCI Lob Is Equal
<br /><br />

Purpose
Compares two LOB locators for equality.
<br /><br />

Syntax
sword OCILobIsEqual ( OCIEnv                  *envhp,
                      CONST OCILobLocator     *x,
                      CONST OCILobLocator     *y,
                      boolean                 *is_equal );
<br /><br />

Comments
Compares the given LOB locators for equality.  Two LOB locators are equal if
and only if they both refer to the same LOB data.
Two NULL locators are considered not equal by this function.
Parameters
envhp (IN) - the OCI environment handle.
x (IN) - LOB locator to compare.
y (IN) - LOB locator to compare.
is_equal (OUT) - TRUE, if the LOB locators are equal; FALSE if they are not.
<br /><br />

See also
OCILobAssign, OCILobLocatorIsInit
OCILobLocatorAssign,
OCILobIsOpen()
<br /><br />

Name
<br /><br />

OCI Lob Is Open
sword OCILobIsOpen(svchp, errhp, locp, flag)
OCISvcCtx     *svchp;
OCIError      *errhp;
OCILobLocator *locp;
boolean       *flag;
<br /><br />

Comments
   Checks if the LOB locator was opened before. flag is set to TRUE
   if opened; FALSE otherwise
<br /><br />

<br /><br />

Parameters
svchp (IN) - the service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
locp (IN) - the locator to test for temporary LOB
flag(OUT) - TRUE, if the LOB locator points to is open
                    FALSE, if not.
<br /><br />

OCILobIsTemporary()
<br /><br />

Name
<br /><br />

OCI Lob Is Temporary
<br /><br />

Purpose
  Tests if this locator points to a temporary LOB
<br /><br />

Syntax
sword OCILobIsTemporary(OCIEnv            *envhp,
                        OCIError          *errhp,
                        OCILobLocator     *locp,
                        boolean           *is_temporary);
<br /><br />

Comments
Tests the locator to determine if it points to a temporary LOB.
If so, is_temporary is set to TRUE. If not, is_temporary is set
to FALSE.
<br /><br />

Parameters
envhp (IN) - the environment handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
locp (IN) - the locator to test for temporary LOB
is_temporary(OUT) - TRUE, if the LOB locator points to a temporary LOB;
                    FALSE, if not.
<br /><br />

See Also
OCILobCreateTemporary, OCILobFreeTemporary
<br /><br />

<br /><br />

OCILobLoadFromFile()
<br /><br />

Name
OCI Lob Load From File
<br /><br />

Purpose
Load/copy all or a portion of the file into an internal LOB.
<br /><br />

Syntax
sword OCILobLoadFromFile ( OCISvcCtx        *svchp,
                           OCIError         *errhp,
                           OCILobLocator    *dst_locp,
                           OCILobLocator    *src_filep,
                           ub4              amount,
                           ub4              dst_offset,
                           ub4              src_offset );
<br /><br />

Comments
Loads/copies a portion or all of a file value into an internal LOB as
specified.  The data is copied from the source file to the destination
internal LOB (BLOB/CLOB).  No character set conversions are performed
when copying the bfile data to a clob/nclob.  The bfile data must already
be in the same character set as the clob/nclob in the database.  No
error checking is performed to verify this.
The source (src_filep) and the destination (dst_locp) LOBs must already exist.
If the data already exists at the destination's start position, it is
overwritten with the source data. If the destination's start position is
beyond the end of the current data, a hole is created from the end of the data
to the beginning of the newly written data from the source. The destination
LOB is extended to accommodate the newly written data if it extends
beyond the current length of the destination LOB.
It is an error to extend the destination LOB beyond the maximum length
allowed or to try to copy from a NULL LOB.
Parameters
svchp (IN) - the service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
dst_locp (IN/OUT) - a locator uniquely referencing the destination internal
LOB which may be of type blob, clob, or nclob.
src_filep (IN/OUT) - a locator uniquely referencing the source BFILE.
amount (IN) - the number of bytes to be copied.
dst_offset (IN) - this is the absolute offset for the destination LOB.
For character LOBs it is the number of characters from the beginning of the
LOB at which to begin writing. For binary LOBs it is the number of bytes from
the beginning of the lob from which to begin reading. The offset starts at 1.
src_offset (IN) - this is the absolute offset for the source BFILE.  It is
the number of bytes from the beginning of the LOB.  The offset starts at 1.
<br /><br />

See Also
OCIErrorGet(), OCILobAppend(), OCILobWrite(), OCILobTrim(), OCILobCopy()
<br /><br />

OCILobLocatorAssign()
<br /><br />

Name
OCI Lob LOCATOR ASsiGn
<br /><br />

Purpose
Assigns one LOB/FILE locator to another.
<br /><br />

Syntax
sword OCILobLocatorAssign ( OCISvcCtx             *svchp,
                            OCIError              *errhp,
                            CONST OCILobLocator   *src_locp,
                            OCILobLocator         **dst_locpp );
<br /><br />

Comments
Assign source locator to destination locator.  After the assignment, both
locators refer to the same LOB data.  For internal LOBs, the source locator's
LOB data gets copied to the destination locator's LOB data only when the
destination locator gets stored in the table.  Therefore, issuing a flush of
the object containing the destination locator will copy the LOB data. For
FILEs only the locator that refers to the OS file is copied to the table. The
OS file is not copied.
Note : the only difference between this and OCILobAssign is that this takes
a OCI service handle pointer instead of a OCI environment handle pointer
<br /><br />

Parameters
svchp (IN/OUT) - OCI service handle initialized in object mode.
errhp (IN/OUT) - The OCI error handle. If there is an error, it is recorded
in errhp and this function returns OCI_ERROR. Diagnostic information can be
obtained by calling OCIErrorGet().
src_locp (IN) - LOB locator to copy from.
dst_locpp (IN/OUT) - LOB locator to copy to.  The caller must allocate space
for the OCILobLocator by calling OCIDescriptorAlloc().
<br /><br />

See also
OCIErrorGet()
OCILobIsEqual()
OCILobLocatorIsInit()
OCILobAssign()
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCILobLocatorIsInit()
<br /><br />

Name
OCI LOB locator is initialized?
<br /><br />

Purpose
Tests to see if a given LOB locator is initialized.
<br /><br />

Syntax
sword OCILobLocatorIsInit ( OCIEnv   *envhp,
                            OCIError *errhp,
                            CONST OCILobLocator *locp,
                            boolean *is_initialized );
<br /><br />

Comments
Tests to see if a given LOB locator is initialized.
<br /><br />

Parameters
envhp (IN/OUT) - OCI environment handle initialized in object mode.
errhp (IN/OUT) - error handle. The OCI error handle. If there is an error, it
is recorded in err and this function returns OCI_ERROR. Diagnostic
information can be obtained by calling OCIErrorGet().
locp (IN) - the LOB locator being tested
is_initialized (OUT) - returns TRUE if the given LOB locator is initialized;
FALSE if it is not.
<br /><br />

See also
OCIErrorGet, OCILobIsEqual
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCILobRead()
<br /><br />

Name
OCI Lob/File ReaD
<br /><br />

Purpose
Reads a portion of a LOB/FILE as specified by the call into a buffer.
<br /><br />

Syntax
sword OCILobRead ( OCISvcCtx       *svchp,
                   OCIError        *errhp,
                   OCILobLocator   *locp,
                   ub4             offset,
                   ub4             *amtp,
                   dvoid           *bufp,
                   ub4             bufl,
                   dvoid           *ctxp,
                   OCICallbackLobRead cbfp,
                   ub2             csid,
                   ub1             csfrm );
<br /><br />

Comments
Reads a portion of a LOB/FILE as specified by the call into a buffer. Data
read from a hole is returned as 0s. It is an error to try to read from a NULL
LOB/FILE. The OS FILE must already exist on the server and must have been
opened using the input locator. Oracle must hav epermission to read the OS
file and user must have read permission on the directory object.
<br /><br />

Parameters
svchp (IN/OUT) - the service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
locp (IN/OUT) - a LOB locator that uniquely references a LOB.
offset (IN) - On input, it is the absolute offset, for character LOBs in the
number of characters from the beginning of the LOB, for binary LOBs it is the
number of bytes. Starts from 1.
amtp (IN/OUT) - On input, the number of character or bytes to be read. On
output, the actual number of bytes or characters read.
If the amount of bytes to be read is larger than the buffer length it is
assumed that the LOB is being read in a streamed mode. On input if this value
is 0, then the data shall be read in streamed mode from the LOB until the end
of LOB. If the data is read in pieces, *amtp always contains the length of
the last piece read.  If a callback function is defined, then this callback
function will be invoked each time bufl bytes are read off the pipe. Each
piece will be written into bufp.
If the callback function is not defined, then OCI_NEED_DATA error code will
be returned. The application must invoke the LOB read over and over again to
read more pieces of the LOB until the OCI_NEED_DATA error code is not
returned. The buffer pointer and the length can be different in each call
if the pieces are being read into different sizes and location.
bufp (IN) - the pointer to a buffer into which the piece will be read. The
length of the allocated memory is assumed to be bufl.
bufl (IN) - the length of the buffer in octets.
ctxp (IN) - the context for the call back function. Can be NULL.
cbfp (IN) - a callback that may be registered to be called for each piece. If
this is NULL, then OCI_NEED_DATA will be returned for each piece.
The callback function must return OCI_CONTINUE for the read to continue.
If any other error code is returned, the LOB read is aborted.
  ctxp (IN) - the context for the call back function. Can be NULL.
  bufp (IN) - a buffer pointer for the piece.
  len (IN) - the length of length of current piece in bufp.
  piece (IN) - which piece - OCI_FIRST_PIECE, OCI_NEXT_PIECE or
  OCI_LAST_PIECE.
csid - the character set ID of the buffer data
csfrm - the character set form of the buffer data
<br /><br />

Related Functions
OCIErrorGet, OCILobWrite, OCILobFileOpen, OCILobFileSetName, CREATE DIRECTORY
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCILobTrim()
<br /><br />

Name
<br /><br />

OCI Lob  Trim
<br /><br />

Purpose
Trims the lob value to a shorter length
<br /><br />

Syntax
sword OCILobTrim ( OCISvcCtx       *svchp,
                 OCIError        *errhp,
                 OCILobLocator   *locp,
                 ub4             newlen );
<br /><br />

Comments
Truncates LOB data to a specified shorter length.
<br /><br />

Parameters
svchp (IN) - the service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
locp (IN/OUT) - a LOB locator that uniquely references the LOB. This locator
must be a locator that was obtained from the server specified by svchp.
newlen (IN) - the new length of the LOB data, which must be less than or equal
to the current length.
<br /><br />

Related Functions
OCIErrorGet, OCILobWrite, OCiLobErase, OCILobAppend, OCILobCopy
<br /><br />

<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCILobWrite()
<br /><br />

Name
OCI Lob Write
<br /><br />

Purpose
Writes a buffer into a LOB
<br /><br />

Syntax
sword OCILobWrite ( OCISvcCtx       *svchp,
                    OCIError        *errhp,
                    OCILobLocator   *locp,
                    ub4             offset,
                    ub4             *amtp,
                    dvoid           *bufp,
                    ub4             buflen,
                    ub1             piece,
                    dvoid           *ctxp,
                    OCICallbackLobWrite   (cbfp)
                                    (
                                    dvoid    *ctxp,
                                    dvoid    *bufp,
                                    ub4      *lenp,
                                    ub1      *piecep )
                    ub2             csid
                    ub1             csfrm );
<br /><br />

<br /><br />

Comments
Writes a buffer into a LOB as specified. If LOB data already exists
it is overwritten with the data stored in the buffer.
The buffer can be written to the LOB in a single piece with this call, or
it can be provided piecewise using callbacks or a standard polling method.
If this value of the piece parameter is OCI_FIRST_PIECE, data must be
provided through callbacks or polling.
If a callback function is defined in the cbfp parameter, then this callback
function will be invoked to get the next piece after a piece is written to
the pipe. Each piece will be written from bufp.
If no callback function is defined, then OCILobWrite() returns the
OCI_NEED_DATA error code. The application must all OCILobWrite() again
to write more pieces of the LOB. In this mode, the buffer pointer and the
length can be different in each call if the pieces are of different sizes and
from different locations. A piece value of OCI_LAST_PIECE terminates the
piecewise write.
<br /><br />

Parameters
svchp (IN/OUT) - the service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
locp (IN/OUT) - a LOB locator that uniquely references a LOB.
offset (IN) - On input, it is the absolute offset, for character LOBs in
the number of characters from the beginning of the LOB, for binary LOBs it
is the number of bytes. Starts at 1.
bufp (IN) - the pointer to a buffer from which the piece will be written. The
length of the allocated memory is assumed to be the value passed in bufl.
Even if the data is being written in pieces, bufp must contain the first
piece of the LOB when this call is invoked.
bufl (IN) - the length of the buffer in bytes.

<strong>Note:</strong>
This parameter assumes an 8-bit byte. If your platform uses a
longer byte, the value of bufl must be adjusted accordingly.
piece (IN) - which piece of the buffer is being written. The default value for
this parameter is OCI_ONE_PIECE, indicating the buffer will be written in a
single piece.
The following other values are also possible for piecewise or callback mode:
OCI_FIRST_PIECE, OCI_NEXT_PIECE and OCI_LAST_PIECE.
amtp (IN/OUT) - On input, takes the number of character or bytes to be
written. On output, returns the actual number of bytes or characters written.
If the data is written in pieces, *amtp will contain the total length of the
pieces written at the end of the call (last piece written) and is undefined in
between.
(Note it is different from the piecewise read case)
ctxp (IN) - the context for the call back function. Can be NULL.
cbfp (IN) - a callback that may be registered to be called for each piece in
a piecewise write. If this is NULL, the standard polling method will be used.
The callback function must return OCI_CONTINUE for the write to continue.
If any other error code is returned, the LOB write is aborted. The
callback takes the following parameters:
  ctxp (IN) - the context for the call back function. Can be NULL.
  bufp (IN/OUT) - a buffer pointer for the piece.
  lenp (IN/OUT) - the length of the buffer (in octets) and the length of
  current piece in bufp (out octets).
  piecep (OUT) - which piece - OCI_NEXT_PIECE or OCI_LAST_PIECE.
csid - the character set ID of the buffer data
csfrm - the character set form of the buffer data
Related Functions
<br /><br />

OCILobWriteAppend()
<br /><br />

Name
OCI Lob Write Append
<br /><br />

Purpose
Writes data to the end of a LOB value. This call provides the ability
to get the length of the data and append it to the end of the LOB in
a single round trip to the server.
<br /><br />

Syntax
sword OCILobWriteAppend ( OCISvcCtx       *svchp,
                    OCIError        *errhp,
                    OCILobLocator   *locp,
                    ub4             *amtp,
                    dvoid           *bufp,
                    ub4             buflen,
                    ub1             piece,
                    dvoid           *ctxp,
                    OCICallbackLobWrite   (cbfp)
                                    (
                                    dvoid    *ctxp,
                                    dvoid    *bufp,
                                    ub4      *lenp,
                                    ub1      *piecep )
                    ub2             csid
                    ub1             csfrm );
<br /><br />

<br /><br />

Comments
Writes a buffer to the end of a LOB as specified. If LOB data already exists
it is overwritten with the data stored in the buffer.
The buffer can be written to the LOB in a single piece with this call, or
it can be provided piecewise using callbacks or a standard polling method.
If this value of the piece parameter is OCI_FIRST_PIECE, data must be
provided through callbacks or polling.
If a callback function is defined in the cbfp parameter, then this callback
function will be invoked to get the next piece after a piece is written to the
pipe. Each piece will be written from bufp.
If no callback function is defined, then OCILobWriteAppend() returns the
OCI_NEED_DATA error code. The application must all OCILobWriteAppend() again
to write more pieces of the LOB. In this mode, the buffer pointer and the
length can be different in each call if the pieces are of different sizes and
from different locations. A piece value of OCI_LAST_PIECE terminates the
piecewise write.
<br /><br />

Parameters
svchp (IN/OUT) - the service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
locp (IN/OUT) - a LOB locator that uniquely references a LOB.
bufp (IN) - the pointer to a buffer from which the piece will be written. The
length of the allocated memory is assumed to be the value passed in bufl. Even
if the data is being written in pieces, bufp must contain the first piece of
the LOB when this call is invoked.
bufl (IN) - the length of the buffer in bytes.

<strong>Note:</strong>
This parameter assumes an 8-bit byte. If your platform uses a
longer byte, the value of bufl must be adjusted accordingly.
piece (IN) - which piece of the buffer is being written. The default value for
this parameter is OCI_ONE_PIECE, indicating the buffer will be written in a
single piece.
The following other values are also possible for piecewise or callback mode:
OCI_FIRST_PIECE, OCI_NEXT_PIECE and OCI_LAST_PIECE.
amtp (IN/OUT) - On input, takes the number of character or bytes to be
written. On output, returns the actual number of bytes or characters written.
If the data is written in pieces, *amtp will contain the total length of the
pieces written at the end of the call (last piece written) and is undefined in
between.
(Note it is different from the piecewise read case)
ctxp (IN) - the context for the call back function. Can be NULL.
cbfp (IN) - a callback that may be registered to be called for each piece in a
piecewise write. If this is NULL, the standard polling method will be used.
The callback function must return OCI_CONTINUE for the write to continue.
If any other error code is returned, the LOB write is aborted. The
callback takes the following parameters:
  ctxp (IN) - the context for the call back function. Can be NULL.
  bufp (IN/OUT) - a buffer pointer for the piece.
  lenp (IN/OUT) - the length of the buffer (in octets) and the length of
  current piece in bufp (out octets).
  piecep (OUT) - which piece - OCI_NEXT_PIECE or OCI_LAST_PIECE.
csid - the character set ID of the buffer data
csfrm - the character set form of the buffer data
Related Functions
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCILobGetStorageLimit()
<br /><br />

Name
OCI Lob Get Storage Limit
<br /><br />

Purpose
To get the maximum Length of a LOB in bytes that can be stored in the database.
<br /><br />

Syntax
sword OCILobGetStorageLimit ( OCISvcCtx       *svchp,
                    OCIError        *errhp,
                    OCILobLocator   *locp,
                    oraub8          *limitp);
<br /><br />

<br /><br />

Comments
With unlimited size LOB support the limit for a LOB is no longer restricted to 4GB.
This interface should be used to get the actual limit for storing data for a specific
LOB locator. Note that if the compatibality is set to 9.2 or older the limit would still
be 4GB.
<br /><br />

Parameters
svchp (IN/OUT) - the service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
locp (IN/OUT) - a LOB locator that uniquely references a LOB.
limitp (OUT)  - The storage limit for a LOB in bytes.
Related Functions
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCILogoff()
Name
OCI simplified Logoff
Purpose
This function is used to terminate a session created with OCILogon() or
OCILogon2().
Syntax
sword OCILogoff ( OCISvcCtx      *svchp
                   OCIError       *errhp );
Comments
This call is used to terminate a session which was created with OCILogon() or
OCILogon2().
This call implicitly deallocates the server, authentication, and service
context handles.

<strong>Note:</strong>
For more information on logging on and off in an application,
refer to the section "Application Initialization, Connection, and
Authorization" on page 2-16.
Parameters
svchp (IN) - the service context handle which was used in the call to
OCILogon() or OCILogon2().
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
See Also
OCILogon(), OCILogon2().
<br /><br />

<br /><br />

<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCILogon()
Name
OCI Service Context Logon
Purpose
This function is used to create a simple logon session.
Syntax
sword OCILogon ( OCIEnv          *envhp,
                       OCIError        *errhp,
                       OCISvcCtx       *svchp,
                       CONST OraText      *username,
                       ub4             uname_len,
                       CONST OraText      *password,
                       ub4             passwd_len,
                       CONST OraText      *dbname,
                       ub4             dbname_len );
Comments
This function is used to create a simple logon session for an application.

<strong>Note:</strong>
Users requiring more complex session (e.g., TP monitor
applications) should refer to the section "Application Initialization,
Connection, and Authorization" on page 2-16.
This call allocates the error and service context handles which are passed to
it. This call also implicitly allocates server and authentication handles
associated with the session.  These handles can be retrieved by calling
OCIAttrGet() on the service context handle.
Parameters
envhp (IN) - the OCI environment handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
svchp (OUT) - the service context pointer.
username (IN) - the username.
uname_len (IN) - the length of username.
password (IN) - the user's password.
passwd_len (IN) - the length of password.
dbname (IN) - the name of the database to connect to.
dbname_len (IN) - the length of dbname.
See Also
OCILogoff()
<br /><br />

<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCILogon2()
Name
OCI Service Context Logon
Purpose
This function is used to create a logon session in connection pooling mode.
Syntax
sword OCILogon2 ( OCIEnv          *envhp,
                       OCIError        *errhp,
                       OCISvcCtx       **svchp,
                       CONST OraText      *username,
                       ub4             uname_len,
                       CONST OraText      *password,
                       ub4             passwd_len,
                       CONST OraText      *dbname,
                       ub4             dbname_len,
                       ub4             mode);
Comments
This function is used to create a simple logon session for an application in
Connection Pooling mode. The valid values for mode are currently OCI_POOL and
OCI_DEFAULT. Call to this function with OCI_DEFAULT mode is equivalent to
OCILogon() call.
This call allocates the error and service context handles which are passed to
it. This call also implicitly allocates server and authentication handles
associated with the session.  These handles can be retrieved by calling
OCIAttrGet() on the service context handle. This call assumes that
OCIConnectionPoolCreate() has already been called for the same dbname.
Parameters
envhp (IN) - the OCI environment handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
svchp (OUT) - the service context pointer.
username (IN) - the username.
uname_len (IN) - the length of username.
password (IN) - the user's password. If this is <strong>null</strong>, it is assumed that a
                proxy session has to be created and the required grants on
                the database are already done.
passwd_len (IN) - the length of password.
dbname (IN) - the name of the database to connect to.
dbname_len (IN) - the length of dbname.
mode (IN) - the mode for doing the server attach. Should be OCI_POOL for
            using Connection Pooling.
<br /><br />

<br /><br />

See Also
OCILogoff()
<br /><br />

<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCIMemoryFree()
Name
OCI FREE Memory
Purpose
Frees up storage associated with the pointer.
Syntax
void OCIMemoryFree ( CONST OCIStmt   *stmhp,
                     dvoid           *memptr);
Comments
Frees up dynamically allocated data pointers associated with the pointer using
either the default memory free function or the registered memory free
function, as the case may be.
A user-defined memory free function can be registered during the initial call
to OCIInitialize().
This call is always successful.
Parameters
stmhp (IN) - statement handle which returned this data buffer.
memptr (IN) - pointer to data allocated by the client library.
Related Functions
OCIInitialize()
<br /><br />

<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCIParamGet()
Name
OCI Get PARaMeter
Purpose
Returns a descriptor of a parameter specified by position in the describe
handle or statement handle.
Syntax
sword OCIParamGet ( CONST dvoid       *hndlp,
                  ub4         htype,
                  OCIError    *errhp,
                  dvoid    **parmdpp,
                  ub4         pos );
Comments
This call returns a descriptor of a parameter specified by position in the
describe handle or statement handle. Parameter descriptors are always
allocated internally by the OCI library. They are read-only.
OCI_NO_DATA may be returned if there are no parameter descriptors for this
position.
See Appendix B for more detailed information about parameter descriptor
attributes.
Parameters
hndlp (IN) - a statement handle or describe handle. The OCIParamGet()
function will return a parameter descriptor for this handle.
htype (IN) - the type of the handle passed in the handle parameter. Valid
types are OCI_HTYPE_DESCRIBE, for a describe handle OCI_HTYPE_STMT, for a
statement handle
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
parmdpp (OUT) - a descriptor of the parameter at the position given in the pos
parameter.
pos (IN) - position number in the statement handle or describe handle. A
parameter descriptor will be returned for this position.

<strong>Note:</strong>
OCI_NO_DATA may be returned if there are no parameter
descriptors for this position.
Related Functions
OCIAttrGet(), OCIAttrSet()
<br /><br />

<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCIParamSet()
Name
OCI Parameter Set in handle
Purpose
Used to set a complex object retrieval descriptor into a complex object
retrieval handle.
Syntax
sword OCIParamGet ( dvoid *hndlp,
                       ub4 htyp,
                      OCIError *errhp,
                      CONST dvoid *dscp,
                      ub4 dtyp,
                      ub4 pos );
Comments
This call sets a given complex object retrieval descriptor into a complex
object retrieval handle.
The handle must have been previously allocated using OCIHandleAlloc(), and
the descriptor must have been previously allocated using OCIDescAlloc().
Attributes of the descriptor are set using OCIAttrSet().
Parameters
hndlp (IN/OUT) - handle pointer.
htype (IN) - handle type.
errhp (IN/OUT) - error handle.
dscp (IN) - complex object retrieval descriptor pointer.
dtyp (IN) -
pos (IN) - position number.
See Also
<br /><br />

<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCIPasswordChange()
Name
OCI Change PassWord
Purpose
This call allows the password of an account to be changed.
Syntax
sword OCIPasswordChange ( OCISvcCtx     *svchp,
                        OCIError      *errhp,
                        CONST OraText    *user_name,
                        ub4           usernm_len,
                        CONST OraText    *opasswd,
                        ub4           opasswd_len,
                        CONST OraText    *npasswd,
                        sb4           npasswd_len,
                        ub4           mode);
Comments
This call allows the password of an account to be changed. This call is
similar to OCISessionBegin() with the following differences:
If the user authentication is already established, it authenticates
the account using the old password and then changes the
password to the new password
If the user authentication is not established, it establishes a user
authentication and authenticates the account using the old
password, then changes the password to the new password.
This call is useful when the password of an account is expired and
OCISessionBegin() returns an error or warning which indicates that the
password has expired.
Parameters
svchp (IN/OUT) - a handle to a service context. The service context handle
must be initialized and have a server context handle associated with it.
errhp (IN) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
user_name (IN) - specifies the user name. It points to a character string,
whose length is specified in usernm_len. This parameter must be NULL if the
service context has been initialized with an authentication handle.
usernm_len (IN) - the length of the user name string specified in user_name.
For a valid user name string, usernm_len must be non-zero.
opasswd (IN) - specifies the user's old password. It points to a character
string, whose length is specified in opasswd_len .
opasswd_len (IN) - the length of the old password string specified in opasswd.
For a valid password string, opasswd_len must be non-zero.
npasswd (IN) - specifies the user's new password. It points to a character
string, whose length is specified in npasswd_len which must be non-zero for a
valid password string. If the password complexity verification routine is
specified in the user's profile to verify the new password's complexity, the
new password must meet the complexity requirements of the verification
function.
npasswd_len (IN)  - then length of the new password string specified in
npasswd. For a valid password string, npasswd_len must be non-zero.
mode - pass as OCI_DEFAULT.
Related Functions
OCISessionBegin()
<br /><br />

<br /><br />

----------------------------------OCIReset------------------------------------
<br /><br />

<br /><br />

OCIReset()
Name
OCI Reset
Purpose
Resets the interrupted asynchronous operation and protocol. Must be called
if a OCIBreak call had been issued while a non-blocking operation was in
progress.
Syntax
sword OCIReset ( dvoid      *hndlp,
                 OCIError   *errhp);
Comments
This call is called in non-blocking mode ONLY. Resets the interrupted
asynchronous operation and protocol. Must be called if a OCIBreak call
had been issued while a non-blocking operation was in progress.
Parameters
hndlp (IN) - the service context handle or the server context handle.
errhp (IN) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
Related Functions
<br /><br />

<br /><br />

OCIResultSetToStmt()
Name
OCI convert Result Set to Statement Handle
Purpose
Converts a descriptor to statement handle for fetching rows.
Syntax
sword OCIResultSetToStmt ( OCIResult     *rsetdp,
                         OCIError      *errhp );
Comments
Converts a descriptor to statement handle for fetching rows.
A result set descriptor can be allocated with a call to OCIDescAlloc().
Parameters
rsetdp (IN/OUT) - a result set descriptor pointer.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
Related Functions
OCIDescAlloc()
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCIServerAttach()
Name
OCI ATtaCH to server
Purpose
Creates an access path to a data source for OCI operations.
Syntax
sword OCIServerAttach ( OCIServer    *srvhp,
                      OCIError     *errhp,
                      CONST OraText   *dblink,
                      sb4          dblink_len,
                      ub4          mode);
Comments
This call is used to create an association between an OCI application and a
particular server.
This call initializes a server context handle, which must have been previously
allocated with a call to OCIHandleAlloc().
The server context handle initialized by this call can be associated with a
service context through a call to OCIAttrSet(). Once that association has been
made, OCI operations can be performed against the server.
If an application is operating against multiple servers, multiple server
context handles can be maintained. OCI operations are performed against
whichever server context is currently associated with the service context.
Parameters
srvhp (IN/OUT) - an uninitialized server context handle, which gets
initialized by this call. Passing in an initialized server handle causes an
error.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
dblink (IN) - specifies the database (server) to use. This parameter points to
a character string which specifies a connect string or a service point. If the
connect string is NULL, then this call attaches to the default host. The length
of connstr is specified in connstr_len. The connstr pointer may be freed by the
caller on return.
dblink_len (IN) - the length of the string pointed to by connstr. For a valid
connect string name or alias, connstr_len must be non-zero.
mode (IN) - specifies the various modes of operation.  For release 8.0, pass as
OCI_DEFAULT - in this mode, calls made to the server on this server context
are made in blocking mode.
Example
See the description of OCIStmtPrepare() on page 13-96 for an example showing
the use of OCIServerAttach().
Related Functions
OCIServerDetach()
<br /><br />

<br /><br />

<br /><br />

OCIServerDetach()
Name
OCI DeTaCH server
Purpose
Deletes an access to a data source for OCI operations.
Syntax
sword OCIServerDetach ( OCIServer   *svrhp,
                      OCIError    *errhp,
                      ub4         mode);
Comments
This call deletes an access to data source for OCI operations, which was
established by a call to OCIServerAttach().
Parameters
srvhp (IN) - a handle to an initialized server context, which gets reset to
uninitialized state. The handle is not de-allocated.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
mode (IN) - specifies the various modes of operation. The only valid mode is
OCI_DEFAULT for the default mode.
Related Functions
OCIServerAttach()
<br /><br />

<br /><br />

<br /><br />

OCIServerVersion()
Name
OCI VERSion
Purpose
Returns the version string of the Oracle server.
Syntax
sword OCIServerVersion ( dvoid        *hndlp,
                       OCIError     *errhp,
                       OraText         *bufp,
                       ub4          bufsz
                       ub1          hndltype );
Comments
This call returns the version string of the Oracle server.
For example, the following might be returned as the version string if your
application is running against a 7.3.2 server:
Oracle7 Server Release 7.3.2.0.0 - Production Release
PL/SQL Release 2.3.2.0.0 - Production
CORE Version 3.5.2.0.0 - Production
TNS for SEQUENT DYNIX/ptx: Version 2.3.2.0.0 - Production
NLSRTL Version 3.2.2.0.0 - Production
<br /><br />

Parameters
hndlp (IN) - the service context handle or the server context handle.
errhp (IN) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
bufp (IN) - the buffer in which the version information is returned.
bufsz (IN) - the length of the buffer.
hndltype (IN) - the type of handle passed to the function.
Related Functions
<br /><br />

<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCISessionBegin()
Name
OCI Session Begin and authenticate user
Purpose
Creates a user authentication and begins a user session for a given server.
Syntax
sword OCISessionBegin ( OCISvcCtx     *svchp,
                      OCIError      *errhp,
                      OCISession    *usrhp,
                      ub4           credt,
                      ub4           mode);
<br /><br />

Comments
For Oracle8, OCISessionBegin() must be called for any given server handle
before requests can be made against it. Also, OCISessionBegin() only supports
authenticating the user for access to the Oracle server specified by the
server handle in the service context. In other words, after OCIServerAttach()
is called to initialize a server handle, OCISessionBegin() must be called to
authenticate the user for that given server.
When OCISessionBegin() is called for the first time for the given server
handle, the initialized authentication handle is called a primary
authentication context. A primary authentication context may not be created
with the OCI_MIGRATE mode. Also, only one primary authentication context can
be created for a given server handle and the primary authentication context c
an only ever be used with that server handle. If the primary authentication
context is set in a service handle with a different server handle, then an
error will result.
After OCISessionBegin() has been called for the server handle, and the primary
authentication context is set in the service handle, OCISessionBegin() may be
called again to initialize another authentication handle with different (or
the same) credentials. When OCISessionBegin() is called with a service handle
set with a primary authentication context, the returned authentication context
in authp is called a user authentication context. As many user authentication
contexts may be initialized as desired.
User authentication contexts may be created with the OCI_MIGRATE mode.
If the OCI_MIGRATE mode is not specified, then the user authentication
context can only ever be used with the same server handle set in svchp. If
OCI_MIGRATE mode is specified, then the user authentication may be set
with different server handles. However, the user authentication context is
restricted to use with only server handles which resolve to the same database
instance and that have equivalent primary authentication contexts. Equivalent
authentication contexts are those which were authenticated as the same
database user.
OCI_SYSDBA, OCI_SYSOPER, and OCI_PRELIM_AUTH may only be used
with a primary authentication context.
To provide credentials for a call to OCISessionBegin(), one of two methods are
supported. The first is to provide a valid username and password pair for
database authentication in the user authentication handle passed to
OCISessionBegin(). This involves using OCIAttrSet() to set the
OCI_ATTR_USERNAME and OCI_ATTR_PASSWORD attributes on the
authentication handle. Then OCISessionBegin() is called with
OCI_CRED_RDBMS.

<strong>Note:</strong>
When the authentication handle is terminated using
OCISessionEnd(), the username and password attributes remain
unchanged and thus can be re-used in a future call to OCISessionBegin().
Otherwise, they must be reset to new values before the next
OCISessionBegin() call.
The second type of credentials supported are external credentials. No
attributes need to be set on the authentication handle before calling
OCISessionBegin(). The credential type is OCI_CRED_EXT. This is equivalent
to the Oracle7 `connect /' syntax. If values have been set for
OCI_ATTR_USERNAME and OCI_ATTR_PASSWORD, then these are
ignored if OCI_CRED_EXT is used.
Parameters
svchp (IN) - a handle to a service context. There must be a valid server
handle set in svchp.
errhp (IN) - an error handle to the retrieve diagnostic information.
usrhp (IN/OUT) - a handle to an authentication context, which is initialized
by this call.
credt (IN) - specifies the type of credentials to use for authentication.
Valid values for credt are:
OCI_CRED_RDBMS - authenticate using a database username and
password pair as credentials. The attributes OCI_ATTR_USERNAME
and OCI_ATTR_PASSWORD should be set on the authentication
context before this call.
OCI_CRED_EXT - authenticate using external credentials. No username
or password is provided.
mode (IN) - specifies the various modes of operation. Valid modes are:
OCI_DEFAULT - in this mode, the authentication context returned may
only ever be set with the same server context specified in svchp. This
establishes the primary authentication context.
OCI_MIGRATE - in this mode, the new authentication context may be
set in a service handle with a different server handle. This mode
establishes the user authentication context.
OCI_SYSDBA - in this mode, the user is authenticated for SYSDBA
access.
OCI_SYSOPER - in this mode, the user is authenticated for SYSOPER
access.
OCI_PRELIM_AUTH - this mode may only be used with OCI_SYSDBA
or OCI_SYSOPER to authenticate for certain administration tasks.
Related Functions
OCISessionEnd()
<br /><br />

<br /><br />

<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCISessionEnd()
Name
OCI Terminate user Authentication Context
Purpose
Terminates a user authentication context created by OCISessionBegin()
Syntax
sword OCISessionEnd ( OCISvcCtx       *svchp,
                    OCIError        *errhp,
                    OCISession      *usrhp,
                    ub4             mode);
<br /><br />

Comments
The user security context associated with the service context is invalidated
by this call. Storage for the authentication context is not freed. The
transaction specified by the service context is implicitly committed. The
transaction handle, if explicitly allocated, may be freed if not being used.
Resources allocated on the server for this user are freed.
The authentication handle may be reused in a new call to OCISessionBegin().
Parameters
svchp (IN/OUT) - the service context handle. There must be a valid server
handle and user authentication handle associated with svchp.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
usrhp (IN) - de-authenticate this user. If this parameter is passed as NULL,
the user in the service context handle is de-authenticated.
mode (IN) - the only valid mode is OCI_DEFAULT.
Example
In this example, an authentication context is destroyed.
Related Functions
OCISessionBegin()
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCIStmtExecute()
Name
OCI EXECute
Purpose
This call associates an application request with a server.
Syntax
sword OCIStmtExecute ( OCISvcCtx           *svchp,
                     OCIStmt             *stmtp,
                     OCIError            *errhp,
                     ub4                 iters,
                     ub4                 rowoff,
                     CONST OCISnapshot   *snap_in,
                     OCISnapshot         *snap_out,
                     ub4                 mode );
Comments
This function  is used to execute a prepared SQL statement.
Using an execute call, the application associates a request with a server. On
success, OCI_SUCCESS is returned.
If a SELECT statement is executed, the description of the select list follows
implicitly as a response. This description is buffered on the client side for
describes, fetches and define type conversions. Hence it is optimal to
describe a select list only after an execute.
Also for SELECT statements, some results are available implicitly. Rows will
be received and buffered at the end of the execute. For queries with small row
count, a prefetch causes memory to be released in the server if the end of
fetch is reached, an optimization that may result in memory usage reduction.
Set attribute call has been defined to set the number of rows to be prefetched
per result set.
For SELECT statements, at the end of the execute, the statement handle
implicitly maintains a reference to the service context on which it is
executed. It is the user's responsibility to maintain the integrity of the
service context. If the attributes of a service context is changed for
executing some operations on this service context, the service context must
be restored to have the same attributes, that a statement was executed with,
prior to a fetch on the statement handle. The implicit reference is maintained
until the statement handle is freed or the fetch is cancelled or an end of
fetch condition is reached.

<strong>Note:</strong>
If output variables are defined for a SELECT statement before a
call to OCIStmtExecute(), the number of rows specified by iters will be
fetched directly into the defined output buffers and additional rows
equivalent to the prefetch count will be prefetched. If there are no
additional rows, then the fetch is complete without calling
OCIStmtFetch().
The execute call will return errors if the statement has bind data types that
are not supported in an Oracle7 server.
Parameters
svchp (IN/OUT) - service context handle.
stmtp (IN/OUT) - an statement handle - defines the statement and the
associated data to be executed at the server. It is invalid to pass in a
statement handle that has bind of data types only supported in release 8.0
when srvchp points to an Oracle7 server.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error. If the statement is being
batched and it is successful, then this handle will contain this particular
statement execution specific errors returned from the server when the batch is
flushed.
iters (IN) - the number of times this statement is executed for non-Select
statements. For Select statements, if iters is non-zero, then defines must
have been done for the statement handle. The execution fetches iters rows into
these predefined buffers and prefetches more rows depending upon the prefetch
row count. This function returns an error if iters=0 for non-SELECT
statements.
rowoff (IN) - the index from which the data in an array bind is relevant for
this multiple row execution.
snap_in (IN) - this parameter is optional. if supplied, must point to a
snapshot descriptor of type OCI_DTYPE_SNAP.  The contents of this descriptor
must be obtained from the snap_out parameter of a previous call.  The
descriptor is ignored if the SQL is not a SELECT.  This facility allows
multiple service contexts to ORACLE to see the same consistent snapshot of the
database's committed data.  However, uncommitted data in one context is not
visible to another context even using the same snapshot.
snap_out (OUT) - this parameter optional. if supplied, must point to a
descriptor of type OCI_DTYPE_SNAP. This descriptor is filled in with an
opaque representation which is the current ORACLE "system change
number" suitable as a snap_in input to a subsequent call to OCIStmtExecute().
This descriptor should not be used any longer than necessary in order to avoid
"snapshot too old" errors.
mode (IN) - The modes are:
If OCI_DEFAULT_MODE, the default mode, is selected, the request is
immediately executed. Error handle contains diagnostics on error if any.
OCI_EXACT_FETCH - if the statement is a SQL SELECT, this mode is
only valid if the application has set the prefetch row count prior to this
call. In this mode, the OCI library will get up to the number of rows
specified (i.e., prefetch row count plus iters). If the number of rows
returned by the query is greater than this value, OCI_ERROR will be
returned with ORA-01422 as the implementation specific error in a
diagnostic record. If the number of rows returned by the query is
smaller than the prefetch row count, OCI_SUCCESS_WITH_INFO will
be returned with ORA-01403 as the implementation specific error. The
prefetch buffer size is ignored and the OCI library tries to allocate all the
space required to contain the prefetched rows. The exact fetch semantics
apply to only the top level rows. No more rows can be fetched for this
query at the end of the call.
OCI_KEEP_FETCH_STATE - the result set rows (not yet fetched) of this
statement executed in this transaction will be maintained when the
transaction is detached for migration. By default, a query is cancelled
when a transaction is detached for migration. This mode is the default
mode when connected to a V7 server.
Related Functions
OCIStmtPrepare()
<br /><br />

<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCIStmtFetch()
Name
OCI FetCH
Purpose
Fetches rows from a query.
Syntax
sword OCIStmtFetch ( OCIStmt     *stmtp,
                   OCIError    *errhp,
                   ub4         nrows,
                   ub2         orientation,
                   ub4         mode);
Comments
The fetch call is a local call, if prefetched rows suffice. However, this is
transparent to the application. If LOB columns are being read, LOB locators
are fetched for subsequent LOB operations to be performed on these locators.
Prefetching is turned off if LONG columns are involved.
A fetch with nrows set to 0 rows effectively cancels the fetch for this
statement.
Parameters
stmtp (IN) - a statement (application request) handle.
errhp (IN) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
nrows (IN) - number of rows to be fetched from the current position.
orientation (IN) - for release 8.0, the only acceptable value is
OCI_FETCH_NEXT, which is also the default value.
mode (IN) - for release 8.0, beta-1, the following mode is defined.
OCI_DEFAULT - default mode
OCI_EOF_FETCH - indicates that it is the last fetch from the result set.
If nrows is non-zero, setting this mode effectively cancels fetching after
retrieving nrows, otherwise it cancels fetching immediately.
Related Functions
OCIAttrGet()
<br /><br />

OCIStmtFetch2()
Name
OCI FetCH2
Purpose
Fetches rows from a query.
Syntax
sword OCIStmtFetch2 ( OCIStmt     *stmtp,
                   OCIError    *errhp,
                   ub4         nrows,
                   ub2         orientation,
                   ub4         scrollOffset,
                   ub4         mode);
Comments
The fetch call works similar to the OCIStmtFetch call with the
addition of the fetchOffset parameter. It can be used on any
statement handle, whether it is scrollable or not. For a
non-scrollable statement handle, the only acceptable value
will be OCI_FETCH_NEXT, and the fetchOffset parameter will be
ignored. Applications are encouraged to use this new call.
<br /><br />

A fetchOffset with OCI_FETCH_RELATIVE is equivalent to
OCI_FETCH_CURRENT with a value of 0, is equivalent to
OCI_FETCH_NEXT with a value of 1, and equivalent to
OCI_FETCH_PRIOR with a value of -1. Note that the range of
accessible rows is [1,OCI_ATTR_ROW_COUNT] beyond which an
error could be raised if sufficient rows do not exist in
<br /><br />

The fetch call is a local call, if prefetched rows suffice. However, this is
transparent to the application. If LOB columns are being read, LOB locators
are fetched for subsequent LOB operations to be performed on these locators.
Prefetching is turned off if LONG columns are involved.
A fetch with nrows set to 0 rows effectively cancels the fetch for this
statement.
Parameters
stmtp (IN) - a statement (application request) handle.
errhp (IN) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
nrows (IN) - number of rows to be fetched from the current position.
It defaults to 1 for orientation OCI_FETCH_LAST.
orientation (IN) -  The acceptable values are as follows, with
OCI_FETCH_NEXT being the default value.
OCI_FETCH_CURRENT gets the current row,
OCI_FETCH_NEXT gets the next row from the current position,
OCI_FETCH_FIRST gets the first row in the result set,
OCI_FETCH_LAST gets the last row in the result set,
OCI_FETCH_PRIOR gets the previous row from the current row in the result set,
OCI_FETCH_ABSOLUTE will fetch the row number (specified by fetchOffset
parameter) in the result set using absolute positioning,
OCI_FETCH_RELATIVE will fetch the row number (specified by fetchOffset
parameter) in the result set using relative positioning.
scrollOffset(IN) - offset used with the OCI_FETCH_ABSOLUTE and
OCI_FETCH_RELATIVE orientation parameters only. It specify
the new current position for scrollable result set. It is
ignored for non-scrollable result sets.
mode (IN) - for release 8.0, beta-1, the following mode is defined.
OCI_DEFAULT - default mode
OCI_EOF_FETCH - indicates that it is the last fetch from the result set.
If nrows is non-zero, setting this mode effectively cancels fetching after
retrieving nrows, otherwise it cancels fetching immediately.
Related Functions
OCIAttrGet()
<br /><br />

<br /><br />

<br /><br />

OCIStmtGetPieceInfo()
Name
OCI Get Piece Information
Purpose
Returns piece information for a piecewise operation.
Syntax
sword OCIStmtGetPieceInfo( CONST OCIStmt  *stmtp,
                         OCIError       *errhp,
                         dvoid          **hndlpp,
                         ub4            *typep,
                         ub1            *in_outp,
                         ub4            *iterp,
                         ub4            *idxp,
                         ub1            *piecep );
<br /><br />

Comments
When an execute/fetch call returns OCI_NEED_DATA to get/return a
dynamic bind/define value or piece, OCIStmtGetPieceInfo() returns the
relevant information: bind/define handle, iteration or index number and
which piece.
See the section "Runtime Data Allocation and Piecewise Operations" on page
5-16 for more information about using OCIStmtGetPieceInfo().
Parameters
stmtp (IN) - the statement when executed returned OCI_NEED_DATA.
errhp (OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
hndlpp (OUT) - returns a pointer to the bind or define handle of the bind or
define whose runtime data is required or is being provided.
typep (OUT) - the type of the handle pointed to by hndlpp: OCI_HTYPE_BIND
(for a bind handle) or OCI_HTYPE_DEFINE (for a define handle).
in_outp (OUT) - returns OCI_PARAM_IN if the data is required for an IN bind
value. Returns OCI_PARAM_OUT if the data is available as an OUT bind
variable or a define position value.
iterp (OUT) - returns the row number of a multiple row operation.
idxp (OUT) - the index of an array element of a PL/SQL array bind operation.
piecep (OUT) - returns one of the following defined values -
OCI_ONE_PIECE, OCI_FIRST_PIECE, OCI_NEXT_PIECE and
OCI_LAST_PIECE. The default value is always OCI_ONE_PIECE.
Related Functions
OCIAttrGet(), OCIAttrGet(), OCIStmtExecute(), OCIStmtFetch(),
OCIStmtSetPieceInfo()
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCIStmtPrepare()
Name
OCI Statement REQuest
Purpose
This call defines the SQL/PLSQL statement to be executed.
Syntax
sword OCIStmtPrepare ( OCIStmt      *stmtp,
                     OCIError     *errhp,
                     CONST OraText   *stmt,
                     ub4          stmt_len,
                     ub4          language,
                     ub4          mode);
Comments
This call is used to prepare a SQL or PL/SQL statement for execution. The
OCIStmtPrepare() call defines an application request.
This is a purely local call. Data values for this statement initialized in
subsequent bind calls will be stored in a bind handle which will hang off this
statement handle.
This call does not create an association between this statement handle and any
particular server.
See the section "Preparing Statements" on page 2-21 for more information
about using this call.
Parameters
stmtp (IN) - a statement handle.
errhp (IN) - an error handle to retrieve diagnostic information.
stmt (IN) - SQL or PL/SQL statement to be executed. Must be a <strong>null</strong>-terminated
string. The pointer to the OraText of the statement must be available as long
as the statement is executed.
stmt_len (IN) - length of the statement. Must not be zero.
language (IN) - V7, V8, or native syntax. Possible values are:
OCI_V7_SYNTAX - V7 ORACLE parsing syntax
OCI_V8_SYNTAX - V8 ORACLE parsing syntax
OCI_NTV_SYNTAX - syntax depending upon the version of the server.
mode (IN) - the only defined mode is OCI_DEFAULT for default mode.
Example
This example demonstrates the use of OCIStmtPrepare(), as well as the OCI
application initialization calls.
Related Functions
OCIAttrGet(), OCIStmtExecute()
<br /><br />

<br /><br />

OCIStmtPrepare2()
Name
OCI Statement REQuest with (a) early binding to svchp and/or
(b) stmt caching
Purpose
This call defines the SQL/PLSQL statement to be executed.
Syntax
sword OCIStmtPrepare2 ( OCISvcCtx *svchp,
                     OCIStmt      **stmtp,
                     OCIError     *errhp,
                     CONST OraText   *stmt,
                     ub4          stmt_len,
                     CONST OraText *key,
                     ub4          key_len,
                     ub4          language,
                     ub4          mode);
Comments
This call is used to prepare a SQL or PL/SQL statement for execution. The
OCIStmtPrepare() call defines an application request.
This is a purely local call. Data values for this statement initialized in
subsequent bind calls will be stored in a bind handle which will hang off this
statement handle.
This call creates an association between the statement handle and a service
context. It differs from OCIStmtPrepare in that respect.It also supports
stmt caching. The stmt will automatically be cached if the authp of the stmt
has enabled stmt caching.
Parameters
svchp (IN) - the service context handle that contains the session that
             this stmt handle belongs to.
stmtp (OUT) - an unallocated stmt handle must be pased in. An allocated
              and prepared  statement handle will be returned.
errhp (IN) - an error handle to retrieve diagnostic information.
stmt (IN) - SQL or PL/SQL statement to be executed. Must be a <strong>null</strong>-
            terminated string. The pointer to the OraText of the statement
            must be available as long as the statement is executed.
stmt_len (IN) - length of the statement. Must not be zero.
key (IN) - This is only Valid for OCI Stmt Caching. It indicates the
           key to search with. It thus optimizes the search in the cache.
key_len (IN) - the length of the key. This, too, is onlly valid for stmt
               caching.
language (IN) - V7, V8, or native syntax. Possible values are:
OCI_V7_SYNTAX - V7 ORACLE parsing syntax
OCI_V8_SYNTAX - V8 ORACLE parsing syntax
OCI_NTV_SYNTAX - syntax depending upon the version of the server.
mode (IN) - the defined modes are OCI_DEFAULT and OCI_PREP2_CACHE_SEARCHONLY.
Example
Related Functions
OCIStmtExecute(), OCIStmtRelease()
<br /><br />

<br /><br />

OCIStmtRelease()
Name
OCI Statement Release. This call is used to relesae the stmt that
was retreived using OCIStmtPrepare2(). If the stmt is release
using this call, OCIHandleFree() must not be called on the stmt
handle.
Purpose
This call releases the statement obtained by OCIStmtPrepare2
Syntax
sword OCIStmtRelease ( OCIStmt      *stmtp,
                     OCIError     *errhp,
                     cONST OraText *key,
                     ub4          key_len,
                     ub4          mode);
Comments
This call is used to release a handle obtained via OCIStmtPrepare2().
It also frees the memory associated with the handle.
This is a purely local call.
Parameters
stmtp (IN/OUT) - The statement handle to be released/freed.
errhp (IN) - an error handle to retrieve diagnostic information.
key (IN) - This is only Valid for OCI Stmt Caching. It indicates the
           key to tag the stmt with.
key_len (IN) - the length of the key. This, too, is only valid for stmt
               caching.
mode (IN) - the defined modes are OCI_DEFAULT for default mode and
            OCI_STRLS_CACHE_DELETE (only used for Stmt Caching).
Example
Related Functions
OCIStmtExecute(), OCIStmtPrepare2()
<br /><br />

<br /><br />

OCIStmtSetPieceInfo()
Name
OCI Set Piece Information
Purpose
Sets piece information for a piecewise operation.
Syntax
sword OCIStmtSetPieceInfo ( dvoid             *hndlp,
                          ub4               type,
                          OCIError          *errhp,
                          CONST dvoid       *bufp,
                          ub4               *alenp,
                          ub1               piece,
                          CONST dvoid       *indp,
                          ub2               *rcodep );
Comments
When an execute call returns OCI_NEED_DATA to get a dynamic IN/OUT
bind value or piece, OCIStmtSetPieceInfo() sets the piece information: the
buffer, the length, the indicator and which piece is currently being processed.
For more information about using OCIStmtSetPieceInfo() see the section
"Runtime Data Allocation and Piecewise Operations" on page 5-16.
Parameters
hndlp (IN/OUT) - the bind/define handle.
type (IN) - type of the handle.
errhp (OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
bufp (IN/OUT) - bufp is a pointer to a storage containing the data value or
the piece when it is an IN bind variable, otherwise bufp is a pointer to
storage for getting a piece or a value for OUT binds and define variables. For
named data types or REFs, a pointer to the object or REF is returned.
alenp (IN/OUT) - the length of the piece or the value.
piece (IN) - the piece parameter. The following are valid values:
OCI_ONE_PIECE, OCI_FIRST_PIECE, OCI_NEXT_PIECE, or
OCI_LAST_PIECE.
The default value is OCI_ONE_PIECE. This parameter is used for IN bind
variables only.
indp (IN/OUT) - indicator. A pointer to a sb2 value or pointer to an indicator
structure for named data types (SQLT_NTY) and REFs (SQLT_REF), i.e., *indp
is either an sb2 or a dvoid * depending upon the data type.
rcodep (IN/OUT) - return code.
Related Functions
OCIAttrGet(), OCIAttrGet(), OCIStmtExecute(), OCIStmtFetch(),
OCIStmtGetPieceInfo()
<br /><br />

<br /><br />

OCIFormatInit
Name
OCIFormat Package Initialize
Purpose
Initializes the OCIFormat package.
Syntax
sword OCIFormatInit(dvoid *hndl, OCIError *err);
Comments
This routine must be called before calling any other OCIFormat routine.
Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR
Parameters
hndl (IN/OUT) - OCI environment or session handle
err (IN/OUT) - OCI error handle
Related Functions
OCIFormatTerm()
<br /><br />

<br /><br />

OCIFormatString
Name
OCIFormat Package Format String
Purpose
Writes a text string into the supplied text buffer using the argument
list submitted to it and in accordance with the format string given.
Syntax
sword OCIFormatString(dvoid *hndl, OCIError *err, OraText *buffer,
                      sbig_ora bufferLength, sbig_ora *returnLength,
                      CONST OraText *formatString, ...);
Comments
The first call to this routine must be preceded by a call to the
OCIFormatInit routine that initializes the OCIFormat package
for use.  When this routine is no longer needed then terminate
the OCIFormat package by a call to the OCIFormatTerm routine.
Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR
Parameters
hndl         (IN/OUT) - OCI environment or session handle
err          (IN/OUT) - OCI error handle
buffer       (OUT)    - text buffer for the string
bufferLength (IN)     - length of the text buffer
returnLength (OUT)    - length of the formatted string
formatString (IN)     - format specification string
...          (IN)     - variable argument list
Related Functions
<br /><br />

<br /><br />

OCIFormatTerm
Name
OCIFormat Package Terminate
Purpose
Terminates the OCIFormat package.
Syntax
sword OCIFormatTerm(dvoid *hndl, OCIError *err);
Comments
It must be called after the OCIFormat package is no longer being used.
Returns OCI_SUCCESS, OCI_INVALID_HANDLE, or OCI_ERROR
Parameters
hndl (IN/OUT) - OCI environment or session handle
err (IN/OUT) - OCI error handle
Related Functions
OCIFormatInit()
<br /><br />

<br /><br />

OCIFormatTUb1
Name
OCIFormat Package ub1 Type
Purpose
Return the type value for the ub1 type.
Syntax
sword OCIFormatTUb1(void);
Comments
None
Parameters
None
Related Functions
None
<br /><br />

<br /><br />

OCIFormatTUb2
Name
OCIFormat Package ub2 Type
Purpose
Return the type value for the ub2 type.
Syntax
sword OCIFormatTUb2(void);
Comments
None
Parameters
None
Related Functions
None
<br /><br />

<br /><br />

OCIFormatTUb4
Name
OCIFormat Package ub4 Type
Purpose
Return the type value for the ub4 type.
Syntax
sword OCIFormatTUb4(void);
Comments
None
Parameters
None
Related Functions
None
<br /><br />

<br /><br />

OCIFormatTUword
Name
OCIFormat Package uword Type
Purpose
Return the type value for the uword type.
Syntax
sword OCIFormatTUword(void);
Comments
None
Parameters
None
Related Functions
None
<br /><br />

<br /><br />

OCIFormatTUbig_ora
Name
OCIFormat Package ubig_ora Type
Purpose
Return the type value for the ubig_ora type.
Syntax
sword OCIFormatTUbig_ora(void);
Comments
None
Parameters
None
Related Functions
None
<br /><br />

<br /><br />

OCIFormatTSb1
Name
OCIFormat Package sb1 Type
Purpose
Return the type value for the sb1 type.
Syntax
sword OCIFormatTSb1(void);
Comments
None
Parameters
None
Related Functions
None
<br /><br />

<br /><br />

OCIFormatTSb2
Name
OCIFormat Package sb2 Type
Purpose
Return the type value for the sb2 type.
Syntax
sword OCIFormatTSb2(void);
Comments
None
Parameters
None
Related Functions
None
<br /><br />

<br /><br />

OCIFormatTSb4
Name
OCIFormat Package sb4 Type
Purpose
Return the type value for the sb4 type.
Syntax
sword OCIFormatTSb4(void);
Comments
None
Parameters
None
Related Functions
None
<br /><br />

<br /><br />

OCIFormatTSword
Name
OCIFormat Package sword Type
Purpose
Return the type value for the sword type.
Syntax
sword OCIFormatTSword(void);
Comments
None
Parameters
None
Related Functions
None
<br /><br />

<br /><br />

OCIFormatTSbig_ora
Name
OCIFormat Package sbig_ora Type
Purpose
Return the type value for the sbig_ora type.
Syntax
sword OCIFormatTSbig_ora(void);
Comments
None
Parameters
None
Related Functions
None
<br /><br />

<br /><br />

OCIFormatTEb1
Name
OCIFormat Package eb1 Type
Purpose
Return the type value for the eb1 type.
Syntax
sword OCIFormatTEb1(void);
Comments
None
Parameters
None
Related Functions
None
<br /><br />

<br /><br />

OCIFormatTEb2
Name
OCIFormat Package eb2 Type
Purpose
Return the type value for the eb2 type.
Syntax
sword OCIFormatTEb2(void);
Comments
None
Parameters
None
Related Functions
None
<br /><br />

<br /><br />

OCIFormatTEb4
Name
OCIFormat Package eb4 Type
Purpose
Return the type value for the eb4 type.
Syntax
sword OCIFormatTEb4(void);
Comments
None
Parameters
None
Related Functions
None
<br /><br />

<br /><br />

OCIFormatTEword
Name
OCIFormat Package eword Type
Purpose
Return the type value for the eword type.
Syntax
sword OCIFormatTEword(void);
Comments
None
Parameters
None
Related Functions
None
<br /><br />

<br /><br />

OCIFormatTChar
Name
OCIFormat Package text Type
Purpose
Return the type value for the text type.
Syntax
sword OCIFormatTChar(void);
Comments
None
Parameters
None
Related Functions
None
<br /><br />

<br /><br />

OCIFormatTText
Name
OCIFormat Package *text Type
Purpose
Return the type value for the *text type.
Syntax
sword OCIFormatTText(void);
Comments
None
Parameters
None
Related Functions
None
<br /><br />

<br /><br />

OCIFormatTDouble
Name
OCIFormat Package double Type
Purpose
Return the type value for the double type.
Syntax
sword OCIFormatTDouble(void);
Comments
None
Parameters
None
Related Functions
None
<br /><br />

<br /><br />

OCIFormatDvoid
Name
OCIFormat Package dvoid Type
Purpose
Return the type value for the dvoid type.
Syntax
sword OCIFormatTDvoid(void);
Comments
None
Parameters
None
Related Functions
None
<br /><br />

<br /><br />

OCIFormatTEnd
Name
OCIFormat Package end Type
Purpose
Return the list terminator's "type".
Syntax
sword OCIFormatTEnd(void);
Comments
None
Parameters
None
Related Functions
None
<br /><br />

<br /><br />

OCISvcCtxToLda()
Name
OCI toggle SerVice context handle to Version 7 Lda_Def
Purpose
Toggles between a V8 service context handle and a V7 Lda_Def.
Syntax
sword OCISvcCtxToLda ( OCISvcCtx    *srvhp,
                     OCIError     *errhp,
                     Lda_Def      *ldap );
Comments
Toggles between an Oracle8 service context handle and an Oracle7 Lda_Def.
This function can only be called after a service context has been properly
initialized.
Once the service context has been translated to an Lda_Def, it can be used in
release 7.x OCI calls (e.g., obindps(), ofen()).

<strong>Note:</strong>
If there are multiple service contexts which share the same server
handle, only one can be in V7 mode at any time.
The action of this call can be reversed by passing the resulting Lda_Def to
the OCILdaToSvcCtx() function.
Parameters
svchp (IN/OUT) - the service context handle.
errhp (IN/OUT) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
ldap (IN/OUT) - a Logon Data Area for V7-style OCI calls which is initialized
by this call.
Related Functions
OCILdaToSvcCtx()
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCITransCommit()
Name
OCI TX (transaction) CoMmit
Purpose
Commits the transaction associated with a specified service context.
Syntax
sword OCITransCommit ( OCISvcCtx    *srvcp,
                     OCIError     *errhp,
                     ub4          flags );
Comments
The transaction currently associated with the service context is committed. If
it is a distributed transaction that the server cannot commit, this call
additionally retrieves the state of the transaction from the database to be
returned to the user in the error handle.
If the application has defined multiple transactions, this function operates
on the transaction currently associated with the service context. If the
application is working with only the implicit local transaction created when
database changes are made, that implicit transaction is committed.
If the application is running in the object mode, then the modified or updated
objects in the object cache for this transaction are also committed.
The flags parameter is used for one-phase commit optimization in distributed
transactions. If the transaction is non-distributed, the flags parameter is
ignored, and OCI_DEFAULT can be passed as its value. OCI applications
managing global transactions should pass a value of
OCI_TRANS_TWOPHASE to the flags parameter for a two-phase commit. The
default is one-phase commit.
Under normal circumstances, OCITransCommit() returns with a status
indicating that the transaction has either been committed or rolled back. With
distributed transactions, it is possible that the transaction is now in-doubt
(i.e., neither committed nor aborted). In this case, OCITransCommit()
attempts to retrieve the status of the transaction from the server.
The status is returned.
Parameters
srvcp (IN) - the service context handle.
errhp (IN) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
flags -see the "Comments" section above.
Related Functions
OCITransRollback()
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCITransDetach()
Name
OCI TX (transaction) DeTach
Purpose
Detaches a transaction.
Syntax
sword OCITransDetach ( OCISvcCtx    *srvcp,
                     OCIError     *errhp,
                     ub4          flags);
Comments
Detaches a global transaction from the service context handle. The transaction
currently attached to the service context handle becomes inactive at the end
of this call. The transaction may be resumed later by calling OCITransStart(),
specifying  a flags value of OCI_TRANS_RESUME.
When a transaction is detached, the value which was specified in the timeout
parameter of OCITransStart() when the transaction was started is used to
determine the amount of time the branch can remain inactive before being
deleted by the server's PMON process.

<strong>Note:</strong>
The transaction can be resumed by a different process than the one
that detached it, provided that the transaction has the same
authorization.
Parameters
srvcp (IN) - the service context handle.
errhp (IN) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
flags (IN) - you must pass a value of OCI_DEFAULT for this parameter.
Related Functions
OCITransStart()
<br /><br />

<br /><br />

<br /><br />

OCITransForget()
Name
OCI TX (transaction) ForGeT
Purpose
Causes the server to forget a heuristically completed global transaction.
Syntax
sword OCITransForget ( OCISvcCtx     *svchp,
                     OCIError      *errhp,
                     ub4           flags);
<br /><br />

Comments
<br /><br />

Forgets a heuristically completed global transaction. The server deletes the
status of the transaction from the system's pending transaction table.
The XID of the transaction to be forgotten is set as an attribute of the
transaction handle (OCI_ATTR_XID).
Parameters
srvcp (IN) - the service context handle - the transaction is rolled back.
errhp (IN) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
flags (IN) - you must pass OCI_DEFAULT for this parameter.
Related Functions
OCITransCommit(), OCITransRollback()
<br /><br />

<br /><br />

OCITransMultiPrepare()
Name
OCI Trans(action) Multi-Branch Prepare
Purpose
Prepares a transaction with multiple branches in a single call.
Syntax
sword OCITransMultiPrepare ( OCISvcCtx    *svchp,
                             ub4           numBranches,
                             OCITrans     **txns,
                             OCIError     **errhp);
<br /><br />

Comments
<br /><br />

Prepares the specified global transaction for commit.
This call is valid only for distributed transactions.
This call is an advanced performance feature intended for use only in
situations where the caller is responsible for preparing all the branches
in a transaction.
Parameters
srvcp (IN) - the service context handle.
numBranches (IN) - This is the number of branches expected. It is also the
array size for the next two parameters.
txns (IN) - This is the array of transaction handles for the branches to
prepare. They should all have the OCI_ATTR_XID set. The global transaction
ID should be the same.
errhp (IN) - This is the array of error handles. If OCI_SUCCESS is not
returned, then these will indicate which branches received which errors.
Related Functions
OCITransPrepare()
<br /><br />

<br /><br />

OCITransPrepare()
Name
OCI TX (transaction) PREpare
Purpose
Prepares a transaction for commit.
Syntax
sword OCITransPrepare ( OCISvcCtx    *svchp,
                      OCIError     *errhp,
                      ub4          flags);
<br /><br />

Comments
<br /><br />

Prepares the specified global transaction for commit.
This call is valid only for distributed transactions.
The call returns OCI_SUCCESS_WITH_INFO if the transaction has not made
any changes. The error handle will indicate that the transaction is read-only.
The flag parameter is not currently used.
Parameters
srvcp (IN) - the service context handle.
errhp (IN) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
flags (IN) - you must pass OCI_DEFAULT for this parameter.
Related Functions
OCITransCommit(), OCITransForget()
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCITransRollback()
Name
OCI TX (transaction) RoLlback
Purpose
Rolls back the current transaction.
Syntax
sword OCITransRollback ( dvoid        *svchp,
                       OCIError     *errhp,
                       ub4          flags );
Comments
The current transaction- defined as the set of statements executed since the
last OCITransCommit() or since OCISessionBegin()-is rolled back.
If the application is running under object mode then the modified or updated
objects in the object cache for this transaction are also rolled back.
An error is returned if an attempt is made to roll back a global transaction
that is not currently active.
Parameters
svchp (IN) - a service context handle. The transaction currently set in the
service context handle is rolled back.
errhp -(IN) - an error handle which can be passed to OCIErrorGet() for
diagnostic information in the event of an error.
flags - you must pass a value of OCI_DEFAULT for this parameter.
Related Functions
OCITransCommit()
<br /><br />

<br /><br />

<br /><br />

<br /><br />

OCITransStart()
Name
OCI TX (transaction) STart
Purpose
Sets the beginning of a transaction.
Syntax
sword OCITransStart ( OCISvcCtx    *svchp,
                    OCIError     *errhp,
                    uword        timeout,
                    ub4          flags);
<br /><br />

Comments
This function sets the beginning of a global or serializable transaction. The
transaction context currently associated with the service context handle is
initialized at the end of the call if the flags parameter specifies that a new
transaction should be started.
The XID of the transaction is set as an attribute of the transaction handle
(OCI_ATTR_XID)
Parameters
svchp (IN/OUT) - the service context handle. The transaction context in the
service context handle is initialized at the end of the call if the flag
specified a new transaction to be started.
errhp (IN/OUT) - The OCI error handle. If there is an error, it is recorded in
err and this function returns OCI_ERROR. Diagnostic information can be
obtained by calling OCIErrorGet().
timeout (IN) - the time, in seconds, to wait for a transaction to become
available for resumption when OCI_TRANS_RESUME is specified. When
OCI_TRANS_NEW is specified, this value is stored and may be used later by
OCITransDetach().
flags (IN) - specifies whether a new transaction is being started or an
existing transaction is being resumed. Also specifies serializiability or
read-only status. More than a single value can be specified. By default,
a read/write transaction is started. The flag values are:
OCI_TRANS_NEW - starts a new transaction branch. By default starts a
tightly coupled and migratable branch.
OCI_TRANS_TIGHT - explicitly specifies a tightly coupled branch
OCI_TRANS_LOOSE - specifies a loosely coupled branch
OCI_TRANS_RESUME - resumes an existing transaction branch.
OCI_TRANS_READONLY - start a readonly transaction
OCI_TRANS_SERIALIZABLE - start a serializable transaction
Related Functions
OCITransDetach()
<br /><br />

<br /><br />

<br /><br />

 

</p>
</p>
<dt><span class="big">alias <span class="underline">OCICallbackOutBind</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">alias <span class="underline">OCICallbackDefine</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">alias <span class="underline">OCIUserCallback</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">alias <span class="underline">OCIEnvCallbackType</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">alias <span class="underline">OCICallbackLobRead</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">alias <span class="underline">OCICallbackLobWrite</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">alias <span class="underline">OCICallbackLobRead2</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">alias <span class="underline">OCICallbackLobWrite2</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">alias <span class="underline">OCICallbackLobArrayRead</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">alias <span class="underline">OCICallbackLobArrayWrite</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">alias <span class="underline">OCICallbackAQEnq</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">alias <span class="underline">OCICallbackAQDeq</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">alias <span class="underline">OCICallbackFailover</span>;
</span></dt>
<dd><p>Failover callback structure.
 
</p>

</dd>
<dt><span class="big">struct <span class="underline">OCIFocbkStruct</span>;
</span></dt>
<dd><br /><br />
<dl></dl>
</dd>
<dt><span class="big">alias <span class="underline">OCIEventCallback</span>;
</span></dt>
<dd><p>HA callback structure.
 
</p>

</dd>
<dt><span class="big">int <span class="underline">OCIInitialize</span>(uint <em>mode</em>, void* <em>ctxp</em>, void*(* <em>malocfp</em>)(void* <em>ctxp</em>, uint size), void*(* <em>ralocfp</em>)(void* <em>ctxp</em>, void* memptr, uint newsize), void(* <em>mfreefp</em>)(void* <em>ctxp</em>, void* memptr));
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCITerminate</span>(uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIEnvCreate</span>(OCIEnv ** <em>envp</em>, uint <em>mode</em>, void* <em>ctxp</em>, void*(* <em>malocfp</em>)(void* <em>ctxp</em>, uint size), void*(* <em>ralocfp</em>)(void* <em>ctxp</em>, void* memptr, uint newsize), void(* <em>mfreefp</em>)(void* <em>ctxp</em>, void* memptr), uint <em>xtramem_sz</em>, void** <em>usrmempp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIEnvNlsCreate</span>(OCIEnv ** <em>envp</em>, uint <em>mode</em>, void* <em>ctxp</em>, void*(* <em>malocfp</em>)(void* <em>ctxp</em>, uint size), void*(* <em>ralocfp</em>)(void* <em>ctxp</em>, void* memptr, uint newsize), void(* <em>mfreefp</em>)(void* <em>ctxp</em>, void* memptr), uint <em>xtramem_sz</em>, void** <em>usrmempp</em>, ushort <em>charset</em>, ushort <em>ncharset</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFEnvCreate</span>(OCIEnv ** <em>envp</em>, uint <em>mode</em>, void* <em>ctxp</em>, void*(* <em>malocfp</em>)(void* <em>ctxp</em>, uint size), void*(* <em>ralocfp</em>)(void* <em>ctxp</em>, void* memptr, uint newsize), void(* <em>mfreefp</em>)(void* <em>ctxp</em>, void* memptr), uint <em>xtramem_sz</em>, void** <em>usrmempp</em>, void* <em>fupg</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIHandleAlloc</span>(void* <em>parenth</em>, void** <em>hndlpp</em>, uint <em>type</em>, uint <em>xtramem_sz</em>, void** <em>usrmempp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIHandleFree</span>(void* <em>hndlp</em>, uint <em>type</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDescriptorAlloc</span>(void* <em>parenth</em>, void** <em>descpp</em>, uint <em>type</em>, uint <em>xtramem_sz</em>, void** <em>usrmempp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDescriptorFree</span>(void* <em>descp</em>, uint <em>type</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIEnvInit</span>(OCIEnv ** <em>envp</em>, uint <em>mode</em>, uint <em>xtramem_sz</em>, void** <em>usrmempp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIServerAttach</span>(OCIServer * <em>srvhp</em>, OCIError * <em>errhp</em>, char* <em>dblink</em>, int <em>dblink_len</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIServerDetach</span>(OCIServer * <em>srvhp</em>, OCIError * <em>errhp</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISessionBegin</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCISession * <em>usrhp</em>, uint <em>credt</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISessionEnd</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCISession * <em>usrhp</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILogon</span>(OCIEnv * <em>envhp</em>, OCIError * <em>errhp</em>, OCISvcCtx ** <em>svchp</em>, char* <em>username</em>, uint <em>uname_len</em>, char* <em>password</em>, uint <em>passwd_len</em>, char* <em>dbname</em>, uint <em>dbname_len</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILogon2</span>(OCIEnv * <em>envhp</em>, OCIError * <em>errhp</em>, OCISvcCtx ** <em>svchp</em>, char* <em>username</em>, uint <em>uname_len</em>, char* <em>password</em>, uint <em>passwd_len</em>, char* <em>dbname</em>, uint <em>dbname_len</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILogoff</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPasswordChange</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, char* <em>user_name</em>, uint <em>usernm_len</em>, char* <em>opasswd</em>, uint <em>opasswd_len</em>, char* <em>npasswd</em>, uint <em>npasswd_len</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIStmtPrepare</span>(OCIStmt * <em>stmtp</em>, OCIError * <em>errhp</em>, char* <em>stmt</em>, uint <em>stmt_len</em>, uint <em>language</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIStmtPrepare2</span>(OCISvcCtx * <em>svchp</em>, OCIStmt ** <em>stmtp</em>, OCIError * <em>errhp</em>, char* <em>stmt</em>, uint <em>stmt_len</em>, char* <em>key</em>, uint <em>key_len</em>, uint <em>language</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIStmtRelease</span>(OCIStmt * <em>stmtp</em>, OCIError * <em>errhp</em>, char* <em>key</em>, uint <em>key_len</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIBindByPos</span>(OCIStmt * <em>stmtp</em>, OCIBind ** <em>bindp</em>, OCIError * <em>errhp</em>, uint <em>position</em>, void* <em>valuep</em>, int <em>value_sz</em>, ushort <em>dty</em>, void* <em>indp</em>, ushort* <em>alenp</em>, ushort* <em>rcodep</em>, uint <em>maxarr_len</em>, uint* <em>curelep</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIBindByName</span>(OCIStmt * <em>stmtp</em>, OCIBind ** <em>bindp</em>, OCIError * <em>errhp</em>, char* <em>placeholder</em>, int <em>placeh_len</em>, void* <em>valuep</em>, int <em>value_sz</em>, ushort <em>dty</em>, void* <em>indp</em>, ushort* <em>alenp</em>, ushort* <em>rcodep</em>, uint <em>maxarr_len</em>, uint* <em>curelep</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIBindObject</span>(OCIBind * <em>bindp</em>, OCIError * <em>errhp</em>, OCIType * <em>type</em>, void** <em>pgvpp</em>, uint* <em>pvszsp</em>, void** <em>indpp</em>, uint* <em>indszp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIBindDynamic</span>(OCIBind * <em>bindp</em>, OCIError * <em>errhp</em>, void* <em>ictxp</em>, int(* <em>icbfp</em>)(void* <em>ictxp</em>, OCIBind * <em>bindp</em>, uint iter, uint index, void** bufpp, uint* alenp, ubyte* piecep, void** indp), void* <em>octxp</em>, int(* <em>ocbfp</em>)(void* <em>octxp</em>, OCIBind * <em>bindp</em>, uint iter, uint index, void** bufpp, uint** alenp, ubyte* piecep, void** indp, ushort** rcodep));
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIBindArrayOfStruct</span>(OCIBind * <em>bindp</em>, OCIError * <em>errhp</em>, uint <em>pvskip</em>, uint <em>indskip</em>, uint <em>alskip</em>, uint <em>rcskip</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIStmtGetPieceInfo</span>(OCIStmt * <em>stmtp</em>, OCIError * <em>errhp</em>, void** <em>hndlpp</em>, uint* <em>typep</em>, ubyte* <em>in_outp</em>, uint* <em>iterp</em>, uint* <em>idxp</em>, ubyte* <em>piecep</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIStmtSetPieceInfo</span>(void* <em>hndlp</em>, uint <em>type</em>, OCIError * <em>errhp</em>, void* <em>bufp</em>, uint* <em>alenp</em>, ubyte <em>piece</em>, void* <em>indp</em>, ushort* <em>rcodep</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIStmtExecute</span>(OCISvcCtx * <em>svchp</em>, OCIStmt * <em>stmtp</em>, OCIError * <em>errhp</em>, uint <em>iters</em>, uint <em>rowoff</em>, OCISnapshot * <em>snap_in</em>, OCISnapshot * <em>snap_out</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDefineByPos</span>(OCIStmt * <em>stmtp</em>, OCIDefine ** <em>defnp</em>, OCIError * <em>errhp</em>, uint <em>position</em>, void* <em>valuep</em>, int <em>value_sz</em>, ushort <em>dty</em>, void* <em>indp</em>, ushort* <em>rlenp</em>, ushort* <em>rcodep</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDefineObject</span>(OCIDefine * <em>defnp</em>, OCIError * <em>errhp</em>, OCIType * <em>type</em>, void** <em>pgvpp</em>, uint* <em>pvszsp</em>, void** <em>indpp</em>, uint* <em>indszp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDefineDynamic</span>(OCIDefine * <em>defnp</em>, OCIError * <em>errhp</em>, void* <em>octxp</em>, int(* <em>ocbfp</em>)(void* <em>octxp</em>, OCIDefine * <em>defnp</em>, uint iter, void** bufpp, uint** alenp, ubyte* piecep, void** indp, ushort** rcodep));
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIRowidToChar</span>(OCIRowid * <em>rowidDesc</em>, char* <em>outbfp</em>, ushort* <em>outbflp</em>, OCIError * <em>errhp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDefineArrayOfStruct</span>(OCIDefine * <em>defnp</em>, OCIError * <em>errhp</em>, uint <em>pvskip</em>, uint <em>indskip</em>, uint <em>rlskip</em>, uint <em>rcskip</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIStmtFetch</span>(OCIStmt * <em>stmtp</em>, OCIError * <em>errhp</em>, uint <em>nrows</em>, ushort <em>orientation</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIStmtFetch2</span>(OCIStmt * <em>stmtp</em>, OCIError * <em>errhp</em>, uint <em>nrows</em>, ushort <em>orientation</em>, int <em>scrollOffset</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIStmtGetBindInfo</span>(OCIStmt * <em>stmtp</em>, OCIError * <em>errhp</em>, uint <em>size</em>, uint <em>startloc</em>, int* <em>found</em>, char*[] <em>bvnp</em>, ubyte[] <em>bvnl</em>, char*[] <em>invp</em>, ubyte[] <em>inpl</em>, ubyte[] <em>dupl</em>, OCIBind ** <em>hndl</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDescribeAny</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, void* <em>objptr</em>, uint <em>objnm_len</em>, ubyte <em>objptr_typ</em>, ubyte <em>info_level</em>, ubyte <em>objtyp</em>, OCIDescribe * <em>dschp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIParamGet</span>(void* <em>hndlp</em>, uint <em>htype</em>, OCIError * <em>errhp</em>, void** <em>parmdpp</em>, uint <em>pos</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIParamSet</span>(void* <em>hdlp</em>, uint <em>htyp</em>, OCIError * <em>errhp</em>, void* <em>dscp</em>, uint <em>dtyp</em>, uint <em>pos</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCITransStart</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, uint <em>timeout</em>, uint <em>flags</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCITransDetach</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, uint <em>flags</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCITransCommit</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, uint <em>flags</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCITransRollback</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, uint <em>flags</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCITransPrepare</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, uint <em>flags</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCITransMultiPrepare</span>(OCISvcCtx * <em>svchp</em>, uint <em>numBranches</em>, OCITrans ** <em>txns</em>, OCIError ** <em>errhp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCITransForget</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, uint <em>flags</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIErrorGet</span>(void* <em>hndlp</em>, uint <em>recordno</em>, char* <em>sqlstate</em>, int* <em>errcodep</em>, char* <em>bufp</em>, uint <em>bufsiz</em>, uint <em>type</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobAppend</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>dst_locp</em>, OCILobLocator * <em>src_locp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobAssign</span>(OCIEnv * <em>envhp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>src_locp</em>, OCILobLocator ** <em>dst_locpp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobCharSetForm</span>(OCIEnv * <em>envhp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>locp</em>, ubyte* <em>csfrm</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobCharSetId</span>(OCIEnv * <em>envhp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>locp</em>, ushort* <em>csid</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobCopy</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>dst_locp</em>, OCILobLocator * <em>src_locp</em>, uint <em>amount</em>, uint <em>dst_offset</em>, uint <em>src_offset</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobCreateTemporary</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>locp</em>, ushort <em>csid</em>, ubyte <em>csfrm</em>, ubyte <em>lobtype</em>, int <em>cache</em>, OCIDuration <em>duration</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobClose</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>locp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobDisableBuffering</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>locp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobEnableBuffering</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>locp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobErase</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>locp</em>, uint* <em>amount</em>, uint <em>offset</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobFileClose</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>filep</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobFileCloseAll</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobFileExists</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>filep</em>, int* <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobFileGetName</span>(OCIEnv * <em>envhp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>filep</em>, char* <em>dir_alias</em>, ushort* <em>d_length</em>, char* <em>filename</em>, ushort* <em>f_length</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobFileIsOpen</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>filep</em>, int* <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobFileOpen</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>filep</em>, ubyte <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobFileSetName</span>(OCIEnv * <em>envhp</em>, OCIError * <em>errhp</em>, OCILobLocator ** <em>filepp</em>, char* <em>dir_alias</em>, ushort <em>d_length</em>, char* <em>filename</em>, ushort <em>f_length</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobFlushBuffer</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>locp</em>, uint <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobFreeTemporary</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>locp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobGetChunkSize</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>locp</em>, uint* <em>chunksizep</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobGetLength</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>locp</em>, uint* <em>lenp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobIsEqual</span>(OCIEnv * <em>envhp</em>, OCILobLocator * <em>x</em>, OCILobLocator * <em>y</em>, int* <em>is_equal</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobIsOpen</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>locp</em>, int* <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobIsTemporary</span>(OCIEnv * <em>envp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>locp</em>, int* <em>is_temporary</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobLoadFromFile</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>dst_locp</em>, OCILobLocator * <em>src_filep</em>, uint <em>amount</em>, uint <em>dst_offset</em>, uint <em>src_offset</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobLocatorAssign</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>src_locp</em>, OCILobLocator ** <em>dst_locpp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobLocatorIsInit</span>(OCIEnv * <em>envhp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>locp</em>, int* <em>is_initialized</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobOpen</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>locp</em>, ubyte <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobRead</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>locp</em>, uint* <em>amtp</em>, uint <em>offset</em>, void* <em>bufp</em>, uint <em>bufl</em>, void* <em>ctxp</em>, int(* <em>cbfp</em>)(void* <em>ctxp</em>, void* <em>bufp</em>, uint len, ubyte piece), ushort <em>csid</em>, ubyte <em>csfrm</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobTrim</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>locp</em>, uint <em>newlen</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobWrite</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>locp</em>, uint* <em>amtp</em>, uint <em>offset</em>, void* <em>bufp</em>, uint <em>buflen</em>, ubyte <em>piece</em>, void* <em>ctxp</em>, int(* <em>cbfp</em>)(void* <em>ctxp</em>, void* <em>bufp</em>, uint* lenp, ubyte* <em>piece</em>), ushort <em>csid</em>, ubyte <em>csfrm</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobWriteAppend</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>lobp</em>, uint* <em>amtp</em>, void* <em>bufp</em>, uint <em>bufl</em>, ubyte <em>piece</em>, void* <em>ctxp</em>, int(* <em>cbfp</em>)(void* <em>ctxp</em>, void* <em>bufp</em>, uint* lenp, ubyte* <em>piece</em>), ushort <em>csid</em>, ubyte <em>csfrm</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIBreak</span>(void* <em>hndlp</em>, OCIError * <em>errhp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIReset</span>(void* <em>hndlp</em>, OCIError * <em>errhp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIServerVersion</span>(void* <em>hndlp</em>, OCIError * <em>errhp</em>, char* <em>bufp</em>, uint <em>bufsz</em>, ubyte <em>hndltype</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIServerRelease</span>(void* <em>hndlp</em>, OCIError * <em>errhp</em>, char* <em>bufp</em>, uint <em>bufsz</em>, ubyte <em>hndltype</em>, uint* <em>s_version</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIAttrGet</span>(void* <em>trgthndlp</em>, uint <em>trghndltyp</em>, void* <em>attributep</em>, uint* <em>sizep</em>, uint <em>attrtype</em>, OCIError * <em>errhp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIAttrSet</span>(void* <em>trgthndlp</em>, uint <em>trghndltyp</em>, void* <em>attributep</em>, uint <em>size</em>, uint <em>attrtype</em>, OCIError * <em>errhp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISvcCtxToLda</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, cda_def * <em>ldap</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILdaToSvcCtx</span>(OCISvcCtx ** <em>svchpp</em>, OCIError * <em>errhp</em>, cda_def * <em>ldap</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIResultSetToStmt</span>(OCIResult * <em>rsetdp</em>, OCIError * <em>errhp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFileClose</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIFileObject * <em>filep</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIUserCallbackRegister</span>(void* <em>hndlp</em>, uint <em>type</em>, void* <em>ehndlp</em>, int(* <em>callback</em>)(void* <em>ctxp</em>, void* <em>hndlp</em>, uint <em>type</em>, uint <em>fcode</em>, uint <em>when</em>, int returnCode, int* errnop, void* arglist), void* <em>ctxp</em>, uint <em>fcode</em>, uint <em>when</em>, OCIUcb * <em>ucbDesc</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIUserCallbackGet</span>(void* <em>hndlp</em>, uint <em>type</em>, void* <em>ehndlp</em>, uint <em>fcode</em>, uint <em>when</em>, int(** <em>callbackp</em>)(void* ctxp, void* <em>hndlp</em>, uint <em>type</em>, uint <em>fcode</em>, uint <em>when</em>, int returnCode, int* errnop, void* arglist), void** <em>ctxpp</em>, OCIUcb * <em>ucbDesc</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISharedLibInit</span>(void* <em>metaCtx</em>, void* <em>libCtx</em>, uint <em>argfmt</em>, int <em>argc</em>, void** <em>argv</em>, int(* <em>envCallback</em>)(OCIEnv * env, uint mode, uint xtramem_sz, void* usrmemp, OCIUcb * ucbDesc));
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFileExists</span>(void* <em>hndl</em>, OCIError * <em>err</em>, char* <em>filename</em>, char* <em>path</em>, ubyte* <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFileFlush</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIFileObject * <em>filep</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFileGetLength</span>(void* <em>hndl</em>, OCIError * <em>err</em>, char* <em>filename</em>, char* <em>path</em>, int* <em>lenp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFileInit</span>(void* <em>hndl</em>, OCIError * <em>err</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFileOpen</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIFileObject ** <em>filep</em>, char* <em>filename</em>, char* <em>path</em>, uint <em>mode</em>, uint <em>create</em>, uint <em>type</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFileRead</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIFileObject * <em>filep</em>, void* <em>bufp</em>, uint <em>bufl</em>, uint* <em>bytesread</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFileSeek</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIFileObject * <em>filep</em>, uint <em>origin</em>, int <em>offset</em>, byte <em>dir</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFileTerm</span>(void* <em>hndl</em>, OCIError * <em>err</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFileWrite</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIFileObject * <em>filep</em>, void* <em>bufp</em>, uint <em>buflen</em>, uint* <em>byteswritten</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobCopy2</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>dst_locp</em>, OCILobLocator * <em>src_locp</em>, ulong <em>amount</em>, ulong <em>dst_offset</em>, ulong <em>src_offset</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobErase2</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>locp</em>, ulong* <em>amount</em>, ulong <em>offset</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobGetLength2</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>locp</em>, ulong* <em>lenp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobLoadFromFile2</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>dst_locp</em>, OCILobLocator * <em>src_filep</em>, ulong <em>amount</em>, ulong <em>dst_offset</em>, ulong <em>src_offset</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobRead2</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>locp</em>, ulong* <em>byte_amtp</em>, ulong* <em>char_amtp</em>, ulong <em>offset</em>, void* <em>bufp</em>, ulong <em>bufl</em>, ubyte <em>piece</em>, void* <em>ctxp</em>, int(* <em>cbfp</em>)(void* <em>ctxp</em>, void* <em>bufp</em>, ulong len, ubyte <em>piece</em>, void** changed_bufpp, ulong* changed_lenp), ushort <em>csid</em>, ubyte <em>csfrm</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobArrayRead</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, uint* <em>array_iter</em>, OCILobLocator ** <em>lobp_arr</em>, ulong* <em>byte_amt_arr</em>, ulong* <em>char_amt_arr</em>, ulong* <em>offset_arr</em>, void** <em>bufp_arr</em>, ulong* <em>bufl_arr</em>, ubyte <em>piece</em>, void* <em>ctxp</em>, int(* <em>cbfp</em>)(void* <em>ctxp</em>, uint <em>array_iter</em>, void* bufp, ulong len, ubyte <em>piece</em>, void** changed_bufpp, ulong* changed_lenp), ushort <em>csid</em>, ubyte <em>csfrm</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobTrim2</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>locp</em>, ulong <em>newlen</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobWrite2</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>locp</em>, ulong* <em>byte_amtp</em>, ulong* <em>char_amtp</em>, ulong <em>offset</em>, void* <em>bufp</em>, ulong <em>buflen</em>, ubyte <em>piece</em>, void* <em>ctxp</em>, int(* <em>cbfp</em>)(void* <em>ctxp</em>, void* <em>bufp</em>, ulong* lenp, ubyte* <em>piece</em>, void** changed_bufpp, ulong* changed_lenp), ushort <em>csid</em>, ubyte <em>csfrm</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobArrayWrite</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, uint* <em>array_iter</em>, OCILobLocator ** <em>lobp_arr</em>, ulong* <em>byte_amt_arr</em>, ulong* <em>char_amt_arr</em>, ulong* <em>offset_arr</em>, void** <em>bufp_arr</em>, ulong* <em>bufl_arr</em>, ubyte <em>piece</em>, void* <em>ctxp</em>, int(* <em>cbfp</em>)(void* <em>ctxp</em>, uint <em>array_iter</em>, void* bufp, ulong* lenp, ubyte* <em>piece</em>, void** changed_bufpp, ulong* changed_lenp), ushort <em>csid</em>, ubyte <em>csfrm</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobWriteAppend2</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>lobp</em>, ulong* <em>byte_amtp</em>, ulong* <em>char_amtp</em>, void* <em>bufp</em>, ulong <em>bufl</em>, ubyte <em>piece</em>, void* <em>ctxp</em>, int(* <em>cbfp</em>)(void* <em>ctxp</em>, void* <em>bufp</em>, ulong* lenp, ubyte* <em>piece</em>, void** changed_bufpp, ulong* changed_lenp), ushort <em>csid</em>, ubyte <em>csfrm</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCILobGetStorageLimit</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCILobLocator * <em>lobp</em>, ulong* <em>limitp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityInitialize</span>(OCISecurity * <em>sechandle</em>, OCIError * <em>error_handle</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityTerminate</span>(OCISecurity * <em>sechandle</em>, OCIError * <em>error_handle</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityOpenWallet</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, uint <em>wrllen</em>, char* <em>wallet_resource_locator</em>, uint <em>pwdlen</em>, char* <em>password</em>, nzttWallet * <em>wallet</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityCloseWallet</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttWallet * <em>wallet</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityCreateWallet</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, uint <em>wrllen</em>, char* <em>wallet_resource_locator</em>, uint <em>pwdlen</em>, char* <em>password</em>, nzttWallet * <em>wallet</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityDestroyWallet</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, uint <em>wrllen</em>, char* <em>wallet_resource_locator</em>, uint <em>pwdlen</em>, char* <em>password</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityStorePersona</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona ** <em>persona</em>, nzttWallet * <em>wallet</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityOpenPersona</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityClosePersona</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityRemovePersona</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona ** <em>persona</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityCreatePersona</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttIdentType <em>identity_type</em>, nzttCipherType <em>cipher_type</em>, nzttPersonaDesc * <em>desc</em>, nzttPersona ** <em>persona</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecuritySetProtection</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>, nzttcef <em>crypto_engine_function</em>, nztttdufmt <em>data_unit_format</em>, nzttProtInfo * <em>protection_info</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityGetProtection</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>, nzttcef <em>crypto_engine_function</em>, nztttdufmt* <em>data_unit_format_ptr</em>, nzttProtInfo * <em>protection_info</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityRemoveIdentity</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttIdentity ** <em>identity_ptr</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityCreateIdentity</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttIdentType <em>type</em>, nzttIdentityDesc * <em>desc</em>, nzttIdentity ** <em>identity_ptr</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityAbortIdentity</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttIdentity ** <em>identity_ptr</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityFreeIdentity</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttIdentity ** <em>identity_ptr</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityStoreTrustedIdentity</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttIdentity ** <em>identity_ptr</em>, nzttPersona * <em>persona</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecuritySign</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>, nzttces <em>signature_state</em>, uint <em>input_length</em>, ubyte* <em>input</em>, nzttBufferBlock * <em>buffer_block</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecuritySignExpansion</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>, uint <em>inputlen</em>, uint* <em>signature_length</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityVerify</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>, nzttces <em>signature_state</em>, uint <em>siglen</em>, ubyte* <em>signature</em>, nzttBufferBlock * <em>extracted_message</em>, int* <em>verified</em>, int* <em>validated</em>, nzttIdentity ** <em>signing_party_identity</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityValidate</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>, nzttIdentity * <em>identity</em>, int* <em>validated</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecuritySignDetached</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>, nzttces <em>signature_state</em>, uint <em>input_length</em>, ubyte* <em>input</em>, nzttBufferBlock * <em>signature</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecuritySignDetExpansion</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>, uint <em>input_length</em>, uint* <em>required_buffer_length</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityVerifyDetached</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>, nzttces <em>signature_state</em>, uint <em>data_length</em>, ubyte* <em>data</em>, uint <em>siglen</em>, ubyte* <em>signature</em>, int* <em>verified</em>, int* <em>validated</em>, nzttIdentity ** <em>signing_party_identity</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurity_PKEncrypt</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>, uint <em>number_of_recipients</em>, nzttIdentity * <em>recipient_list</em>, nzttces <em>encryption_state</em>, uint <em>input_length</em>, ubyte* <em>input</em>, nzttBufferBlock * <em>encrypted_data</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityPKEncryptExpansion</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>, uint <em>number_recipients</em>, uint <em>input_length</em>, uint* <em>buffer_length_required</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityPKDecrypt</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>, nzttces <em>encryption_state</em>, uint <em>input_length</em>, ubyte* <em>input</em>, nzttBufferBlock * <em>encrypted_data</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityEncrypt</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>, nzttces <em>encryption_state</em>, uint <em>input_length</em>, ubyte* <em>input</em>, nzttBufferBlock * <em>encrypted_data</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityEncryptExpansion</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>, uint <em>input_length</em>, uint* <em>encrypted_data_length</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityDecrypt</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>, nzttces <em>decryption_state</em>, uint <em>input_length</em>, ubyte* <em>input</em>, nzttBufferBlock * <em>decrypted_data</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityEnvelope</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>, uint <em>number_of_recipients</em>, nzttIdentity * <em>identity</em>, nzttces <em>encryption_state</em>, uint <em>input_length</em>, ubyte* <em>input</em>, nzttBufferBlock * <em>enveloped_data</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityDeEnvelope</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>, nzttces <em>decryption_state</em>, uint <em>input_length</em>, ubyte* <em>input</em>, nzttBufferBlock * <em>output_message</em>, int* <em>verified</em>, int* <em>validated</em>, nzttIdentity ** <em>sender_identity</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityKeyedHash</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>, nzttces <em>hash_state</em>, uint <em>input_length</em>, ubyte* <em>input</em>, nzttBufferBlock * <em>keyed_hash</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityKeyedHashExpansion</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>, uint <em>input_length</em>, uint* <em>required_buffer_length</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityHash</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>, nzttces <em>hash_state</em>, uint <em>input</em>, ubyte* <em>input_length</em>, nzttBufferBlock * <em>hash</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityHashExpansion</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>, uint <em>input_length</em>, uint* <em>required_buffer_length</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecuritySeedRandom</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>, uint <em>seed_length</em>, ubyte* <em>seed</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityRandomBytes</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>, uint <em>number_of_bytes_desired</em>, nzttBufferBlock * <em>random_bytes</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityRandomNumber</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttPersona * <em>persona</em>, uint* <em>random_number_ptr</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityInitBlock</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttBufferBlock * <em>buffer_block</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityReuseBlock</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttBufferBlock * <em>buffer_block</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityPurgeBlock</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, nzttBufferBlock * <em>buffer_block</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecuritySetBlock</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, uint <em>flags_to_set</em>, uint <em>buffer_length</em>, uint <em>used_buffer_length</em>, ubyte* <em>buffer</em>, nzttBufferBlock * <em>buffer_block</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISecurityGetIdentity</span>(OCISecurity * <em>osshandle</em>, OCIError * <em>error_handle</em>, uint <em>namelen</em>, char* <em>distinguished_name</em>, nzttIdentity ** <em>identity</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIAQEnq</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, char* <em>queue_name</em>, OCIAQEnqOptions * <em>enqopt</em>, OCIAQMsgProperties * <em>msgprop</em>, OCIType * <em>payload_tdo</em>, void** <em>payload</em>, void** <em>payload_ind</em>, OCIRaw ** <em>msgid</em>, uint <em>flags</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIAQDeq</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, char* <em>queue_name</em>, OCIAQDeqOptions * <em>deqopt</em>, OCIAQMsgProperties * <em>msgprop</em>, OCIType * <em>payload_tdo</em>, void** <em>payload</em>, void** <em>payload_ind</em>, OCIRaw ** <em>msgid</em>, uint <em>flags</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIAQEnqArray</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, char* <em>queue_name</em>, OCIAQEnqOptions * <em>enqopt</em>, uint* <em>iters</em>, OCIAQMsgProperties ** <em>msgprop</em>, OCIType * <em>payload_tdo</em>, void** <em>payload</em>, void** <em>payload_ind</em>, OCIRaw ** <em>msgid</em>, void* <em>ctxp</em>, int(* <em>enqcbfp</em>)(void* <em>ctxp</em>, void** <em>payload</em>, void** <em>payload_ind</em>), uint <em>flags</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIAQDeqArray</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, char* <em>queue_name</em>, OCIAQDeqOptions * <em>deqopt</em>, uint* <em>iters</em>, OCIAQMsgProperties ** <em>msgprop</em>, OCIType * <em>payload_tdo</em>, void** <em>payload</em>, void** <em>payload_ind</em>, OCIRaw ** <em>msgid</em>, void* <em>ctxp</em>, int(* <em>deqcbfp</em>)(void* <em>ctxp</em>, void** <em>payload</em>, void** <em>payload_ind</em>), uint <em>flags</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIAQListen</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCIAQAgent ** <em>agent_list</em>, uint <em>num_agents</em>, int <em>wait</em>, OCIAQAgent ** <em>agent</em>, uint <em>flags</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIAQListen2</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCIAQAgent ** <em>agent_list</em>, uint <em>num_agents</em>, OCIAQListenOpts * <em>lopts</em>, OCIAQAgent ** <em>agent</em>, OCIAQLisMsgProps * <em>lmops</em>, uint <em>flags</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIExtractInit</span>(void* <em>hndl</em>, OCIError * <em>err</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIExtractTerm</span>(void* <em>hndl</em>, OCIError * <em>err</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIExtractReset</span>(void* <em>hndl</em>, OCIError * <em>err</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIExtractSetNumKeys</span>(void* <em>hndl</em>, OCIError * <em>err</em>, uint <em>numkeys</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIExtractSetKey</span>(void* <em>hndl</em>, OCIError * <em>err</em>, char* <em>name</em>, ubyte <em>type</em>, uint <em>flag</em>, void* <em>defval</em>, int* <em>intrange</em>, char** <em>strlist</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIExtractFromFile</span>(void* <em>hndl</em>, OCIError * <em>err</em>, uint <em>flag</em>, char* <em>filename</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIExtractFromStr</span>(void* <em>hndl</em>, OCIError * <em>err</em>, uint <em>flag</em>, char* <em>input</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIExtractToInt</span>(void* <em>hndl</em>, OCIError * <em>err</em>, char* <em>keyname</em>, uint <em>valno</em>, int* <em>retval</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIExtractToBool</span>(void* <em>hndl</em>, OCIError * <em>err</em>, char* <em>keyname</em>, uint <em>valno</em>, ubyte* <em>retval</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIExtractToStr</span>(void* <em>hndl</em>, OCIError * <em>err</em>, char* <em>keyname</em>, uint <em>valno</em>, char* <em>retval</em>, uint <em>buflen</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIExtractToOCINum</span>(void* <em>hndl</em>, OCIError * <em>err</em>, char* <em>keyname</em>, uint <em>valno</em>, OCINumber * <em>retval</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIExtractToList</span>(void* <em>hndl</em>, OCIError * <em>err</em>, uint* <em>numkeys</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIExtractFromList</span>(void* <em>hndl</em>, OCIError * <em>err</em>, uint <em>index</em>, char** <em>name</em>, ubyte* <em>type</em>, uint* <em>numvals</em>, void*** <em>values</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIMemoryAlloc</span>(void* <em>hdl</em>, OCIError * <em>err</em>, void** <em>mem</em>, OCIDuration <em>dur</em>, uint <em>size</em>, uint <em>flags</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIMemoryResize</span>(void* <em>hdl</em>, OCIError * <em>err</em>, void** <em>mem</em>, uint <em>newsize</em>, uint <em>flags</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIMemoryFree</span>(void* <em>hdl</em>, OCIError * <em>err</em>, void* <em>mem</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIContextSetValue</span>(void* <em>hdl</em>, OCIError * <em>err</em>, OCIDuration <em>duration</em>, ubyte* <em>key</em>, ubyte <em>keylen</em>, void* <em>ctx_value</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIContextGetValue</span>(void* <em>hdl</em>, OCIError * <em>err</em>, ubyte* <em>key</em>, ubyte <em>keylen</em>, void** <em>ctx_value</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIContextClearValue</span>(void* <em>hdl</em>, OCIError * <em>err</em>, ubyte* <em>key</em>, ubyte <em>keylen</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIContextGenerateKey</span>(void* <em>hdl</em>, OCIError * <em>err</em>, uint* <em>key</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIMemorySetCurrentIDs</span>(void* <em>hdl</em>, OCIError * <em>err</em>, uint <em>curr_session_id</em>, uint <em>curr_trans_id</em>, uint <em>curr_stmt_id</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerTdsCtxInit</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerTdsCtx ** <em>tdsc</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerTdsCtxFree</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerTdsCtx * <em>tdsc</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerTdsInit</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerTdsCtx * <em>tdsc</em>, OCIPicklerTds ** <em>tdsh</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerTdsFree</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerTds * <em>tdsh</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerTdsCreateElementNumber</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerTds * <em>tdsh</em>, ubyte <em>prec</em>, byte <em>scale</em>, uint* <em>elt</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerTdsCreateElementChar</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerTds * <em>tdsh</em>, ushort <em>len</em>, uint* <em>elt</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerTdsCreateElementVarchar</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerTds * <em>tdsh</em>, ushort <em>len</em>, uint* <em>elt</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerTdsCreateElementRaw</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerTds * <em>tdsh</em>, ushort <em>len</em>, uint* <em>elt</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerTdsCreateElement</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerTds * <em>tdsh</em>, ushort <em>dty</em>, uint* <em>elt</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerTdsAddAttr</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerTds * <em>tdsh</em>, uint <em>elt</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerTdsGenerate</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerTds * <em>tdsh</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerTdsGetAttr</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerTds * <em>tdsh</em>, ubyte <em>attrno</em>, ushort* <em>typ</em>, ushort* <em>len</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerFdoInit</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerFdo ** <em>fdoh</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerFdoFree</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerFdo * <em>fdoh</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerImageInit</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerFdo * <em>fdoh</em>, OCIPicklerTds * <em>tdsh</em>, OCIPicklerImage ** <em>imgh</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerImageFree</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerImage * <em>imgh</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerImageAddScalar</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerImage * <em>imgh</em>, void* <em>scalar</em>, uint <em>len</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerImageAddNullScalar</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerImage * <em>imgh</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerImageGenerate</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerImage * <em>imgh</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerImageGetScalarSize</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerImage * <em>imgh</em>, uint <em>attrno</em>, uint* <em>size</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerImageGetScalar</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerImage * <em>imgh</em>, uint <em>attrno</em>, void* <em>buf</em>, uint* <em>len</em>, short* <em>ind</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerImageCollBegin</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerImage * <em>imgh</em>, OCIPicklerTds * <em>colltdsh</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerImageCollAddScalar</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerImage * <em>imgh</em>, void* <em>scalar</em>, uint <em>buflen</em>, short <em>ind</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerImageCollEnd</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerImage * <em>imgh</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerImageCollBeginScan</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerImage * <em>imgh</em>, OCIPicklerTds * <em>coll_tdsh</em>, uint <em>attrnum</em>, uint <em>startidx</em>, short* <em>ind</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerImageCollGetScalarSize</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerTds * <em>coll_tdsh</em>, uint* <em>size</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPicklerImageCollGetScalar</span>(OCIEnv * <em>env</em>, OCIError * <em>err</em>, OCIPicklerImage * <em>imgh</em>, void* <em>buf</em>, uint* <em>buflen</em>, short* <em>ind</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIAnyDataGetType</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCIAnyData * <em>sdata</em>, ushort* <em>tc</em>, OCIType ** <em>type</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIAnyDataIsNull</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCIAnyData * <em>sdata</em>, int* <em>isnull</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIAnyDataConvert</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, ushort <em>tc</em>, OCIType * <em>type</em>, OCIDuration <em>dur</em>, void* <em>ind</em>, void* <em>data_val</em>, uint <em>len</em>, OCIAnyData ** <em>sdata</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIAnyDataBeginCreate</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, ushort <em>tc</em>, OCIType * <em>type</em>, OCIDuration <em>dur</em>, OCIAnyData ** <em>sdata</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIAnyDataDestroy</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCIAnyData * <em>sdata</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIAnyDataAttrSet</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCIAnyData * <em>sdata</em>, ushort <em>tc</em>, OCIType * <em>type</em>, void* <em>ind</em>, void* <em>attr_val</em>, uint <em>length</em>, int <em>is_any</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIAnyDataCollAddElem</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCIAnyData * <em>sdata</em>, ushort <em>tc</em>, OCIType * <em>type</em>, void* <em>ind</em>, void* <em>attr_val</em>, uint <em>length</em>, int <em>is_any</em>, int <em>last_elem</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIAnyDataEndCreate</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCIAnyData * <em>sdata</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIAnyDataAccess</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCIAnyData * <em>sdata</em>, ushort <em>tc</em>, OCIType * <em>type</em>, void* <em>ind</em>, void* <em>attr_val</em>, uint* <em>length</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIAnyDataGetCurrAttrNum</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCIAnyData * <em>sdata</em>, uint* <em>attrnum</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIAnyDataAttrGet</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCIAnyData * <em>sdata</em>, ushort <em>tc</em>, OCIType * <em>type</em>, void* <em>ind</em>, void* <em>attr_val</em>, uint* <em>length</em>, int <em>is_any</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIAnyDataCollGetElem</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCIAnyData * <em>sdata</em>, ushort <em>tc</em>, OCIType * <em>type</em>, void* <em>ind</em>, void* <em>celem_val</em>, uint* <em>length</em>, int <em>is_any</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFormatInit</span>(void* <em>hndl</em>, OCIError * <em>err</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFormatString</span>(void* <em>hndl</em>, OCIError * <em>err</em>, char* <em>buffer</em>, uint <em>bufferLength</em>, uint* <em>returnLength</em>, char* <em>formatString</em>,...);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFormatTerm</span>(void* <em>hndl</em>, OCIError * <em>err</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFormatTUb1</span>();
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFormatTUb2</span>();
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFormatTUb4</span>();
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFormatTUword</span>();
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFormatTUbig_ora</span>();
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFormatTSb1</span>();
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFormatTSb2</span>();
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFormatTSb4</span>();
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFormatTSword</span>();
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFormatTSbig_ora</span>();
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFormatTEb1</span>();
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFormatTEb2</span>();
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFormatTEb4</span>();
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFormatTEword</span>();
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFormatTChar</span>();
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFormatTText</span>();
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFormatTDouble</span>();
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFormatTDvoid</span>();
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIFormatTEnd</span>();
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCIThreadProcessInit</span>();
</span></dt>
<dd><p>DESCRIPTION
*****************************************************************************
1 Threads Interface
</p>
<p>The OCIThread package provides a number of commonly used threading
primitives for use by Oracle customers.  It offers a portable interface to
threading capabilities native to various platforms.  It does not implement
threading on platforms which do not have native threading capability.
<br /><br />

OCIThread does not provide a portable implementation of multithreaded
facilities.  It only serves as a set of portable covers for native
multithreaded facilities.  Therefore, platforms that do not have native
support for multi-threading will only be able to support a limited
implementation of OCIThread.  As a result, products that rely on all of
OCIThread's functionality will not port to all platforms.  Products that must
port to all platforms must use only a subset of OCIThread's functionality.
This issue is discussed further in later sections of this document.
<br /><br />

The OCIThread API is split into four main parts.  Each part is described
briefly here.  The following subsections describe each in greater detail.
<br /><br />

 1. Initialization and Termination Calls
<br /><br />

     These calls deal with the initialization and termination of OCIThread.
     Initialization of OCIThread initializes the OCIThread context which is
     a member of the OCI environment or session handle.  This context is
     required for other OCIThread calls.
<br /><br />

 2. Passive Threading Primitives
<br /><br />

     The passive threading primitives include primitives to manipulate mutual
     exclusion (mutex) locks, thread ID's, and thread-specific data keys.
<br /><br />

     The reason that these primitives are described as 'passive' is that while
     their specifications allow for the existence of multiple threads, they do
     not require it.  This means that it is possible for these primitives to
     be implemented according to specification in both single-threaded and
     multi-threaded environments.
<br /><br />

     As a result, OCIThread clients that use only these primitives will not
     require the existence of multiple threads in order to work correctly,
     i.e., they will be able to work in single-threaded environments without
     branching code.
<br /><br />

 3. Active Threading Primitives
<br /><br />

     Active threading primitives include primitives dealing with the creation,
     termination, and other manipulation of threads.
<br /><br />

     The reason that these primitives are described as 'active' is that they
     can only be used in <strong>true</strong> multi-threaded environments.  Their
     specifications explicitly require that it be possible to have multiple
     threads.  If you need to determine at runtime whether or not you are in a
     multi-threaded environment, call OCIThreadIsMulti() before calling an
     OCIThread active primitive.
<br /><br />

<br /><br />

1.1 Initialization &amp; Termination
==================================
<br /><br />

The types and functions described in this section are associated with the
initialization and termination of the OCIThread package.  OCIThread must
be properly initialized before any of its functionality can be used.
OCIThread's process initialization function, '<span class="underline">OCIThreadProcessInit</span>()',
must be called with care; see below.
<br /><br />

The observed behavior of the initialization and termination functions is the
same regardless of whether OCIThread is in single-threaded or multi-threaded
environment.  It is OK to call the initialization functions from both generic
and operating system specific (OSD) code.
<br /><br />

1.1.1 Types
<br /><br />

  OCIThreadContext - OCIThread Context
<ins><pre class="d_code">
    Most calls to OCIThread functions take the OCI environment or session
    handle as a parameter.  The OCIThread context <span class="blue">is</span> part of the OCI
    environment or session handle and it must be initialized by calling
    'OCIThreadInit()'.  Termination of the OCIThread context occurs by calling
    'OCIThreadTerm()'.

    The OCIThread context <span class="blue">is</span> a <span class="blue">private</span> data structure.  Clients must NEVER
    attempt to examine the contents of the context.

1.1.2  <span class="underline">OCIThreadProcessInit</span>

  <span class="underline">OCIThreadProcessInit</span> - OCIThread Process INITialization
</pre></ins>

    Description
<br /><br />

      This function should be called to perform OCIThread process
      initialization.
<br /><br />

    Prototype
<br /><br />

      void <span class="underline">OCIThreadProcessInit</span>();
<br /><br />

    Returns
<br /><br />

      Nothing.
<br /><br />

    Notes
<br /><br />

      Whether or not this function needs to be called depends on how OCI
      Thread is going to be used.
<br /><br />

 In a single-threaded application, calling this function is optional.
          If it is called at all, the first call to it must occur before calls
          to any other OCIThread functions.  Subsequent calls can be made
          without restriction; they will not have any effect.
<br /><br />

 In a multi-threaded application, this function MUST be called.  The
          first call to it MUST occur 'strictly before' any other OCIThread
          calls; i.e., no other calls to OCIThread functions (including other
          calls to this one) can be concurrent with the first call.
          Subsequent calls to this function can be made without restriction;
          they will not have any effect.
<br /><br />

<br /><br />

1.1.3 OCIThreadInit
<br /><br />

  OCIThreadInit - OCIThread INITialize
<ins><pre class="d_code">
    Description

      This initializes OCIThread context.

    Prototype

      sword OCIThreadInit(dvoid* hndl, OCIError* err);

        hndl(IN/OUT): The OCI environment or session handle.

        err(IN/OUT): The OCI error handle.  If there <span class="blue">is</span> an error and OCI_ERROR
                     <span class="blue">is</span> returned, the error <span class="blue">is</span> recorded <span class="blue">in</span> err and diagnostic
                     information can be obtained by calling OCIErrorGet().

    Returns

      OCI_SUCCESS, OCI_ERROR or OCI_INVALID_HANDLE.

    Notes

      It <span class="blue">is</span> illegal <span class="blue">for</span> OCIThread clients to <span class="blue">try</span> an examine the memory
      pointed to by the returned pointer.

      It <span class="blue">is</span> safe to make concurrent calls to 'OCIThreadInit()'.  Unlike
      'OCIThreadProcessInit()',  there <span class="blue">is</span> no need to have a first call
      that occurs before all the others.

      The first time 'OCIThreadInit()' <span class="blue">is</span> called, it initilaizes the OCI
      Thread context.  It also saves a pointer to the context <span class="blue">in</span> some system
      dependent manner.  Subsequent calls to 'OCIThreadInit()' will <span class="blue">return</span>
      the same context.

      Each call to 'OCIThreadInit()' must eventually be matched by a call to
      'OCIThreadTerm()'.

  OCIThreadTerm - OCIThread TERMinate
</pre></ins>

    Description
<br /><br />

      This should be called to release the OCIThread context.  It should be
      called exactly once for each call made to 'OCIThreadInit()'.
<br /><br />

    Prototype
<br /><br />

      sword OCIThreadTerm(dvoid* hndl, OCIError* err);
<br /><br />

        hndl(IN/OUT): The OCI environment or session handle.
<br /><br />

        err(IN/OUT): The OCI error handle.  If there is an error and OCI_ERROR
                     is returned, the error is recorded in err and diagnostic
                     information can be obtained by calling OCIErrorGet().
<br /><br />

    Returns
<br /><br />

      OCI_SUCCESS, OCI_ERROR or OCI_INVALID_HANDLE.
<br /><br />

    Notes
<br /><br />

      It is safe to make concurrent calls to 'OCIThreadTerm()'.
<br /><br />

      'OCIThreadTerm()' will not do anything until it has been called as
      many times as 'OCIThreadInit()' has been called.  When that happens,
      it terminates the OCIThread layer and frees the memory allocated for
      the context.  Once this happens, the context should not be re-used.
      It will be necessary to obtain a new one by calling 'OCIThreadInit()'.
<br /><br />

<br /><br />

  OCIThreadIsMulti - OCIThread Is Multi-Threaded?
<ins><pre class="d_code">
    Description

      This tells the caller whether the application <span class="blue">is</span> running <span class="blue">in</span> a
      multi-threaded environment or a single-threaded environment.

    Prototype
      boolean OCIThreadIsMulti(<span class="blue">void</span>);

    Returns

      TRUE <span class="blue">if</span> the environment <span class="blue">is</span> multi-threaded;
      FALSE <span class="blue">if</span> the environment <span class="blue">is</span> single-threaded.


1.2 Passive Threading Primitives
==================================

1.2.1 Types

The passive threading primitives deal <span class="blue">with</span> the manipulation of mutex,
thread ID's, and thread-specific data.  Since the specifications of these
primitives <span class="blue">do</span> not require the existence of multiple threads, they can be
used both on multithreaded and single-threaded platforms.

1.2.1.1  OCIThreadMutex - OCIThread Mutual Exclusion Lock
</pre></ins>

  The type 'OCIThreadMutex' is used to represent a mutual exclusion lock
  (mutex).  A mutex is typically used for one of two purposes: (i) to
  ensure that only one thread accesses a given set of data at a time, or
  (ii) to ensure that only one thread executes a given critical section of
  code at a time.
<br /><br />

  Mutexes pointer can be declared as parts of client structures or as
  stand-alone variables.  Before they can be used, they must be initialized
  using 'OCIThreadMutexInit()'.  Once they are no longer needed, they must be
  destroyed using 'OCIThreadMutexDestroy()'.  A mutex pointer must NOT be
  used after it is destroyed.
<br /><br />

  A thread can acquire a mutex by using either 'OCIThreadMutexAcquire()' or
  'OCIThreadMutexTry()'.  They both ensure that only one thread at a time is
  allowed to hold a given mutex.  A thread that holds a mutex can release it
  by calling 'OCIThreadMutexRelease()'.
<br /><br />

<br /><br />

1.2.1.2  OCIThreadKey - OCIThread Key for Thread-Specific Data
<ins><pre class="d_code">
  A key can be thought of as a process-wide variable that has a
  thread-specific value.  What <span class="blue">this</span> means <span class="blue">is</span> that all the threads <span class="blue">in</span> a
  process can use any given key.  However, each thread can examine or modify
  that key independently of the other threads.  The value that a thread sees
  when it examines the key will always be the same as the value that it last
  set <span class="blue">for</span> the key.  It will not see any values set <span class="blue">for</span> the key by the other
  threads.

  The type of the value held by a key <span class="blue">is</span> a 'd<span class="blue">void</span>* ' generic pointer.

  Keys can be created using 'OCIThreadKeyInit()'.  When a key <span class="blue">is</span> created, its
  value <span class="blue">is</span> initialized to 'NULL' <span class="blue">for</span> all threads.

  A thread can set a key's value using 'OCIThreadKeySet()'.  A thread can
  get a key's value using 'OCIThreadKeyGet()'.

  The OCIThread key functions will save and retrieve data SPECIFIC TO THE
  THREAD.  When clients maintain a pool of threads and assign the threads to
  different tasks, it *may not* be appropriate <span class="blue">for</span> a task to use OCIThread
  key functions to save data associated <span class="blue">with</span> it.  Here <span class="blue">is</span> a scenario of how
  things can fail: A thread <span class="blue">is</span> assigned to execute the initialization of a
  task.  During the initialization, the task stored some data related to it
  <span class="blue">in</span> the thread using OCIThread key functions.  After the initialization,
  the thread <span class="blue">is</span> returned back to the threads pool.  Later, the threads pool
  manager assigned another thread to perform some operations on the task,
  and the task needs to retrieve those data it stored earlier <span class="blue">in</span>
  initialization.  Since the task <span class="blue">is</span> running <span class="blue">in</span> another thread, it will not
  be able to retrieve the same data back!  Applications that use thread
  pools should be aware of <span class="blue">this</span> and be cautious when using OCIThread key
  functions.


1.2.1.3  OCIThreadKeyDestFunc - OCIThread Key Destructor Function Type
</pre></ins>

  This is the type of a pointer to a key's destructor routine.  Keys can be
  associated with a destructor routine when they are created (see
  'OCIThreadKeyInit()').
<br /><br />

  A key's destructor routine will be called whenever a thread that has a
  non-NULL value for the key terminates.
<br /><br />

  The destructor routine returns nothing and takes one parameter.  The
  parameter will be the value that was set for key when the thread
  terminated.
<br /><br />

  The destructor routine is guaranteed to be called on a thread's value
  in the key after the termination of the thread and before process
  termination.  No more precise guarantee can be made about the timing
  of the destructor routine call; thus no code in the process may assume
  any post-condition of the destructor routine.  In particular, the
  destructor is not guaranteed to execute before a join call on the
  terminated thread returns.
<br /><br />

<br /><br />

1.2.1.4  OCIThreadId - OCIThread Thread ID
<ins><pre class="d_code">
  Type 'OCIThreadId' <span class="blue">is</span> the type that will be used to identify a thread.
  At any given time, no two threads will ever have the same 'OCIThreadId'.
  However, 'OCIThreadId' values can be recycled; i.e., once a thread dies,
  a <span class="blue">new</span> thread may be created that has the same 'OCIThreadId' as the one
  that died.  In particular, the thread ID must uniquely identify a thread
  T within a process, and it must be consistent and valid <span class="blue">in</span> all threads U
  of the process <span class="blue">for</span> which it can be guaranteed that T <span class="blue">is</span> running
  concurrently <span class="blue">with</span> U.  The thread ID <span class="blue">for</span> a thread T must be retrievable
  within thread T.  This will be done via OCIThreadIdGet().

  The 'OCIThreadId' type supports the concept of a NULL thread ID: the NULL
  thread ID will never be the same as the ID of an actual thread.



1.2.2 Function prototypes <span class="blue">for</span> passive primitives
</pre></ins>

1.2.2.1 Mutex functions
<ins><pre class="d_code">
  OCIThreadMutexInit - OCIThread MuteX Initialize
</pre></ins>

    Description
<br /><br />

      This allocate and initializes a mutex.  All mutexes must be
      initialized prior to use.
<br /><br />

    Prototype
<br /><br />

      sword OCIThreadMutexInit(dvoid* hndl, OCIError* err,
                               OCIThreadMutex** mutex);
<br /><br />

        hndl(IN/OUT): The OCI environment or session handle.
<br /><br />

        err(IN/OUT): The OCI error handle.  If there is an error and OCI_ERROR
                     is returned, the error is recorded in err and diagnostic
                     information can be obtained by calling OCIErrorGet().
<br /><br />

        mutex(OUT):  The mutex to initialize.
<br /><br />

    Returns
<br /><br />

      OCI_SUCCESS, OCI_ERROR or OCI_INVALID_HANDLE.
<br /><br />

    Notes
<br /><br />

      Multiple threads must not initialize the same mutex simultaneously.
      Also, a mutex must not be reinitialized until it has been destroyed (see
      'OCIThreadMutexDestroy()').
<br /><br />

  OCIThreadMutexDestroy - OCIThread MuteX Destroy
<ins><pre class="d_code">
    Description

      This destroys and deallocate a mutex.  Each mutex must be destroyed
      once it <span class="blue">is</span> no longer needed.

    Prototype

      sword OCIThreadMutexDestroy(dvoid* hndl, OCIError* err,
                                  OCIThreadMutex** mutex);

        hndl(IN/OUT): The OCI environment or session handle.

        err(IN/OUT): The OCI error handle.  If there <span class="blue">is</span> an error and OCI_ERROR
                     <span class="blue">is</span> returned, the error <span class="blue">is</span> recorded <span class="blue">in</span> err and diagnostic
                     information can be obtained by calling OCIErrorGet().

        mutex(IN/OUT):   The mutex to destroy.

    Returns

      OCI_SUCCESS, OCI_ERROR or OCI_INVALID_HANDLE.

    Notes

      It <span class="blue">is</span> not legal to destroy a mutex that <span class="blue">is</span> uninitialized or <span class="blue">is</span> currently
      held by a thread.  The destruction of a mutex must not occur concurrently
      <span class="blue">with</span> any other operations on the mutex.  A mutex must not be used after
      it has been destroyed.


  OCIThreadMutexAcquire - OCIThread MuteX Acquire
</pre></ins>

    Description
<br /><br />

      This acquires a mutex for the thread in which it is called.  If the mutex
      is held by another thread, the calling thread is blocked until it can
      acquire the mutex.
<br /><br />

    Prototype
<br /><br />

     sword OCIThreadMutexAcquire(dvoid *hndl, OCIError *err,
                                 OCIThreadMutex *mutex);
<br /><br />

        hndl(IN/OUT): The OCI environment or session handle.
<br /><br />

        err(IN/OUT): The OCI error handle.  If there is an error, it is
                     recorded in err and this function returns OCI_ERROR.
                     Diagnostic information can be obtained by calling
                     OCIErrorGet().
<br /><br />

        mutex(IN/OUT):   The mutex to acquire.
<br /><br />

    Returns
<br /><br />

      OCI_SUCCESS, OCI_ERROR or OCI_INVALID_HANDLE.
<br /><br />

    Notes
<br /><br />

      It is illegal to attempt to acquire an uninitialized mutex.
<br /><br />

      This function's behavior is undefined if it is used by a thread to
      acquire a mutex that is already held by that thread.
<br /><br />

<br /><br />

<br /><br />

  OCIThreadMutexRelease - OCIThread MuteX Release
<ins><pre class="d_code">
    Description

      This releases a mutex.  If there are any threads blocked on the mutex,
      one of them will acquire it and become unblocked.

    Prototype

      sword OCIThreadMutexRelease(dvoid *hndl, OCIError *err,
                                  OCIThreadMutex *mutex);

        hndl(IN/OUT): The OCI environment or session handle.

        err(IN/OUT): The OCI error handle.  If there <span class="blue">is</span> an error and OCI_ERROR
                     <span class="blue">is</span> returned, the error <span class="blue">is</span> recorded <span class="blue">in</span> err and diagnostic
                     information can be obtained by calling OCIErrorGet().

        mutex(IN/OUT):   The mutex to release.

    Returns

      OCI_SUCCESS, OCI_ERROR or OCI_INVALID_HANDLE.

    Notes

      It <span class="blue">is</span> illegal to attempt to release an uninitialized mutex.  It <span class="blue">is</span> also
      illegal <span class="blue">for</span> a thread to release a mutex that it does not hold.


  OCIThreadKeyInit - OCIThread KeY Initialize
</pre></ins>

    Description
<br /><br />

      This creates a key.  Each call to this routine allocate and generates
      a new key that is distinct from all other keys.
<br /><br />

    Prototype
<br /><br />

      sword OCIThreadKeyInit(dvoid *hndl, OCIError *err, OCIThreadKey** key,
                             OCIThreadKeyDestFunc destFn);
<br /><br />

        hndl(IN/OUT): The OCI environment or session handle.
<br /><br />

        err(IN/OUT): The OCI error handle.  If there is an error and OCI_ERROR
                     is returned, the error is recorded in err and diagnostic
                     information can be obtained by calling OCIErrorGet().
<br /><br />

        key(OUT):    The 'OCIThreadKey' in which to create the new key.
<br /><br />

        destFn(IN):  The destructor for the key.  NULL is permitted.
<br /><br />

    Returns
<br /><br />

      OCI_SUCCESS, OCI_ERROR or OCI_INVALID_HANDLE.
<br /><br />

    Notes
<br /><br />

      Once this function executes successfully, a pointer to an allocated and
      initialized key is return.  That key can be used with 'OCIThreadKeyGet()'
      and 'OCIThreadKeySet()'.  The initial value of the key will be 'NULL' for
      all threads.
<br /><br />

      It is illegal for this function to be called more than once to create the
      same key (i.e., to be called more than once with the same value for the
      'key' parameter).
<br /><br />

      If the 'destFn' parameter is not NULL, the routine pointed to by 'destFn'
      will be called whenever a thread that has a non-NULL value for the key
      terminates.  The routine will be called with one parameter.  The
      parameter will be the key's value for the thread at the time at which the
      thread terminated.
      If the key does not need a destructor function, pass NULL for 'destFn'.
<br /><br />

<br /><br />

  OCIThreadKeyDestroy - OCIThread KeY DESTROY
<ins><pre class="d_code">
   Description

     Destroy and deallocate the key pointed to by 'key'.

    Prototype

      sword OCIThreadKeyDestroy(dvoid *hndl, OCIError *err,
                                OCIThreadKey** key);

        hndl(IN/OUT): The OCI environment or session handle.

        err(IN/OUT): The OCI error handle.  If there <span class="blue">is</span> an error and OCI_ERROR
                     <span class="blue">is</span> returned, the error <span class="blue">is</span> recorded <span class="blue">in</span> err and diagnostic
                     information can be obtained by calling OCIErrorGet().

        key(IN/OUT):  The 'OCIThreadKey' <span class="blue">in</span> which to destroy the key.

    Returns

      OCI_SUCCESS, OCI_ERROR or OCI_INVALID_HANDLE.

    Notes

      This <span class="blue">is</span> different from the destructor <span class="blue">function</span> callback passed to the
      key create routine.  This <span class="blue">new</span> destroy <span class="blue">function</span> 'OCIThreadKeyDestroy' <span class="blue">is</span>
      used to terminate any resources OCI THREAD acquired when it created
      'key'.  [The 'OCIThreadKeyDestFunc' callback type <span class="blue">is</span> a key VALUE
      destructor; it does <span class="blue">in</span> no way operate on the key itself.]

      This must be called once the user has finished using the key.  Not
      calling the key destroy <span class="blue">function</span> may result <span class="blue">in</span> memory leaks.




1.2.2.2 Thread Key operations
</pre></ins>

  OCIThreadKeyGet - OCIThread KeY Get value
<ins><pre class="d_code">
    Description

      This gets the calling thread's current value <span class="blue">for</span> a key.

    Prototype

      sword OCIThreadKeyGet(dvoid *hndl, OCIError *err, OCIThreadKey *key,
                            dvoid** pValue);

        hndl(IN/OUT): The OCI environment or session handle.

        err(IN/OUT): The OCI error handle.  If there <span class="blue">is</span> an error and OCI_ERROR
                     <span class="blue">is</span> returned, the error <span class="blue">is</span> recorded <span class="blue">in</span> err and diagnostic
                     information can be obtained by calling OCIErrorGet().

        key(IN):          The key.

        pValue(IN/OUT):   The location <span class="blue">in</span> which to place the thread-specific
                          key value.

    Returns

      OCI_SUCCESS, OCI_ERROR or OCI_INVALID_HANDLE.

    Notes

      It <span class="blue">is</span> illegal to use <span class="blue">this</span> <span class="blue">function</span> on a key that has not been created
      using 'OCIThreadKeyInit()'.

      If the calling thread has not yet assigned a value to the key, 'NULL' <span class="blue">is</span>
      placed <span class="blue">in</span> the location pointed to by 'pValue'.


  OCIThreadKeySet - OCIThread KeY Set value
</pre></ins>

    Description
<br /><br />

      This sets the calling thread's value for a key.
<br /><br />

    Prototype
<br /><br />

      sword OCIThreadKeySet(dvoid *hndl, OCIError *err, OCIThreadKey *key,
                            dvoid *value);
<br /><br />

        hndl(IN/OUT): The OCI environment or session handle.
<br /><br />

        err(IN/OUT): The OCI error handle.  If there is an error and OCI_ERROR
                     is returned, the error is recorded in err and diagnostic
                     information can be obtained by calling OCIErrorGet().
<br /><br />

        key(IN/OUT): The key.
<br /><br />

        value(IN):   The thread-specific value to set in the key.
<br /><br />

    Returns
<br /><br />

      OCI_SUCCESS, OCI_ERROR or OCI_INVALID_HANDLE.
<br /><br />

    Notes
<br /><br />

      It is illegal to use this function on a key that has not been created
      using 'OCIThreadKeyInit()'.
<br /><br />

1.2.2.3  Thread Id
<ins><pre class="d_code">
  OCIThreadIdInit - OCIThread Thread Id INITialize
</pre></ins>

    Description
<br /><br />

      Allocate and initialize the thread id 'tid'.
<br /><br />

    Prototype
<br /><br />

      sword OCIThreadIdInit(dvoid *hndl, OCIError *err, OCIThreadId** tid);
<br /><br />

        hndl(IN/OUT): The OCI environment or session handle.
<br /><br />

        err(IN/OUT): The OCI error handle.  If there is an error and OCI_ERROR
                     is returned, the error is recorded in err and diagnostic
                     information can be obtained by calling OCIErrorGet().
<br /><br />

        tid (OUT):   Pointer to the thread ID to initialize.
<br /><br />

    Returns
<br /><br />

      OCI_SUCCESS, OCI_ERROR or OCI_INVALID_HANDLE.
<br /><br />

<br /><br />

  OCIThreadIdDestroy - OCIThread Thread Id DESTROY
<ins><pre class="d_code">
    Description

      Destroy and deallocate the thread id 'tid'.

    Prototype

      sword OCIThreadIdDestroy(dvoid *hndl, OCIError *err, OCIThreadId** tid);

        hndl(IN/OUT): The OCI environment or session handle.

        err(IN/OUT): The OCI error handle.  If there <span class="blue">is</span> an error and OCI_ERROR
                     <span class="blue">is</span> returned, the error <span class="blue">is</span> recorded <span class="blue">in</span> err and diagnostic
                     information can be obtained by calling OCIErrorGet().

        tid(IN/OUT):        Pointer to the thread ID to destroy.

    Returns

      OCI_SUCCESS, OCI_ERROR or OCI_INVALID_HANDLE.

    Note

      'tid' should be initialized by OCIThreadIdInit().


  OCIThreadIdSet - OCIThread Thread Id Set
</pre></ins>

    Description
<br /><br />

      This sets one 'OCIThreadId' to another.
<br /><br />

    Prototype
<br /><br />

      sword OCIThreadIdSet(dvoid *hndl, OCIError *err,
                           OCIThreadId *tidDest,
                           OCIThreadId *tidSrc);
<br /><br />

        hndl(IN/OUT): The OCI environment or session handle.
<br /><br />

        err(IN/OUT): The OCI error handle.  If there is an error and OCI_ERROR
                     is returned, the error is recorded in err and diagnostic
                     information can be obtained by calling OCIErrorGet().
<br /><br />

        tidDest(OUT):   This should point to the location of the 'OCIThreadId'
                        to be set to.
<br /><br />

        tidSrc(IN):     This should point to the 'OCIThreadId' to set from.
<br /><br />

    Returns
<br /><br />

      OCI_SUCCESS, OCI_ERROR or OCI_INVALID_HANDLE.
<br /><br />

    Notes
<br /><br />

      'tid' should be initialized by OCIThreadIdInit().
<br /><br />

<br /><br />

  OCIThreadIdSetNull - OCIThread Thread Id Set Null
<ins><pre class="d_code">
    Description

      This sets the NULL thread ID to a given 'OCIThreadId'.

    Prototype

      sword OCIThreadIdSetNull(dvoid *hndl, OCIError *err,
                               OCIThreadId *tid);

        hndl(IN/OUT): The OCI environment or session handle.

        err(IN/OUT): The OCI error handle.  If there <span class="blue">is</span> an error, it <span class="blue">is</span>
                     recorded <span class="blue">in</span> err and <span class="blue">this</span> <span class="blue">function</span> returns OCI_ERROR.
                     Diagnostic information can be obtained by calling
                     OCIErrorGet().

        tid(OUT):    This should point to the 'OCIThreadId' <span class="blue">in</span> which to put
                     the NULL thread ID.

    Returns

      OCI_SUCCESS, OCI_ERROR or OCI_INVALID_HANDLE.

    Notes

      'tid' should be initialized by OCIThreadIdInit().


  OCIThreadIdGet - OCIThread Thread Id Get
</pre></ins>

    Description
<br /><br />

      This retrieves the 'OCIThreadId' of the thread in which it is called.
<br /><br />

    Prototype
<br /><br />

      sword OCIThreadIdGet(dvoid *hndl, OCIError *err,
                           OCIThreadId *tid);
<br /><br />

        hndl(IN/OUT): The OCI environment or session handle.
<br /><br />

        err(IN/OUT): The OCI error handle.  If there is an error and OCI_ERROR
                     is returned, the error is recorded in err and diagnostic
                     information can be obtained by calling OCIErrorGet().
<br /><br />

        tid(OUT):    This should point to the location in which to place the
                     ID of the calling thread.
<br /><br />

    Returns
<br /><br />

      OCI_SUCCESS, OCI_ERROR or OCI_INVALID_HANDLE.
<br /><br />

    Notes
<br /><br />

      'tid' should be initialized by OCIThreadIdInit().
<br /><br />

      When OCIThread is used in a single-threaded environment,
      OCIThreadIdGet() will always place the same value in the location
      pointed to by 'tid'.  The exact value itself is not important.  The
      important thing is that it is not the same as the NULL thread ID and
      that it is always the same value.
<br /><br />

<br /><br />

  OCIThreadIdSame - OCIThread Thread Ids Same?
<ins><pre class="d_code">
    Description

      This determines whether or not two 'OCIThreadId's represent the same
      thread.

    Prototype

      sword OCIThreadIdSame(dvoid *hndl, OCIError *err,
                            OCIThreadId *tid1, OCIThreadId *tid2,
                            boolean *result);

        hndl(IN/OUT): The OCI environment or session handle.

        err(IN/OUT): The OCI error handle.  If there <span class="blue">is</span> an error and OCI_ERROR
                     <span class="blue">is</span> returned, the error <span class="blue">is</span> recorded <span class="blue">in</span> err and diagnostic
                     information can be obtained by calling OCIErrorGet().

        tid1(IN):   Pointer to the first 'OCIThreadId'.

        tid2(IN):   Pointer to the second 'OCIThreadId'.

        result(IN/OUT): Pointer to the result.

    Returns

      OCI_SUCCESS, OCI_ERROR or OCI_INVALID_HANDLE.

    Notes

      If 'tid1' and 'tid2' represent the same thread, 'result' <span class="blue">is</span> set to TRUE.
      Otherwise, 'result' <span class="blue">is</span> set to FALSE.

      'result' <span class="blue">is</span> set to TRUE <span class="blue">if</span> both 'tid1' and 'tid2' are the NULL thread ID.

      'ti1d' and 'tid2' should be initialized by OCIThreadIdInit().


  OCIThreadIdNull - OCIThread Thread Id NULL?
</pre></ins>

    Description
<br /><br />

      This determines whether or not a given 'OCIThreadId' is the NULL thread
      ID.
<br /><br />

    Prototype
<br /><br />

      sword OCIThreadIdNull(dvoid *hndl, OCIError *err,
                            OCIThreadId *tid,
                            boolean *result);
<br /><br />

        hndl(IN/OUT): The OCI environment or session handle.
<br /><br />

        err(IN/OUT): The OCI error handle.  If there is an error and OCI_ERROR
                     is returned, the error is recorded in err and diagnostic
                     information can be obtained by calling OCIErrorGet().
<br /><br />

        tid(IN):    Pointer to the 'OCIThreadId' to check.
<br /><br />

        result(IN/OUT): Pointer to the result.
<br /><br />

    Returns
<br /><br />

      OCI_SUCCESS, OCI_ERROR or OCI_INVALID_HANDLE.
<br /><br />

    Notes
<br /><br />

      If 'tid' is the NULL thread ID, 'result' is set to TRUE.  Otherwise,
      'result' is set to FALSE.
<br /><br />

      'tid' should be initialized by OCIThreadIdInit().
<br /><br />

<br /><br />

1.3 Active Threading Primitives
=================================
<br /><br />

The active threading primitives deal with the manipulation of actual
threads.  Because the specifications of most of these primitives require
that it be possible to have multiple threads, they work correctly only in
the enabled OCIThread; In the disabled OCIThread, they always return
failure.  The exception is OCIThreadHandleGet(); it may be called in a
single-threaded environment, in which case it will have no effect.
<br /><br />

Active primitives should only be called by code running in a multi-threaded
environment.  You can call OCIThreadIsMulti() to determine whether the
environment is multi-threaded or single-threaded.
<br /><br />

<br /><br />

1.3.1  Types
<ins><pre class="d_code">
1.3.1.1    OCIThreadHandle - OCIThread Thread Handle
</pre></ins>

  Type 'OCIThreadHandle' is used to manipulate a thread in the active
</p>
<strong>primitives:</strong>
OCIThreadJoin()and OCIThreadClose().  A thread handle opened by
  OCIThreadCreate() must be closed in a matching call to
  OCIThreadClose().  A thread handle is invalid after the call to
  OCIThreadClose().
<br /><br />

  The distinction between a thread ID and a thread handle in OCIThread usage
  follows the distinction between the thread ID and the thread handle on
  Windows NT.  On many platforms, the underlying native types are the same.
<br /><br />

<br /><br />

1.3.2  Functions
<ins><pre class="d_code">
  OCIThreadHndInit - OCIThread HaNDle Initialize
</pre></ins>

    Description
<br /><br />

      Allocate and initialize the thread handle.
<br /><br />

    Prototype
<br /><br />

      sword OCIThreadHndInit(dvoid *hndl, OCIError *err,
                             OCIThreadHandle** thnd);
<br /><br />

        hndl(IN/OUT): The OCI environment or session handle.
<br /><br />

        err(IN/OUT): The OCI error handle.  If there is an error and OCI_ERROR
                     is returned, the error is recorded in err and diagnostic
                     information can be obtained by calling OCIErrorGet().
<br /><br />

        thnd(OUT):   The address of pointer to the thread handle to initialize.
<br /><br />

    Returns
<br /><br />

      OCI_SUCCESS, OCI_ERROR or OCI_INVALID_HANDLE.
<br /><br />

<br /><br />

  OCIThreadHndDestroy - OCIThread HaNDle Destroy
<ins><pre class="d_code">
    Description

      Destroy and deallocate the thread handle.

    Prototype

      sword OCIThreadHndDestroy(dvoid *hndl, OCIError *err,
                                OCIThreadHandle** thnd);

        hndl(IN/OUT): The OCI environment or session handle.

        err(IN/OUT): The OCI error handle.  If there <span class="blue">is</span> an error and OCI_ERROR
                     <span class="blue">is</span> returned, the error <span class="blue">is</span> recorded <span class="blue">in</span> err and diagnostic
                     information can be obtained by calling OCIErrorGet().

        thnd(IN/OUT):  The address of pointer to the thread handle to destroy.

    Returns

      OCI_SUCCESS, OCI_ERROR or OCI_INVALID_HANDLE.

    Notes

      'thnd' should be initialized by OCIThreadHndInit().


  OCIThreadCreate - OCIThread Thread Create
</pre></ins>

    Description
<br /><br />

      This creates a new thread.
<br /><br />

    Prototype
<br /><br />

      sword OCIThreadCreate(dvoid *hndl, OCIError *err,
                            void (*start)(dvoid *), dvoid *arg,
                            OCIThreadId *tid, OCIThreadHandle *tHnd);
<br /><br />

        hndl(IN/OUT): The OCI environment or session handle.
<br /><br />

        err(IN/OUT): The OCI error handle.  If there is an error and OCI_ERROR
                     is returned, the error is recorded in err and diagnostic
                     information can be obtained by calling OCIErrorGet().
<br /><br />

        start(IN):    The function in which the new thread should begin
                      execution.
<br /><br />

        arg(IN):      The argument to give the function pointed to by 'start'.
<br /><br />

        tid(IN/OUT):  If not NULL, gets the ID for the new thread.
<br /><br />

        tHnd(IN/OUT): If not NULL, gets the handle for the new thread.
<br /><br />

    Returns
<br /><br />

      OCI_SUCCESS, OCI_ERROR or OCI_INVALID_HANDLE.
<br /><br />

    Notes
<br /><br />

      The new thread will start by executing a call to the function pointed
      to by 'start' with the argument given by 'arg'.  When that function
      returns, the new thread will terminate.  The function should not
      return a value and should accept one parameter, a 'dvoid *'.
<br /><br />

      The call to OCIThreadCreate() must be matched by a call to
      OCIThreadClose() if and only if tHnd is non-NULL.
<br /><br />

      If tHnd is NULL, a thread ID placed in *tid will not be valid in the
      calling thread because the timing of the spawned thread's termination
      is unknown.
<br /><br />

      'tid' should be initialized by OCIThreadIdInit().
<br /><br />

      'thnd' should be initialized by OCIThreadHndInit().
<br /><br />

<br /><br />

<br /><br />

  OCIThreadJoin - OCIThread Thread Join
<ins><pre class="d_code">
    Description

      This <span class="blue">function</span> allows the calling thread to 'join' <span class="blue">with</span> another thread.
      It blocks the caller until the specified thread terminates.

    Prototype

      sword OCIThreadJoin(dvoid *hndl, OCIError *err, OCIThreadHandle *tHnd);

        hndl(IN/OUT): The OCI environment or session handle.

        err(IN/OUT): The OCI error handle.  If there <span class="blue">is</span> an error and OCI_ERROR
                     <span class="blue">is</span> returned, the error <span class="blue">is</span> recorded <span class="blue">in</span> err and diagnostic
                     information can be obtained by calling OCIErrorGet().

        tHnd(IN):    The 'OCIThreadHandle' of the thread to join <span class="blue">with</span>.

    Returns

      OCI_SUCCESS, OCI_ERROR or OCI_INVALID_HANDLE.

    Notes

      'thnd' should be initialized by OCIThreadHndInit().

      The result of multiple threads all trying to join <span class="blue">with</span> the same thread <span class="blue">is</span>
      undefined.


  OCIThreadClose - OCIThread Thread Close
</pre></ins>

   Description
<br /><br />

     This function should be called to close a thread handle.
<br /><br />

   Prototype
<br /><br />

     sword OCIThreadClose(dvoid *hndl, OCIError *err, OCIThreadHandle *tHnd);
<br /><br />

        hndl(IN/OUT): The OCI environment or session handle.
<br /><br />

        err(IN/OUT): The OCI error handle.  If there is an error and OCI_ERROR
                     is returned, the error is recorded in err and diagnostic
                     information can be obtained by calling OCIErrorGet().
<br /><br />

        tHnd(IN/OUT):    The OCIThread thread handle to close.
<br /><br />

   Returns
<br /><br />

      OCI_SUCCESS, OCI_ERROR or OCI_INVALID_HANDLE.
<br /><br />

   Notes
<br /><br />

      'thnd' should be initialized by OCIThreadHndInit().
<br /><br />

      Both thread handle and the thread ID that was returned by the same call
      to OCIThreadCreate() are invalid after the call to OCIThreadClose().
<br /><br />

<br /><br />

<br /><br />

  OCIThreadHandleGet - OCIThread Thread Get Handle
<ins><pre class="d_code">
    Description

      Retrieve the 'OCIThreadHandle' of the thread in which it is called.

    Prototype

      sword OCIThreadHandleGet(dvoid *hndl, OCIError *err,
                               OCIThreadHandle *tHnd);

        hndl(IN/OUT): The OCI environment or session handle.

        err(IN/OUT): The OCI error handle.  If there is an error and OCI_ERROR
                     is returned, the error is recorded in err and diagnostic
                     information can be obtained by calling OCIErrorGet().

        tHnd(IN/OUT):      If not NULL, the location to place the thread
                           handle for the thread.

     Returns

      OCI_SUCCESS, OCI_ERROR or OCI_INVALID_HANDLE.

    Notes

      'thnd' should be initialized by OCIThreadHndInit().

      The thread handle 'tHnd' retrieved by this function must be closed
      with OCIThreadClose() and destroyed by OCIThreadHndDestroy() after it
      is used.




1.4 Using OCIThread
=====================

This section summarizes some of the more important details relating to the use
of OCIThread.

 Process initialization

    OCIThread only requires that the process initialization function
    ('OCIThreadProcessInit()') be called when OCIThread is being used in a
    multi-threaded application.  Failing to call 'OCIThreadProcessInit()' in
    a single-threaded application is not an error.

 OCIThread initialization

    Separate calls to 'OCIThreadInit()' will all return the same OCIThread
    context.

    Also, remember that each call to 'OCIThreadInit()' must eventually be
    matched by a call to 'OCIThreadTerm()'.

 Active vs. Passive Threading primitives

    OCIThread client code written without using any active primitives can be
    compiled and used without change on both single-threaded and
    multi-threaded platforms.

    OCIThread client code written using active primitives will only work
    correctly on multi-threaded platforms.  In order to write a version of the
    same application to run on single-threaded platform, it is necessary to
    branch the your code, whether by branching versions of the source file or
    by branching at runtime with the OCIThreadIsMulti() call.




 
</pre></ins>


<dt><span class="big">int <span class="underline">OCIThreadInit</span>(void* <em>hndl</em>, OCIError * <em>err</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIThreadTerm</span>(void* <em>hndl</em>, OCIError * <em>err</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIThreadIsMulti</span>();
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIThreadMutexInit</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIThreadMutex ** <em>mutex</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIThreadMutexDestroy</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIThreadMutex ** <em>mutex</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIThreadMutexAcquire</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIThreadMutex * <em>mutex</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIThreadMutexRelease</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIThreadMutex * <em>mutex</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIThreadKeyInit</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIThreadKey ** <em>key</em>, void(* <em>destFn</em>)(dvoid*));
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIThreadKeyDestroy</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIThreadKey ** <em>key</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIThreadKeyGet</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIThreadKey * <em>key</em>, void** <em>pValue</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIThreadKeySet</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIThreadKey * <em>key</em>, void* <em>value</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIThreadIdInit</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIThreadId ** <em>tid</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIThreadIdDestroy</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIThreadId ** <em>tid</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIThreadIdSet</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIThreadId * <em>tidDest</em>, OCIThreadId * <em>tidSrc</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIThreadIdSetNull</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIThreadId * <em>tid</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIThreadIdGet</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIThreadId * <em>tid</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIThreadIdSame</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIThreadId * <em>tid1</em>, OCIThreadId * <em>tid2</em>, int* <em>result</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIThreadIdNull</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIThreadId * <em>tid</em>, int* <em>result</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIThreadHndInit</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIThreadHandle ** <em>thnd</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIThreadHndDestroy</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIThreadHandle ** <em>thnd</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIThreadCreate</span>(void* <em>hndl</em>, OCIError * <em>err</em>, void(* <em>start</em>)(void*), void* <em>arg</em>, OCIThreadId * <em>tid</em>, OCIThreadHandle * <em>tHnd</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIThreadJoin</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIThreadHandle * <em>tHnd</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIThreadClose</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIThreadHandle * <em>tHnd</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIThreadHandleGet</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIThreadHandle * <em>tHnd</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">alias <span class="underline">OCIBindRowCallback</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">alias <span class="underline">OCIFetchRowCallback</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">alias <span class="underline">OCISubscriptionNotify</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISubscriptionRegister</span>(OCISvcCtx * <em>svchp</em>, OCISubscription ** <em>subscrhpp</em>, ushort <em>count</em>, OCIError * <em>errhp</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISubscriptionPost</span>(OCISvcCtx * <em>svchp</em>, OCISubscription ** <em>subscrhpp</em>, ushort <em>count</em>, OCIError * <em>errhp</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISubscriptionUnRegister</span>(OCISvcCtx * <em>svchp</em>, OCISubscription * <em>subscrhp</em>, OCIError * <em>errhp</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISubscriptionDisable</span>(OCISubscription * <em>subscrhp</em>, OCIError * <em>errhp</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISubscriptionEnable</span>(OCISubscription * <em>subscrhp</em>, OCIError * <em>errhp</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDateTimeGetTime</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIDateTime * <em>datetime</em>, ubyte* <em>hr</em>, ubyte* <em>mm</em>, ubyte* <em>ss</em>, uint* <em>fsec</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDateTimeGetDate</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIDateTime * <em>date</em>, short* <em>yr</em>, ubyte* <em>mnth</em>, ubyte* <em>dy</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDateTimeGetTimeZoneOffset</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIDateTime * <em>datetime</em>, byte* <em>hr</em>, byte* <em>mm</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDateTimeConstruct</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIDateTime * <em>datetime</em>, short <em>yr</em>, ubyte <em>mnth</em>, ubyte <em>dy</em>, ubyte <em>hr</em>, ubyte <em>mm</em>, ubyte <em>ss</em>, uint <em>fsec</em>, char* <em>timezone</em>, uint <em>timezone_length</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDateTimeSysTimeStamp</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIDateTime * <em>sys_date</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDateTimeAssign</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIDateTime * <em>from</em>, OCIDateTime * <em>to</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDateTimeToText</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIDateTime * <em>date</em>, char* <em>fmt</em>, ubyte <em>fmt_length</em>, ubyte <em>fsprec</em>, char* <em>lang_name</em>, uint <em>lang_length</em>, uint* <em>buf_size</em>, char* <em>buf</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDateTimeFromText</span>(void* <em>hndl</em>, OCIError * <em>err</em>, char* <em>date_str</em>, uint <em>dstr_length</em>, char* <em>fmt</em>, ubyte <em>fmt_length</em>, char* <em>lang_name</em>, uint <em>lang_length</em>, OCIDateTime * <em>date</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDateTimeCompare</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIDateTime * <em>date1</em>, OCIDateTime * <em>date2</em>, int* <em>result</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDateTimeCheck</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIDateTime * <em>date</em>, uint* <em>valid</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDateTimeConvert</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIDateTime * <em>indate</em>, OCIDateTime * <em>outdate</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDateTimeSubtract</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIDateTime * <em>indate1</em>, OCIDateTime * <em>indate2</em>, OCIInterval * <em>inter</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDateTimeIntervalAdd</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIDateTime * <em>datetime</em>, OCIInterval * <em>inter</em>, OCIDateTime * <em>outdatetime</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDateTimeIntervalSub</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIDateTime * <em>datetime</em>, OCIInterval * <em>inter</em>, OCIDateTime * <em>outdatetime</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIIntervalSubtract</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIInterval * <em>minuend</em>, OCIInterval * <em>subtrahend</em>, OCIInterval * <em>result</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIIntervalAdd</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIInterval * <em>addend1</em>, OCIInterval * <em>addend2</em>, OCIInterval * <em>result</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIIntervalMultiply</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIInterval * <em>inter</em>, OCINumber * <em>nfactor</em>, OCIInterval * <em>result</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIIntervalDivide</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIInterval * <em>dividend</em>, OCINumber * <em>divisor</em>, OCIInterval * <em>result</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIIntervalCompare</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIInterval * <em>inter1</em>, OCIInterval * <em>inter2</em>, int* <em>result</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIIntervalFromNumber</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIInterval * <em>inter</em>, OCINumber * <em>number</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIIntervalFromText</span>(void* <em>hndl</em>, OCIError * <em>err</em>, char* <em>inpstr</em>, uint <em>str_len</em>, OCIInterval * <em>result</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIIntervalToText</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIInterval * <em>inter</em>, ubyte <em>lfprec</em>, ubyte <em>fsprec</em>, char* <em>buffer</em>, uint <em>buflen</em>, uint* <em>resultlen</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIIntervalToNumber</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIInterval * <em>inter</em>, OCINumber * <em>number</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIIntervalCheck</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIInterval * <em>interval</em>, uint* <em>valid</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIIntervalAssign</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIInterval * <em>ininter</em>, OCIInterval * <em>outinter</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIIntervalSetYearMonth</span>(void* <em>hndl</em>, OCIError * <em>err</em>, int <em>yr</em>, int <em>mnth</em>, OCIInterval * <em>result</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIIntervalGetYearMonth</span>(void* <em>hndl</em>, OCIError * <em>err</em>, int* <em>yr</em>, int* <em>mnth</em>, OCIInterval * <em>result</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIIntervalSetDaySecond</span>(void* <em>hndl</em>, OCIError * <em>err</em>, int <em>dy</em>, int <em>hr</em>, int <em>mm</em>, int <em>ss</em>, int <em>fsec</em>, OCIInterval * <em>result</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIIntervalGetDaySecond</span>(void* <em>hndl</em>, OCIError * <em>err</em>, int* <em>dy</em>, int* <em>hr</em>, int* <em>mm</em>, int* <em>ss</em>, int* <em>fsec</em>, OCIInterval * <em>result</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDateTimeToArray</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIDateTime * <em>datetime</em>, OCIInterval * <em>reftz</em>, ubyte* <em>outarray</em>, uint* <em>len</em>, ubyte <em>fsprec</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDateTimeFromArray</span>(void* <em>hndl</em>, OCIError * <em>err</em>, ubyte* <em>inarray</em>, uint <em>len</em>, ubyte <em>type</em>, OCIDateTime * <em>datetime</em>, OCIInterval * <em>reftz</em>, ubyte <em>fsprec</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDateTimeGetTimeZoneName</span>(void* <em>hndl</em>, OCIError * <em>err</em>, OCIDateTime * <em>datetime</em>, ubyte* <em>buf</em>, uint* <em>buflen</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIIntervalFromTZ</span>(void* <em>hndl</em>, OCIError * <em>err</em>, char* <em>inpstring</em>, uint <em>str_len</em>, OCIInterval * <em>result</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIConnectionPoolCreate</span>(OCIEnv * <em>envhp</em>, OCIError * <em>errhp</em>, OCICPool * <em>poolhp</em>, char** <em>poolName</em>, int* <em>poolNameLen</em>, char* <em>dblink</em>, int <em>dblinkLen</em>, uint <em>connMin</em>, uint <em>connMax</em>, uint <em>connIncr</em>, char* <em>poolUserName</em>, int <em>poolUserLen</em>, char* <em>poolPassword</em>, int <em>poolPassLen</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIConnectionPoolDestroy</span>(OCICPool * <em>poolhp</em>, OCIError * <em>errhp</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISessionPoolCreate</span>(OCIEnv * <em>envhp</em>, OCIError * <em>errhp</em>, OCISPool * <em>spoolhp</em>, char** <em>poolName</em>, uint* <em>poolNameLen</em>, char* <em>connStr</em>, uint <em>connStrLen</em>, uint <em>sessMin</em>, uint <em>sessMax</em>, uint <em>sessIncr</em>, char* <em>userid</em>, uint <em>useridLen</em>, char* <em>password</em>, uint <em>passwordLen</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISessionPoolDestroy</span>(OCISPool * <em>spoolhp</em>, OCIError * <em>errhp</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISessionGet</span>(OCIEnv * <em>envhp</em>, OCIError * <em>errhp</em>, OCISvcCtx ** <em>svchp</em>, OCIAuthInfo * <em>authhp</em>, char* <em>poolName</em>, uint <em>poolName_len</em>, char* <em>tagInfo</em>, uint <em>tagInfo_len</em>, char** <em>retTagInfo</em>, uint* <em>retTagInfo_len</em>, int* <em>found</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCISessionRelease</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, char* <em>tag</em>, uint <em>tag_len</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIAppCtxSet</span>(void* <em>sesshndl</em>, void* <em>nsptr</em>, uint <em>nsptrlen</em>, void* <em>attrptr</em>, uint <em>attrptrlen</em>, void* <em>valueptr</em>, uint <em>valueptrlen</em>, OCIError * <em>errhp</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIAppCtxClearAll</span>(void* <em>sesshndl</em>, void* <em>nsptr</em>, uint <em>nsptrlen</em>, OCIError * <em>errhp</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIPing</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIKerbAttrSet</span>(OCISession * <em>trgthndlp</em>, uint <em>cred_use</em>, ubyte* <em>ftgt_ticket</em>, uint <em>ticket_len</em>, ubyte* <em>session_key</em>, uint <em>skey_len</em>, ushort <em>ftgt_keytype</em>, uint <em>ftgt_ticket_flags</em>, int <em>ftgt_auth_time</em>, int <em>ftgt_start_time</em>, int <em>ftgt_end_time</em>, int <em>ftgt_renew_time</em>, char* <em>ftgt_client_principal</em>, uint <em>ftgt_client_principal_len</em>, char* <em>ftgt_client_realm</em>, uint <em>ftgt_client_realm_len</em>, OCIError * <em>errhp</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDBStartup</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCIAdmin * <em>admhp</em>, uint <em>mode</em>, uint <em>flags</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIDBShutdown</span>(OCISvcCtx * <em>svchp</em>, OCIError * <em>errhp</em>, OCIAdmin * <em>admhp</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCIClientVersion</span>(int* <em>major_version</em>, int* <em>minor_version</em>, int* <em>update_num</em>, int* <em>patch_num</em>, int* <em>port_update_num</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">OCIInitEventHandle</span>(OCIError * <em>errhp</em>, OCIEvent * <em>event</em>, char* <em>str</em>, uint <em>size</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">deprecated int <span class="underline">OCIStmtBindByPos</span>(OCIStmt * <em>stmtp</em>, OCIBind * <em>bindp</em>, OCIError * <em>errhp</em>, uint <em>position</em>, void* <em>valuep</em>, int <em>value_sz</em>, ushort <em>dty</em>, void* <em>indp</em>, ushort* <em>alenp</em>, ushort* <em>rcodep</em>, uint <em>maxarr_len</em>, uint* <em>curelep</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">deprecated int <span class="underline">OCIStmtBindByName</span>(OCIStmt * <em>stmtp</em>, OCIBind * <em>bindp</em>, OCIError * <em>errhp</em>, char* <em>placeholder</em>, int <em>placeh_len</em>, void* <em>valuep</em>, int <em>value_sz</em>, ushort <em>dty</em>, void* <em>indp</em>, ushort* <em>alenp</em>, ushort* <em>rcodep</em>, uint <em>maxarr_len</em>, uint* <em>curelep</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">deprecated int <span class="underline">ocidefn</span>(OCIStmt * <em>stmtp</em>, OCIDefine * <em>defnp</em>, OCIError * <em>errhp</em>, uint <em>position</em>, void* <em>valuep</em>, int <em>value_sz</em>, ushort <em>dty</em>, void* <em>indp</em>, ushort* <em>rlenp</em>, ushort* <em>rcodep</em>, uint <em>mode</em>);
</span></dt>
<dd><br /><br />
</dd>
</dd>

<hr />
<p><span class="small">Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. BSD license
 
</span></p>
</body>
</html>
