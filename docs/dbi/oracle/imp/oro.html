<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<title>dbi.oracle.imp.oro</title>
	<style type="text/css">
		.underline {
			text-decoration: underline;
		}

		.big {
			font-size: larger;
		}

		.small {
			font-size: smaller;
		}

		.red {
			color: red;
		}

		.blue {
			color: blue;
		}

		.green {
			color: green;
		}

		.yellow {
			color: yellow;
		}

		.black {
			color: black;
		}

		.white {
			color: white;
		}
	</style>
</head>
<body>
<h1>dbi.oracle.imp.oro</h1>
<!-- Generated by Ddoc from dbi\oracle\imp\oro.d -->
<p>Oracle import library.
</p>
<p>Part of the D DBI project.

</p>
<p><strong>Version:</strong><br />Oracle 10g revision 2
<br /><br />

	Import library version 0.03

</p>
<p><strong>Authors:</strong><br />The D DBI project

</p>

<dl><dt><span class="big">struct <span class="underline">OCIRef</span>;
</span></dt>
<dd><p>OCI object reference.
</p>
<p>In the Oracle object runtime environment, an object is identified by an
 object reference (ref) which contains the object identifier plus other
 runtime information.  The contents of a ref is opaque to clients.  Use
 OCIObjectNew() to construct a ref.
 
</p>

<dl></dl>
</dd>
<dt><span class="big">alias <span class="underline">OCIInd</span>;
</span></dt>
<dd><p>A variable of this type contains (<strong>null</strong>) indicator information.
 
</p>

</dd>
<dt><span class="big">const short <span class="underline">OCI_IND_NOTNULL</span>;
</span></dt>
<dd><p>Not <strong>null</strong>.
</p>

</dd>
<dt><span class="big">const short <span class="underline">OCI_IND_NULL</span>;
</span></dt>
<dd><p>Is <strong>null</strong>.
</p>

</dd>
<dt><span class="big">const short <span class="underline">OCI_IND_BADNULL</span>;
</span></dt>
<dd><p>Bad <strong>null</strong>.
</p>

</dd>
<dt><span class="big">const short <span class="underline">OCI_IND_NOTNULLABLE</span>;
</span></dt>
<dd><p>Can't be <strong>null</strong>.
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_ATTR_OBJECT_DETECTCHANGE</span>;
</span></dt>
<dd><p>To enable object change detection mode, set this to TRUE.
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_ATTR_OBJECT_NEWNOTNULL</span>;
</span></dt>
<dd><p>To enable object creation with non-<strong>null</strong> attributes by default, set this to TRUE.  By default, an object is created with <strong>null</strong> attributes.
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_ATTR_CACHE_ARRAYFLUSH</span>;
</span></dt>
<dd><p>To enable sorting of the objects that belong to the same table before being flushed through OCICacheFlush, set this to TRUE.  Please note that by enabling this object cache will not be flushing the objects in the same order they were dirtied.
</p>

</dd>
<dt><span class="big">enum <span class="underline">OCIPinOpt</span>;
</span></dt>
<dd><p>OCI object pin option.
</p>
<p>In the Oracle object runtime environment, the program has the option to
 specify which copy of the object to pin.
<br /><br />

 OCI_PINOPT_DEFAULT pins an object using the default pin option.  The default
 pin option can be set as an attribute of the OCI environment handle
 (OCI_ATTR_PINTOPTION).  The value of the default pin option can be
 OCI_PINOPT_ANY, OCI_PINOPT_RECENT, or OCI_PIN_LATEST. The default option
 is initialized to OCI_PINOPT_ANY.
<br /><br />

 OCI_PIN_ANY pins any copy of the object.  The object is pinned
 using the following criteria:
   If the object copy is not loaded, load it from the persistent store.
   Otherwise, the loaded object copy is returned to the program.
<br /><br />

 OCI_PIN_RECENT pins the latest copy of an object.  The object is
 pinned using the following criteria:
   If the object is not loaded, load the object from the persistent store
       from the latest version.
   If the object is not loaded in the current transaction and it is not
       dirtied, the object is refreshed from the latest version.
   Otherwise, the loaded object copy is returned to the program.
<br /><br />

 OCI_PINOPT_LATEST pins the latest copy of an object.  The object copy is
 pinned using the following criteria:
   If the object copy is not loaded, load it from the persistent store.
   If the object copy is loaded and dirtied, it is returned to the program.
   Otherwise, the loaded object copy is refreshed from the persistent store.
 
</p>

<dl><dt><span class="big"><span class="underline">OCI_PIN_DEFAULT</span></span></dt>
<dd><p>Default pin option.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_PIN_ANY</span></span></dt>
<dd><p>Pin any copy of the object.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_PIN_RECENT</span></span></dt>
<dd><p>Pin recent copy of the object.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_PIN_LATEST</span></span></dt>
<dd><p>Pin latest copy of the object.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">enum <span class="underline">OCILockOpt</span>;
</span></dt>
<dd><p>OCI object lock option.
</p>
<p>This option is used to specify the locking preferences when an object is
 loaded from the server.
 
</p>

<dl><dt><span class="big"><span class="underline">OCI_LOCK_NONE</span></span></dt>
<dd><p><strong>null</strong> (same as no lock).
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_LOCK_X</span></span></dt>
<dd><p>Exclusive lock.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_LOCK_X_NOWAIT</span></span></dt>
<dd><p>Exclusive lock, do not wait.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">enum <span class="underline">OCIMarkOpt</span>;
</span></dt>
<dd><p>OCI object mark option.
</p>
<p>When the object is marked updated, the client has to specify how the
 object is intended to be changed.
 
</p>

<dl><dt><span class="big"><span class="underline">OCI_MARK_DEFAULT</span></span></dt>
<dd><p>Default (the same as OCI_MARK_NONE).
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_MARK_NONE</span></span></dt>
<dd><p>Object has not been modified.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_MARK_UPDATE</span></span></dt>
<dd><p>Object is to be updated.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">typedef <span class="underline">OCIDuration</span>;
</span></dt>
<dd><p>OCI object duration.
</p>
<p>A client can specify the duration of which an object is pinned (pin
 duration) and the duration of which the object is in memory (allocation
 duration).  If the objects are still pinned at the end of the pin duration,
 the object cache manager will automatically unpin the objects for the
 client. If the objects still exist at the end of the allocation duration,
 the object cache manager will automatically free the objects for the client.
<br /><br />

 Objects that are pinned with the option OCI_DURATION_TRANS will get unpinned
 automatically at the end of the current transaction.
<br /><br />

 Objects that are pinned with the option OCI_DURATION_SESSION will get
 unpinned automatically at the end of the current session (connection).
<br /><br />

 The option OCI_DURATION_NULL is used when the client does not want to set
 the pin duration.  If the object is already loaded into the cache, then the
 pin duration will remain the same.  If the object is not yet loaded, the
 pin duration of the object will be set to OCI_DURATION_DEFAULT.
 
</p>

</dd>
<dt><span class="big">const OCIDuration <span class="underline">OCI_DURATION_INVALID</span>;
</span></dt>
<dd><p>Invalid duration.
</p>

</dd>
<dt><span class="big">const OCIDuration <span class="underline">OCI_DURATION_BEGIN</span>;
</span></dt>
<dd><p>Beginning sequence of duration.
</p>

</dd>
<dt><span class="big">const OCIDuration <span class="underline">OCI_DURATION_NULL</span>;
</span></dt>
<dd><p>Null duration.
</p>

</dd>
<dt><span class="big">const OCIDuration <span class="underline">OCI_DURATION_DEFAULT</span>;
</span></dt>
<dd><p>Default.
</p>

</dd>
<dt><span class="big">const OCIDuration <span class="underline">OCI_DURATION_USER_CALLBACK</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">const OCIDuration <span class="underline">OCI_DURATION_NEXT</span>;
</span></dt>
<dd><p>Next special duration.
</p>

</dd>
<dt><span class="big">const OCIDuration <span class="underline">OCI_DURATION_SESSION</span>;
</span></dt>
<dd><p>The end of user session.
</p>

</dd>
<dt><span class="big">const OCIDuration <span class="underline">OCI_DURATION_TRANS</span>;
</span></dt>
<dd><p>The end of user transaction.
</p>

</dd>
<dt><span class="big">deprecated const OCIDuration <span class="underline">OCI_DURATION_CALL</span>;
</span></dt>
<dd><p>Deprecated.  The end of user client/server call.
</p>

</dd>
<dt><span class="big">const OCIDuration <span class="underline">OCI_DURATION_STATEMENT</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">const OCIDuration <span class="underline">OCI_DURATION_CALLOUT</span>;
</span></dt>
<dd><p>This is to be used only during callouts.  It is similar to that of OCI_DURATION_CALL, but lasts only for the duration of a callout.  Its heap is from PGA.
</p>

</dd>
<dt><span class="big">const OCIDuration <span class="underline">OCI_DURATION_LAST</span>;
</span></dt>
<dd><p>The last predefined duration.
</p>

</dd>
<dt><span class="big">const OCIDuration <span class="underline">OCI_DURATION_PROCESS</span>;
</span></dt>
<dd><p>This is not being treated as other predefined durations such as SESSION, CALL etc, because this would not have an entry in the duration table and its functionality is primitive such that only allocate, free, resize memory are allowed, but one cannot create subduration out of this.
</p>

</dd>
<dt><span class="big">enum <span class="underline">OCIObjectProperty</span>;
</span></dt>
<dd><p>OCI object property.
</p>
<p><span class="red">Deprecated:</span><br />This will be removed or changed in a future release.
<br /><br />

 This specifies the properties of objects in the object cache.
 
</p>

<dl><dt><span class="big"><span class="underline">OCI_OBJECTPROP_DIRTIED</span></span></dt>
<dd><p>Dirty objects.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_OBJECTPROP_LOADED</span></span></dt>
<dd><p>Objects loaded in the transaction.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_OBJECTPROP_LOCKED</span></span></dt>
<dd><p>Locked objects.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">enum <span class="underline">OCIRefreshOpt</span>;
</span></dt>
<dd><p>OCI cache refresh option.
</p>
<p>This option is used to specify the set of objects to be refreshed.
<br /><br />

 OCI_REFRESH_LOAD refreshes the objects that are loaded in the current
 transaction.
 
</p>

<dl><dt><span class="big"><span class="underline">OCI_REFRESH_LOADED</span></span></dt>
<dd><p>Refresh objects loaded in the transaction.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">enum <span class="underline">OCIObjectEvent</span>;
</span></dt>
<dd><p>OCI Object Event.
</p>
<p><span class="red">Deprecated:</span><br />This will be removed or changed in a future release.
<br /><br />

 This specifies the kind of event that is supported by the object
 cache.  The program can register a callback that is invoked when the
 specified event occurs.
 
</p>

<dl><dt><span class="big"><span class="underline">OCI_OBJECTEVENT_BEFORE_FLUSH</span></span></dt>
<dd><p>Before flushing the cache.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_OBJECTEVENT_AFTER_FLUSH</span></span></dt>
<dd><p>After flushing the cache.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_OBJECTEVENT_BEFORE_REFRESH</span></span></dt>
<dd><p>Before refreshing the cache.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_OBJECTEVENT_AFTER_REFRESH</span></span></dt>
<dd><p>After refreshing the cache.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_OBJECTEVENT_WHEN_MARK_UPDATED</span></span></dt>
<dd><p>When an object is marked updated.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_OBJECTEVENT_WHEN_MARK_DELETED</span></span></dt>
<dd><p>When an object is marked deleted.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_OBJECTEVENT_WHEN_UNMARK</span></span></dt>
<dd><p>When an object is being unmarked.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_OBJECTEVENT_WHEN_LOCK</span></span></dt>
<dd><p>When an object is being locked.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">const ubyte <span class="underline">OCI_OBJECTCOPY_NOREF</span>;
</span></dt>
<dd><p>If <span class="underline">OCI_OBJECTCOPY_NOREF</span> is specified when copying an instance, the  reference and lob will not be copied to the target instance.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_OBJECTFREE_FORCE</span>;
</span></dt>
<dd><p>If OCI_OBJECTCOPY_FORCE is specified when freeing an instance, the instance is freed regardless it is pinned or dirtied.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_OBJECTFREE_NONULL</span>;
</span></dt>
<dd><p>If OCI_OBJECTCOPY_NONULL is specified when freeing an instance, the <strong>null</strong> structure is not freed.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_OBJECTFREE_HEADER</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">alias <span class="underline">OCIObjectPropId</span>;
</span></dt>
<dd><p>OCI object property id.
</p>
<p>Identifies the different properties of objects.
 
</p>

</dd>
<dt><span class="big">const ubyte <span class="underline">OCI_OBJECTPROP_LIFETIME</span>;
</span></dt>
<dd><p>Persistent or transient or value.
</p>

</dd>
<dt><span class="big">const ubyte <span class="underline">OCI_OBJECTPROP_SCHEMA</span>;
</span></dt>
<dd><p>Schema name of table containing object.
</p>

</dd>
<dt><span class="big">const ubyte <span class="underline">OCI_OBJECTPROP_TABLE</span>;
</span></dt>
<dd><p>Table name of table containing object.
</p>

</dd>
<dt><span class="big">const ubyte <span class="underline">OCI_OBJECTPROP_PIN_DURATION</span>;
</span></dt>
<dd><p>Pin duartion of object.
</p>

</dd>
<dt><span class="big">const ubyte <span class="underline">OCI_OBJECTPROP_ALLOC_DURATION</span>;
</span></dt>
<dd><p>Alloc duartion of object.
</p>

</dd>
<dt><span class="big">const ubyte <span class="underline">OCI_OBJECTPROP_LOCK</span>;
</span></dt>
<dd><p>Lock status of object.
</p>

</dd>
<dt><span class="big">const ubyte <span class="underline">OCI_OBJECTPROP_MARKSTATUS</span>;
</span></dt>
<dd><p>Mark status of object.
</p>

</dd>
<dt><span class="big">const ubyte <span class="underline">OCI_OBJECTPROP_VIEW</span>;
</span></dt>
<dd><p>Is object a view object or not?
</p>

</dd>
<dt><span class="big">enum <span class="underline">OCIObjectLifetime</span>;
</span></dt>
<dd><p>OCI object lifetime.
</p>
<p>Classifies objects depending upon the lifetime and referenceability
 of the object.
 
</p>

<dl><dt><span class="big"><span class="underline">OCI_OBJECT_PERSISTENT</span></span></dt>
<dd><p>Persistent object.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_OBJECT_TRANSIENT</span></span></dt>
<dd><p>Transient object.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_OBJECT_VALUE</span></span></dt>
<dd><p>Value object.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">alias <span class="underline">OCIObjectMarkStatus</span>;
</span></dt>
<dd><p>OCI object mark status.
</p>
<p>Status of the object - new, updated or deleted.
 
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_OBJECT_NEW</span>;
</span></dt>
<dd><p>New object.
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_OBJECT_DELETED</span>;
</span></dt>
<dd><p>Object marked deleted.
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_OBJECT_UPDATED</span>;
</span></dt>
<dd><p>Object marked updated.
</p>

</dd>
<dt><span class="big">bool <span class="underline">OCI_OBJECT_IS_DELETED</span>(uint <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_OBJECT_IS_NEW</span>(uint <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_OBJECT_IS_DIRTY</span>(uint <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">alias <span class="underline">OCITypeCode</span>;
</span></dt>
<dd><p>The <span class="underline">OCITypeCode</span> type is interchangeable with the existing SQLT type, which is a ub2.
 
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_REF</span>;
</span></dt>
<dd><p>SQL/OTS OBJECT REFERENCE.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_DATE</span>;
</span></dt>
<dd><p>SQL DATE  OTS DATE.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_SIGNED8</span>;
</span></dt>
<dd><p>SQL SIGNED INTEGER(8)  OTS SINT8.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_SIGNED16</span>;
</span></dt>
<dd><p>SQL SIGNED INTEGER(16)  OTS SINT16.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_SIGNED32</span>;
</span></dt>
<dd><p>SQL SIGNED INTEGER(32)  OTS SINT32.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_REAL</span>;
</span></dt>
<dd><p>SQL REAL  OTS SQL_REAL.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_DOUBLE</span>;
</span></dt>
<dd><p>SQL DOUBLE PRECISION  OTS SQL_DOUBLE.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_BFLOAT</span>;
</span></dt>
<dd><p>Binary float.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_BDOUBLE</span>;
</span></dt>
<dd><p>Binary double.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_FLOAT</span>;
</span></dt>
<dd><p>SQL FLOAT(P)  OTS FLOAT(P).
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_NUMBER</span>;
</span></dt>
<dd><p>SQL NUMBER(P S)  OTS NUMBER(P S).
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_DECIMAL</span>;
</span></dt>
<dd><p>SQL DECIMAL(P S)  OTS DECIMAL(P S).
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_UNSIGNED8</span>;
</span></dt>
<dd><p>SQL UNSIGNED INTEGER(8)  OTS OCITypeCode8.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_UNSIGNED16</span>;
</span></dt>
<dd><p>SQL UNSIGNED INTEGER(16)  OTS OCITypeCode16.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_UNSIGNED32</span>;
</span></dt>
<dd><p>SQL UNSIGNED INTEGER(32)  OTS OCITypeCode32.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_OCTET</span>;
</span></dt>
<dd><p>SQL ???  OTS OCTET.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_SMALLINT</span>;
</span></dt>
<dd><p>SQL SMALLINT  OTS SMALLINT.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_INTEGER</span>;
</span></dt>
<dd><p>SQL INTEGER  OTS INTEGER.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_RAW</span>;
</span></dt>
<dd><p>SQL RAW(N)  OTS RAW(N).
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_PTR</span>;
</span></dt>
<dd><p>SQL POINTER  OTS POINTER.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_VARCHAR2</span>;
</span></dt>
<dd><p>SQL VARCHAR2(N)  OTS SQL_VARCHAR2(N).
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_CHAR</span>;
</span></dt>
<dd><p>SQL CHAR(N)  OTS SQL_CHAR(N).
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_VARCHAR</span>;
</span></dt>
<dd><p>SQL VARCHAR(N)  OTS SQL_VARCHAR(N).
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_MLSLABEL</span>;
</span></dt>
<dd><p>OTS MLSLABEL.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_VARRAY</span>;
</span></dt>
<dd><p>SQL VARRAY  OTS PAGED VARRAY.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_TABLE</span>;
</span></dt>
<dd><p>SQL TABLE  OTS MULTISET.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_OBJECT</span>;
</span></dt>
<dd><p>SQL/OTS NAMED OBJECT TYPE.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_OPAQUE</span>;
</span></dt>
<dd><p>SQL/OTS Opaque Types.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_NAMEDCOLLECTION</span>;
</span></dt>
<dd><p>SQL/OTS NAMED COLLECTION TYPE.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_BLOB</span>;
</span></dt>
<dd><p>SQL/OTS BINARY LARGE OBJECT.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_BFILE</span>;
</span></dt>
<dd><p>SQL/OTS BINARY FILE OBJECT.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_CLOB</span>;
</span></dt>
<dd><p>SQL/OTS CHARACTER LARGE OBJECT.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_CFILE</span>;
</span></dt>
<dd><p>SQL/OTS CHARACTER FILE OBJECT.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_TIME</span>;
</span></dt>
<dd><p>SQL/OTS TIME.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_TIME_TZ</span>;
</span></dt>
<dd><p>SQL/OTS TIME_TZ.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_TIMESTAMP</span>;
</span></dt>
<dd><p>SQL/OTS TIMESTAMP.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_TIMESTAMP_TZ</span>;
</span></dt>
<dd><p>SQL/OTS TIMESTAMP_TZ.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_TIMESTAMP_LTZ</span>;
</span></dt>
<dd><p>TIMESTAMP_LTZ.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_INTERVAL_YM</span>;
</span></dt>
<dd><p>SQL/OTS INTRVL YR-MON.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_INTERVAL_DS</span>;
</span></dt>
<dd><p>SQL/OTS INTRVL DAY-SEC.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_UROWID</span>;
</span></dt>
<dd><p>Urowid type.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_OTMFIRST</span>;
</span></dt>
<dd><p>first Open Type Manager typecode.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_OTMLAST</span>;
</span></dt>
<dd><p>last OTM typecode.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_SYSFIRST</span>;
</span></dt>
<dd><p>first OTM system type (internal).
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_SYSLAST</span>;
</span></dt>
<dd><p>last OTM system type (internal).
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_PLS_INTEGER</span>;
</span></dt>
<dd><p>type code for PLS_INTEGER.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_NCHAR</span>;
</span></dt>
<dd><p>Intended for use in the OCIAnyData API only.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_NVARCHAR2</span>;
</span></dt>
<dd><p>Intended for use in the OCIAnyData API only.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_NCLOB</span>;
</span></dt>
<dd><p>Intended for use in the OCIAnyData API only.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_NONE</span>;
</span></dt>
<dd><p>To indicate absence of typecode being specified.
</p>

</dd>
<dt><span class="big">const ushort <span class="underline">OCI_TYPECODE_ERRHP</span>;
</span></dt>
<dd><p>To indicate error has to be taken from error handle - reserved for sqlplus use.
</p>

</dd>
<dt><span class="big">enum <span class="underline">OCITypeGetOpt</span>;
</span></dt>
<dd><p>This is the flag passed to OCIGetTypeArray() to indicate how the TDO is
 going to be loaded into the object cache.
 OCI_TYPEGET_HEADER implies that only the header portion is to be loaded
 initially, with the rest loaded in on a 'lazy' basis. Only the header is
 needed for PL/SQL and OCI operations. OCI_TYPEGET_ALL implies that ALL
 the attributes and methods belonging to a TDO will be loaded into the
 object cache in one round trip. Hence it will take much longer to execute,
 but will ensure that no more loading needs to be done when pinning ADOs
 etc. This is only needed if your code needs to examine and manipulate
 attribute and method information.
</p>
<p>The default is OCI_TYPEGET_HEADER.
 
</p>

<dl><dt><span class="big"><span class="underline">OCI_TYPEGET_HEADER</span></span></dt>
<dd><p>Load only the header portion of the TDO when getting the type.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_TYPEGET_ALL</span></span></dt>
<dd><p>Load all attribute and method descriptors as well.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">enum <span class="underline">OCITypeEncap</span>;
</span></dt>
<dd><p>OCI Encapsulation Level
 
</p>

<dl><dt><span class="big"><span class="underline">OCI_TYPEENCAP_PRIVATE</span></span></dt>
<dd><strong>Private:</strong>
only visible internally.


</dd>
<dt><span class="big"><span class="underline">OCI_TYPEENCAP_PUBLIC</span></span></dt>
<dd><strong>Public:</strong>
visible both internally and externally.


</dd>
</dl>
</dd>
<dt><span class="big">enum <span class="underline">OCITypeMethodFlag</span>;
</span></dt>
<dd><br /><br />
<dl><dt><span class="big"><span class="underline">OCI_TYPEMETHOD_INLINE</span></span></dt>
<dd><p>Inline.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_TYPEMETHOD_CONSTANT</span></span></dt>
<dd><p>Constant.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_TYPEMETHOD_VIRTUAL</span></span></dt>
<dd><p>Virtual.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_TYPEMETHOD_CONSTRUCTOR</span></span></dt>
<dd><p>Constructor.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_TYPEMETHOD_DESTRUCTOR</span></span></dt>
<dd><p>Destructor.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_TYPEMETHOD_OPERATOR</span></span></dt>
<dd><p>Operator.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_TYPEMETHOD_SELFISH</span></span></dt>
<dd><p>Selfish method (generic otherwise).
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_TYPEMETHOD_MAP</span></span></dt>
<dd><p>Map (relative ordering).
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_TYPEMETHOD_ORDER</span></span></dt>
<dd><p>Order (relative ordering).
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_TYPEMETHOD_RNDS</span></span></dt>
<dd><p>Read no Data State (default).
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_TYPEMETHOD_WNDS</span></span></dt>
<dd><p>Write no Data State.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_TYPEMETHOD_RNPS</span></span></dt>
<dd><p>Read no Process State.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_TYPEMETHOD_WNPS</span></span></dt>
<dd><p>Write no Process State.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_TYPEMETHOD_ABSTRACT</span></span></dt>
<dd><p>Abstract (not instantiable) method.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_TYPEMETHOD_OVERRIDING</span></span></dt>
<dd><p>Overriding method.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_TYPEMETHOD_PIPELINED</span></span></dt>
<dd><p>Method is pipelined.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">bool <span class="underline">OCI_METHOD_IS_NEW</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_METHOD_IS_CONSTANT</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_METHOD_IS_VIRTUAL</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_METHOD_IS_CONSTRUCTOR</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_METHOD_IS_DESTRUCTOR</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_METHOD_IS_OPERATOR</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_METHOD_IS_SELFISH</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_METHOD_IS_MAP</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_METHOD_IS_ORDER</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_METHOD_IS_RNDS</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_METHOD_IS_WNDS</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_METHOD_IS_RNPS</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_METHOD_IS_WNPS</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_METHOD_IS_ABSTRACT</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_METHOD_IS_OVERRIDING</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_METHOD_IS_PIPELINED</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_TYPEMETHOD_IS_INLINE</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_TYPEMETHOD_IS_CONSTANT</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_TYPEMETHOD_IS_VIRTUAL</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_TYPEMETHOD_IS_CONSTRUCTOR</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_TYPEMETHOD_IS_DESTRUCTOR</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_TYPEMETHOD_IS_OPERATOR</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_TYPEMETHOD_IS_SELFISH</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_TYPEMETHOD_IS_MAP</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_TYPEMETHOD_IS_ORDER</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_TYPEMETHOD_IS_RNDS</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_TYPEMETHOD_IS_WNDS</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_TYPEMETHOD_IS_RNPS</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_TYPEMETHOD_IS_WNPS</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_TYPEMETHOD_IS_ABSTRACT</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_TYPEMETHOD_IS_OVERRIDING</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">bool <span class="underline">OCI_TYPEMETHOD_IS_PIPELINED</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_SET_INLINE</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_SET_CONSTANT</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_SET_VIRTUAL</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_SET_CONSTRUCTOR</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_SET_DESTRUCTOR</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_SET_OPERATOR</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_SET_SELFISH</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_SET_MAP</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_SET_ORDER</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_SET_RNDS</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_SET_WNDS</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_SET_RNPS</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_SET_WNPS</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_CLEAR_INLINE</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_CLEAR_CONSTANT</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_CLEAR_VIRTUAL</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_CLEAR_CONSTRUCTOR</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_CLEAR_DESTRUCTOR</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_CLEAR_OPERATOR</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_CLEAR_SELFISH</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_CLEAR_MAP</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_CLEAR_ORDER</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_CLEAR_RNDS</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_CLEAR_WNDS</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_CLEAR_RNPS</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">OCI_TYPEMETHOD_CLEAR_WNPS</span>(OCITypeMethodFlag <em>flag</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">enum <span class="underline">OCITypeParamMode</span>;
</span></dt>
<dd><br /><br />
<dl><dt><span class="big"><span class="underline">OCI_TYPEPARAM_IN</span></span></dt>
<dd><p>In.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_TYPEPARAM_OUT</span></span></dt>
<dd><p>Out.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_TYPEPARAM_INOUT</span></span></dt>
<dd><p>Inout.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_TYPEPARAM_BYREF</span></span></dt>
<dd><p>Call by reference (implicitly in-out).
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_TYPEPARAM_OUTNCPY</span></span></dt>
<dd><p>OUT with NOCOPY modifier.
</p>

</dd>
<dt><span class="big"><span class="underline">OCI_TYPEPARAM_INOUTNCPY</span></span></dt>
<dd><p>IN OUT with NOCOPY modifier.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">const ubyte <span class="underline">OCI_NUMBER_DEFAULTPREC</span>;
</span></dt>
<dd><p>No precision specified.
</p>

</dd>
<dt><span class="big">deprecated const byte <span class="underline">OCI_NUMBER_DEFAULTSCALE</span>;
</span></dt>
<dd><p>No binary/decimal scale specified.
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_VARRAY_MAXSIZE</span>;
</span></dt>
<dd><p>Default maximum number of elements for a varray.
</p>

</dd>
<dt><span class="big">const uint <span class="underline">OCI_STRING_MAXLEN</span>;
</span></dt>
<dd><p>Default maximum length of a vstring.
</p>

</dd>
<dt><span class="big">deprecated alias <span class="underline">OCICoherency</span>;
</span></dt>
<dd><p><span class="red">Deprecated:</span><br />Only used for beta2.
</p>

</dd>
<dt><span class="big">deprecated OCIRefreshOpt <span class="underline">OCI_COHERENCY</span>;
</span></dt>
<dd><p><span class="red">Deprecated:</span><br />Only used for beta2.
</p>

</dd>
<dt><span class="big">deprecated OCIRefreshOpt <span class="underline">OCI_COHERENCY_NULL</span>;
</span></dt>
<dd><p><span class="red">Deprecated:</span><br />Only used for beta2.
</p>

</dd>
<dt><span class="big">deprecated OCIRefreshOpt <span class="underline">OCI_COHERENCY_ALWAYS</span>;
</span></dt>
<dd><p><span class="red">Deprecated:</span><br />Only used for beta2.
</p>

</dd>
</dl>

<hr />
<p><span class="small">Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. BSD license
 
</span></p>
</body>
</html>
