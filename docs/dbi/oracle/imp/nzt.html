<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<title>dbi.oracle.imp.nzt</title>
	<style type="text/css">
		.underline {
			text-decoration: underline;
		}

		.big {
			font-size: larger;
		}

		.small {
			font-size: smaller;
		}

		.red {
			color: red;
		}

		.blue {
			color: blue;
		}

		.green {
			color: green;
		}

		.yellow {
			color: yellow;
		}

		.black {
			color: black;
		}

		.white {
			color: white;
		}
	</style>
</head>
<body>
<h1>dbi.oracle.imp.nzt</h1>
<!-- Generated by Ddoc from dbi\oracle\imp\nzt.d -->
<p>Oracle import library.
</p>
<p>Part of the D DBI project.

</p>
<p><strong>Version:</strong><br />Oracle 10g revision 2
<br /><br />

	Import library version 0.03

</p>
<p><strong>Authors:</strong><br />The D DBI project

</p>

<dl><dt><span class="big">const uint <span class="underline">NZT_MAX_SHA1</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">const uint <span class="underline">NZT_MAX_MD5</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">deprecated const char[] <span class="underline">NZT_DEFAULT_WRL</span>;
</span></dt>
<dd><p>Uses directory defined by the parameter SNZD_DEFAULT_FILE_DIRECTORY which in unix is "$HOME/oracle/oss."
</p>

</dd>
<dt><span class="big">const char[] <span class="underline">NZT_SQLNET_WRL</span>;
</span></dt>
<dd><p>In this case, the directory path will be retrieved from the sqlnet.ora file under the oss.source.my_wallet parameter.
</p>

</dd>
<dt><span class="big">const char[] <span class="underline">NZT_FILE_WRL</span>;
</span></dt>
<dd><p>Find the Oracle wallet in this directory. eg: file:<dir-path>.
</p>

</dd>
<dt><span class="big">const char[] <span class="underline">NZT_ENTR_WRL</span>;
</span></dt>
<dd><p>Entrust WRL. eg: entr:<dir-path>.
</p>

</dd>
<dt><span class="big">const char[] <span class="underline">NZT_MCS_WRL</span>;
</span></dt>
<dd><p>Microsoft WRL.
</p>

</dd>
<dt><span class="big">const char[] <span class="underline">NZT_ORACLE_WRL</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">const char[] <span class="underline">NZT_REGISTRY_WRL</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">enum <span class="underline">nzttwrl</span>;
</span></dt>
<dd><br /><br />
<dl><dt><span class="big"><span class="underline">NZTTWRL_DEFAULT</span></span></dt>
<dd><p>Default, use SNZD_DEFAULT_FILE_DIRECTORY.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTWRL_SQLNET</span></span></dt>
<dd><p>Use oss.source.my_wallet in sqlnet.ora file.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTWRL_FILE</span></span></dt>
<dd><p>Find the oracle wallet in this directory.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTWRL_ENTR</span></span></dt>
<dd><p>Find the entrust profile in this directory.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTWRL_MCS</span></span></dt>
<dd><p>WRL for Microsoft.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTWRL_ORACLE</span></span></dt>
<dd><p>Get the wallet from OSS db.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTWRL_NULL</span></span></dt>
<dd><p>New SSO defaulting mechanism.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTWRL_REGISTRY</span></span></dt>
<dd><p>Find the wallet in Windows Registry.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">struct <span class="underline">nzctx</span>;
</span></dt>
<dd><br /><br />
<dl></dl>
</dd>
<dt><span class="big">struct <span class="underline">nzstrc</span>;
</span></dt>
<dd><br /><br />
<dl></dl>
</dd>
<dt><span class="big">struct <span class="underline">nzosContext</span>;
</span></dt>
<dd><br /><br />
<dl></dl>
</dd>
<dt><span class="big">struct <span class="underline">nzttIdentityPrivate</span>;
</span></dt>
<dd><br /><br />
<dl></dl>
</dd>
<dt><span class="big">struct <span class="underline">nzttPersonaPrivate</span>;
</span></dt>
<dd><br /><br />
<dl></dl>
</dd>
<dt><span class="big">struct <span class="underline">nzttWalletPrivate</span>;
</span></dt>
<dd><br /><br />
<dl></dl>
</dd>
<dt><span class="big">struct <span class="underline">nzttWalletObj</span>;
</span></dt>
<dd><p>For wallet object.
 
</p>

<dl></dl>
</dd>
<dt><span class="big">struct <span class="underline">nzssEntry</span>;
</span></dt>
<dd><p>For secretstore.
 
</p>

<dl></dl>
</dd>
<dt><span class="big">struct <span class="underline">nzpkcs11_Info</span>;
</span></dt>
<dd><br /><br />
<dl></dl>
</dd>
<dt><span class="big">enum <span class="underline">nzttces</span>;
</span></dt>
<dd><p>Crypto Engine State.
</p>
<p>Once the crypto engine (CE) has been initialized for a particular
 cipher, it is either at the initial state, or it is continuing to
 use the cipher.  NZTCES_END is used to change the state back to
 initialized and flush any remaining output.  NZTTCES_RESET can be
 used to change the state back to initialized and throw away any
 remaining output.
 
</p>

<dl><dt><span class="big"><span class="underline">NZTTCES_CONTINUE</span></span></dt>
<dd><p>Continue processing input.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTCES_END</span></span></dt>
<dd><p>End processing input.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTCES_RESET</span></span></dt>
<dd><p>Reset processing and skip generating output.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">enum <span class="underline">nzttcef</span>;
</span></dt>
<dd><p>Crypto Engine Functions.
</p>
<p>List of crypto engine categories; used to index into protection
 vector.
 
</p>

<dl><dt><span class="big"><span class="underline">NZTTCEF_DETACHEDSIGNATURE</span></span></dt>
<dd><p>Signature detached from content.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTCEF_SIGNATURE</span></span></dt>
<dd><p>Signature combined with content.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTCEF_ENVELOPING</span></span></dt>
<dd><p>Signature and encryption with content.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTCEF_PKENCRYPTION</span></span></dt>
<dd><p>Encryption for one or more recipients.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTCEF_ENCRYPTION</span></span></dt>
<dd><p>Symmetric encryption.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTCEF_KEYEDHASH</span></span></dt>
<dd><p>Keyed hash/checksum.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTCEF_HASH</span></span></dt>
<dd><p>Hash/checksum.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTCEF_RANDOM</span></span></dt>
<dd><p>Random byte generation.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTCEF_LAST</span></span></dt>
<dd><p>Used for array size.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">enum <span class="underline">nzttState</span>;
</span></dt>
<dd><p>State of the persona.
 
</p>

<dl><dt><span class="big"><span class="underline">NZTTSTATE_EMPTY</span></span></dt>
<dd><p>Is not in any state(senseless???).
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTSTATE_REQUESTED</span></span></dt>
<dd><p>Cert-request.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTSTATE_READY</span></span></dt>
<dd><p>Certificate.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTSTATE_INVALID</span></span></dt>
<dd><p>Certificate.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTSTATE_RENEWAL</span></span></dt>
<dd><p>Renewal-requested.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">enum <span class="underline">nzttVersion</span>;
</span></dt>
<dd><p>Cert-version types.
</p>
<p>This is used to quickly look-up the cert-type.
 
</p>

<dl><dt><span class="big"><span class="underline">NZTTVERSION_X509v1</span></span></dt>
<dd><p>X.509v1.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTVERSION_X509v3</span></span></dt>
<dd><p>X.509v3.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTVERSION_SYMMETRIC</span></span></dt>
<dd><p>Deprecated.  Symmetric.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTVERSION_INVALID_TYPE</span></span></dt>
<dd><p>For Initialization.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">enum <span class="underline">nzttCipherType</span>;
</span></dt>
<dd><p>Cipher Types.
</p>
<p>List of all cryptographic algorithms, some of which may not be
 available.
 
</p>

<dl><dt><span class="big"><span class="underline">NZTTCIPHERTYPE_RSA</span></span></dt>
<dd><p>RSA public key.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTCIPHERTYPE_DES</span></span></dt>
<dd><p>DES.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTCIPHERTYPE_RC4</span></span></dt>
<dd><p>RC4.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTCIPHERTYPE_MD5DES</span></span></dt>
<dd><p>DES encrypted MD5 with salt (PBE).
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTCIPHERTYPE_MD5RC2</span></span></dt>
<dd><p>RC2 encrypted MD5 with salt (PBE).
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTCIPHERTYPE_MD5</span></span></dt>
<dd><p>MD5.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTCIPHERTYPE_SHA</span></span></dt>
<dd><p>SHA.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">enum <span class="underline">nztttdufmt</span>;
</span></dt>
<dd><p>TDU Formats.
</p>
<p>List of possible toolkit data unit (TDU) formats.  Depending on the
 function and cipher used some may be not be available.
 
</p>

<dl><dt><span class="big"><span class="underline">NZTTTDUFMT_PKCS7</span></span></dt>
<dd><p>PKCS7 format.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTTDUFMT_RSAPAD</span></span></dt>
<dd><p>RSA padded format.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTTDUFMT_ORACLEv1</span></span></dt>
<dd><p>Oracle v1 format.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTTDUFMT_LAST</span></span></dt>
<dd><p>Used for array size.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">enum <span class="underline">nzttValState</span>;
</span></dt>
<dd><p>Validation States.
</p>
<p>Possible validation states an identity can be in.
 
</p>

<dl><dt><span class="big"><span class="underline">NZTTVALSTATE_NONE</span></span></dt>
<dd><p>Needs to be validated.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTVALSTATE_GOOD</span></span></dt>
<dd><p>Validated.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTVALSTATE_REVOKED</span></span></dt>
<dd><p>Failed to validate.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">enum <span class="underline">nzttPolicy</span>;
</span></dt>
<dd><p>Policy Fields.
</p>
<p>Policies enforced.
 
</p>

<dl><dt><span class="big"><span class="underline">NZTTPOLICY_NONE</span></span></dt>
<dd><p>No retries are allowed.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTPOLICY_RETRY_1</span></span></dt>
<dd><p>Number of retries for decryption = 1.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTPOLICY_RETRY_2</span></span></dt>
<dd><p>Number of retries for decryption = 2.
</p>

</dd>
<dt><span class="big"><span class="underline">NZTTPOLICY_RETRY_3</span></span></dt>
<dd><p>Number of retries for decryption = 3.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">alias <span class="underline">nzttID</span>;
</span></dt>
<dd><p>Personas and identities have unique id's that are represented with
 128 bits.
 
</p>

</dd>
<dt><span class="big">enum <span class="underline">nzttIdentType</span>;
</span></dt>
<dd><p>Identity Types
</p>
<p>List of all Identity types..
 
</p>

<dl><dt><span class="big"><span class="underline">NZTTIDENTITYTYPE_INVALID_TYPE</span></span></dt>
<dd><br /><br />
</dd>
<dt><span class="big"><span class="underline">NZTTIDENTITYTYPE_CERTIFICTAE</span></span></dt>
<dd><br /><br />
</dd>
<dt><span class="big"><span class="underline">NZTTIDENTITYTYPE_CERT_REQ</span></span></dt>
<dd><br /><br />
</dd>
<dt><span class="big"><span class="underline">NZTTIDENTITYTYPE_RENEW_CERT_REQ</span></span></dt>
<dd><br /><br />
</dd>
<dt><span class="big"><span class="underline">NZTTIDENTITYTYPE_CLEAR_ETP</span></span></dt>
<dd><br /><br />
</dd>
<dt><span class="big"><span class="underline">NZTTIDENTITYTYPE_CLEAR_UTP</span></span></dt>
<dd><br /><br />
</dd>
<dt><span class="big"><span class="underline">NZTTIDENTITYTYPE_CLEAR_PTP</span></span></dt>
<dd><br /><br />
</dd>
</dl>
</dd>
<dt><span class="big">const uint <span class="underline">NZTTKPUSAGE_SSL</span>;
</span></dt>
<dd><p>SSL Server.
</p>

</dd>
<dt><span class="big">const uint <span class="underline">NZTTKPUSAGE_SSL_CLIENT</span>;
</span></dt>
<dd><p>SSL Client.
</p>

</dd>
<dt><span class="big">alias <span class="underline">nzttTStamp</span>;
</span></dt>
<dd><p>Timestamp as 32 bit quantity in UTC.
 
</p>

</dd>
<dt><span class="big">struct <span class="underline">nzttBufferBlock</span>;
</span></dt>
<dd><p>Buffer Block.
</p>
<p>A function that needs to fill (and possibly grow) an output buffer
 uses an output parameter block to describe each buffer.
<br /><br />

 The flags_nzttBufferBlock member tells the function whether the
 buffer can be grown or not.  If flags_nzttBufferBlock is 0, then
 the buffer will be realloc'ed automatically.
<br /><br />

 The buflen_nzttBufferBLock member is set to the length of the
 buffer before the function is called and will be the length of the
 buffer when the function is finished.  If buflen_nzttBufferBlock is
 0, then the initial pointer stored in pobj_nzttBufferBlock is
 ignored.
<br /><br />

 The objlen_nzttBufferBlock member is set to the length of the
 object stored in the buffer when the function is finished.  If the
 initial buffer had a non-0 length, then it is possible that the
 object length is shorter than the buffer length.
<br /><br />

 The pobj_nzttBufferBlock member is a pointer to the output object.
 
</p>

<dl><dt><span class="big">uint <span class="underline">flags_nzttBufferBlock</span>;
</span></dt>
<dd><p>Flags.
</p>

</dd>
<dt><span class="big">uint <span class="underline">buflen_nzttBufferBlock</span>;
</span></dt>
<dd><p>Total length of buffer.
</p>

</dd>
<dt><span class="big">uint <span class="underline">usedlen_nzttBufferBlock</span>;
</span></dt>
<dd><p>Length of used buffer part.
</p>

</dd>
<dt><span class="big">ubyte* <span class="underline">buffer_nzttBufferBlock</span>;
</span></dt>
<dd><p>Pointer to buffer.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">const uint <span class="underline">NZT_NO_AUTO_REALLOC</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">struct <span class="underline">nzttWallet</span>;
</span></dt>
<dd><p>Wallet.
 
</p>

<dl><dt><span class="big">ubyte* <span class="underline">ldapName_nzttWallet</span>;
</span></dt>
<dd><p>User's LDAP name.
</p>

</dd>
<dt><span class="big">uint <span class="underline">ldapNamelen_nzttWallet</span>;
</span></dt>
<dd><p>Length of user's LDAP name.
</p>

</dd>
<dt><span class="big">nzttPolicy <span class="underline">securePolicy_nzttWallet</span>;
</span></dt>
<dd><p>Secured-policy of the wallet.
</p>

</dd>
<dt><span class="big">nzttPolicy <span class="underline">openPolicy_nzttWallet</span>;
</span></dt>
<dd><p>Open-policy of the wallet.
</p>

</dd>
<dt><span class="big">nzttPersona * <span class="underline">persona_nzttWallet</span>;
</span></dt>
<dd><p>List of personas in wallet.
</p>

</dd>
<dt><span class="big">nzttWalletPrivate * <span class="underline">private_nzttWallet</span>;
</span></dt>
<dd><p>Private wallet information.
</p>

</dd>
<dt><span class="big">uint <span class="underline">npersona_nzttWallet</span>;
</span></dt>
<dd><p>Deprecated.  Number of personas.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">struct <span class="underline">nzttPersona</span>;
</span></dt>
<dd><p>Persona.
</p>
<p>The wallet contains one or more personas.  A persona always
 contains its private key and its identity.  It may also contain
 other 3rd party identites.  All identities qualified with trust
 where the qualifier can indicate anything from untrusted to trusted
 for specific operations.
 
</p>

<dl><dt><span class="big">ubyte* <span class="underline">genericName_nzttPersona</span>;
</span></dt>
<dd><p>User-friendly persona name.
</p>

</dd>
<dt><span class="big">uint <span class="underline">genericNamelen_nzttPersona</span>;
</span></dt>
<dd><p>Persona-name length.
</p>

</dd>
<dt><span class="big">nzttPersonaPrivate * <span class="underline">private_nzttPersona</span>;
</span></dt>
<dd><p>Opaque part of persona.
</p>

</dd>
<dt><span class="big">nzttIdentity * <span class="underline">mycertreqs_nzttPersona</span>;
</span></dt>
<dd><p>My cert-requests.
</p>

</dd>
<dt><span class="big">nzttIdentity * <span class="underline">mycerts_nzttPersona</span>;
</span></dt>
<dd><p>My certificates.
</p>

</dd>
<dt><span class="big">nzttIdentity * <span class="underline">mytps_nzttPersona</span>;
</span></dt>
<dd><p>List of trusted identities.
</p>

</dd>
<dt><span class="big">nzssEntry * <span class="underline">mystore_nzttPersona</span>;
</span></dt>
<dd><p>List of secrets.
</p>

</dd>
<dt><span class="big">nzpkcs11_Info * <span class="underline">mypkcs11Info_nzttPersona</span>;
</span></dt>
<dd><p>PKCS11 token info.
</p>

</dd>
<dt><span class="big">nzttPersona * <span class="underline">next_nzttPersona</span>;
</span></dt>
<dd><p>Next persona.
</p>

</dd>
<dt><span class="big">nzttUsage <span class="underline">usage_nzttPersona</span>;
</span></dt>
<dd><p>Deprecated.  persona usage; SSL/SET/etc.
</p>

</dd>
<dt><span class="big">nzttState <span class="underline">state_nzttPersona</span>;
</span></dt>
<dd><p>Deprecated.  persona state-requested/ready.
</p>

</dd>
<dt><span class="big">uint <span class="underline">ntps_nzttPersona</span>;
</span></dt>
<dd><p>Deprecated.  Num of trusted identities.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">struct <span class="underline">nzttIdentity</span>;
</span></dt>
<dd><p>Identity.
</p>
<p>Structure containing information about an identity.
<br /><br />

 NOTE
  -- the next_trustpoint field only applies to trusted identities and
     has no meaning (i.e. is <strong>null</strong>) for self identities.
 
</p>

<dl><dt><span class="big">char* <span class="underline">dn_nzttIdentity</span>;
</span></dt>
<dd><p>Alias.
</p>

</dd>
<dt><span class="big">uint <span class="underline">dnlen_nzttIdentity</span>;
</span></dt>
<dd><p>Length of alias.
</p>

</dd>
<dt><span class="big">char* <span class="underline">comment_nzttIdentity</span>;
</span></dt>
<dd><p>Comment.
</p>

</dd>
<dt><span class="big">uint <span class="underline">commentlen_nzttIdentity</span>;
</span></dt>
<dd><p>Length of comment.
</p>

</dd>
<dt><span class="big">nzttIdentityPrivate * <span class="underline">private_nzttIdentity</span>;
</span></dt>
<dd><p>Opaque part of identity.
</p>

</dd>
<dt><span class="big">nzttIdentity * <span class="underline">next_nzttIdentity</span>;
</span></dt>
<dd><p>Next identity in list.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">struct <span class="underline">nzttB64Cert</span>;
</span></dt>
<dd><br /><br />
<dl><dt><span class="big">ubyte* <span class="underline">b64Cert_nzttB64Cert</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">uint <span class="underline">b64Certlen_nzttB64Cert</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">nzttB64Cert * <span class="underline">next_nzttB64Cert</span>;
</span></dt>
<dd><br /><br />
</dd>
</dl>
</dd>
<dt><span class="big">struct <span class="underline">nzttPKCS7ProtInfo</span>;
</span></dt>
<dd><br /><br />
<dl><dt><span class="big">nzttCipherType <span class="underline">mictype_nzttPKCS7ProtInfo</span>;
</span></dt>
<dd><p>Hash cipher.
</p>

</dd>
<dt><span class="big">nzttCipherType <span class="underline">symmtype_nzttPKCS7ProtInfo</span>;
</span></dt>
<dd><p>Symmetric cipher.
</p>

</dd>
<dt><span class="big">uint <span class="underline">keylen_nzttPKCS7ProtInfo</span>;
</span></dt>
<dd><p>Length of key to use.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">union <span class="underline">nzttProtInfo</span>;
</span></dt>
<dd><p>Protection Information.
</p>
<p>Information specific to a type of protection.
 
</p>

<dl><dt><span class="big">nzttPKCS7ProtInfo <span class="underline">pkcs7_nzttProtInfo</span>;
</span></dt>
<dd><br /><br />
</dd>
</dl>
</dd>
<dt><span class="big">struct <span class="underline">nzttPersonaDesc</span>;
</span></dt>
<dd><p>A description of a persona so that the toolkit can create one.  A
 persona can be symmetric or asymmetric and both contain an
 identity.  The identity for an asymmetric persona will be the
 certificate and the identity for the symmetric persona will be
 descriptive information about the persona.  In either case, an
 identity will have been created before the persona is created.
</p>
<p>A persona can be stored separately from the wallet that references
 it.  By default, a persona is stored with the wallet (it inherits
 with WRL used to open the wallet).  If a WRL is specified, then it
 is used to store the actuall persona and the wallet will have a
 reference to it.
 
</p>

<dl><dt><span class="big">uint <span class="underline">privlen_nzttPersonaDesc</span>;
</span></dt>
<dd><p>Length of private info (key).
</p>

</dd>
<dt><span class="big">ubyte* <span class="underline">priv_nzttPersonaDesc</span>;
</span></dt>
<dd><p>Private information.
</p>

</dd>
<dt><span class="big">uint <span class="underline">prllen_nzttPersonaDesc</span>;
</span></dt>
<dd><p>Length of PRL.
</p>

</dd>
<dt><span class="big">char* <span class="underline">prl_nzttPersonaDesc</span>;
</span></dt>
<dd><p>PRL for storage.
</p>

</dd>
<dt><span class="big">uint <span class="underline">aliaslen_nzttPersonaDesc</span>;
</span></dt>
<dd><p>Length of alias.
</p>

</dd>
<dt><span class="big">char* <span class="underline">alias_nzttPersonaDesc</span>;
</span></dt>
<dd><p>Alias.
</p>

</dd>
<dt><span class="big">uint <span class="underline">longlen_nzttPersonaDesc</span>;
</span></dt>
<dd><p>Length of longer description.
</p>

</dd>
<dt><span class="big">char* <span class="underline">long_nzttPersonaDesc</span>;
</span></dt>
<dd><p>Longer persona description.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">struct <span class="underline">nzttIdentityDesc</span>;
</span></dt>
<dd><p>A description of an identity so that the toolkit can create one.
 Since an identity can be symmetric or asymmetric, the asymmetric
 identity information will not be used when a symmetric identity is
 created.  This means the publen_nzttIdentityDesc and
 pub_nzttIdentityDesc members will not be used when creating a
 symmetric identity.
 
</p>

<dl><dt><span class="big">uint <span class="underline">publen_nzttIdentityDesc</span>;
</span></dt>
<dd><p>Length of identity.
</p>

</dd>
<dt><span class="big">ubyte* <span class="underline">pub_nzttIdentityDesc</span>;
</span></dt>
<dd><p>Type specific identity.
</p>

</dd>
<dt><span class="big">uint <span class="underline">dnlen_nzttIdentityDesc</span>;
</span></dt>
<dd><p>Length of alias.
</p>

</dd>
<dt><span class="big">char* <span class="underline">dn_nzttIdentityDesc</span>;
</span></dt>
<dd><p>Alias.
</p>

</dd>
<dt><span class="big">uint <span class="underline">longlen_nzttIdentityDesc</span>;
</span></dt>
<dd><p>Length of longer description.
</p>

</dd>
<dt><span class="big">char* <span class="underline">long_nzttIdentityDesc</span>;
</span></dt>
<dd><p>Longer description.
</p>

</dd>
<dt><span class="big">uint <span class="underline">quallen_nzttIdentityDesc</span>;
</span></dt>
<dd><p>Length of trust qualifier.
</p>

</dd>
<dt><span class="big">char* <span class="underline">trustqual_nzttIdentityDesc</span>;
</span></dt>
<dd><p>Trust qualifier.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">nzerror <span class="underline">nztwOpenWallet</span>(nzctx * <em>osscntxt</em>, uint <em>wrllen</em>, char* <em>wrl</em>, uint <em>pwdlen</em>, char* <em>pwd</em>, nzttWallet * <em>wallet</em>);
</span></dt>
<dd><p>Open a <em>wallet</em> based on a <em>wallet</em> Resource Locator (WRL).
</p>
<p>The syntax for a WRL is <Wallet Type>:<Wallet Type Parameters>.
<br /><br />

 Wallet Type	Wallet Type Parameters.
 -----------	----------------------
 File		Pathname (e.g. "file:/home/asriniva")
 Oracle	Connect string (e.g. "oracle:scott/tiger@oss")
<br /><br />

 There are also defaults.  If the WRL is NZT_DEFAULT_WRL, then
 the platform specific WRL default is used.  If only the <em>wallet</em>
 type is specified, then the WRL type specific default is used
 (e.g. "oracle:")
<br /><br />

 There is an implication with Oracle that should be stated: An
 Oracle based <em>wallet</em> can be implemented in a user's private space
 or in world readable space.
<br /><br />

 When the <em>wallet</em> is opened, the password is verified by hashing
 it and comparing against the password hash stored with the
 <em>wallet</em>.  The list of personas (and their associated identities)
 is built and stored into the <em>wallet</em> structure.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>uint <em>wrllen</em></td>
<td>Length of WRL.</td></tr>
<tr><td>char* <em>wrl</em></td>
<td>WRL.</td></tr>
<tr><td>uint <em>pwdlen</em></td>
<td>Length of password.</td></tr>
<tr><td>char* <em>pwd</em></td>
<td>Password.</td></tr>
<tr><td>nzttWallet * <em>wallet</em></td>
<td>Initialized <em>wallet</em> structure.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_RIO_OPEN	RIO could not open <em>wallet</em> (see network trace file).
	NZERROR_TK_PASSWORD	Password verification failed.
	NZERROR_TK_WRLTYPE	WRL type is not known.
	NZERROR_TK_WRLPARM	WRL parm does not match type.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztwCloseWallet</span>(nzctx * <em>osscntxt</em>, nzttWallet * <em>wallet</em>);
</span></dt>
<dd><p>Close a <em>wallet</em>.
</p>
<p>Closing a <em>wallet</em> also closes all personas associated with that
 <em>wallet</em>.  It does not cause a persona to automatically be saved
 if it has changed.  The implication is that a persona can be
 modified by an application but if it is not explicitly saved it
 reverts back to what was in the <em>wallet</em>.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttWallet * <em>wallet</em></td>
<td>Wallet.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_RIO_CLOSE	RIO could not close <em>wallet</em> (see network trace file).
 
</p>

</dd>
<dt><span class="big">deprecated nzerror <span class="underline">nztwGetCertInfo</span>(nzctx * <em>nz_context</em>, nzosContext * <em>nzosCtx</em>, nzttWallet * <em>walletRef</em>, void* <em>peerCert</em>);
</span></dt>
<dd><p>This function shouldn't be called.  It's a temporary Oracle hack.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztwRetrievePersonaCopy</span>(nzctx * <em>osscntxt</em>, nzttWallet * <em>wallet</em>, uint <em>index</em>, nzttPersona ** <em>persona</em>);
</span></dt>
<dd><p>Retrieve a <em>persona</em> from <em>wallet</em>.
</p>
<p>Retrieves a <em>persona</em> from the <em>wallet</em> based on the <em>index</em> number passed
 in.  This <em>persona</em> is a COPY of the one stored in the <em>wallet</em>, therefore
 it is perfectly fine for the <em>wallet</em> to be closed after this call is
 made.
<br /><br />

 The caller is responsible for disposing of the <em>persona</em> when completed.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttWallet * <em>wallet</em></td>
<td>Wallet.</td></tr>
<tr><td>uint <em>index</em></td>
<td>Which <em>wallet</em> <em>index</em> to remove (first <em>persona</em> is zero).</td></tr>
<tr><td>nzttPersona ** <em>persona</em></td>
<td>Persona found.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztwRetrievePersonaCopyByName</span>(nzctx * <em>osscntxt</em>, nzttWallet * <em>wallet</em>, char* <em>name</em>, nzttPersona ** <em>persona</em>);
</span></dt>
<dd><p>Retrieve a <em>persona</em> based on its <em>name</em>.
</p>
<p>Retrieves a <em>persona</em> from the <em>wallet</em> based on the <em>name</em> of the <em>persona</em>.
 This <em>persona</em> is a COPY of the one stored in the <em>wallet</em>, therefore
 it is perfectly fine for the <em>wallet</em> to be closed after this call is
 made.
<br /><br />

 The caller is responsible for disposing of the <em>persona</em> when completed.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttWallet * <em>wallet</em></td>
<td>Wallet.</td></tr>
<tr><td>char* <em>name</em></td>
<td>Name of the <em>persona</em></td></tr>
<tr><td>nzttPersona ** <em>persona</em></td>
<td>Persona found.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nzteOpenPersona</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>);
</span></dt>
<dd><p>Open a <em>persona</em>.
</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_PASSWORD	Password failed to decrypt <em>persona</em>.
	NZERROR_TK_BADPRL	Persona resource locator did not work.
	NZERROR_RIO_OPEN	Could not open <em>persona</em> (see network trace file).
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nzteClosePersona</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>);
</span></dt>
<dd><p>Close a <em>persona</em>.
</p>
<p>Closing a <em>persona</em> does not store the <em>persona</em>, it simply releases
 the memory associated with the crypto engine.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nzteDestroyPersona</span>(nzctx * <em>osscntxt</em>, nzttPersona ** <em>persona</em>);
</span></dt>
<dd><p>Destroy a <em>persona</em>.
</p>
<p>The <em>persona</em> is destroyed in the open state, but it will
 not be associated with a wallet.
<br /><br />

 The <em>persona</em> parameter is doubly indirect so that at the
 conclusion of the function, the pointer can be set to <strong>null</strong>.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona ** <em>persona</em></td>
<td>Persona.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_TYPE		Unsupported itype/ctype combination.
	NZERROR_TK_PARMS	Error in <em>persona</em> description.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nzteRetrieveTrustedIdentCopy</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, uint <em>index</em>, nzttIdentity ** <em>identity</em>);
</span></dt>
<dd><p>Retrieve a trusted <em>identity</em> from a <em>persona</em>.
</p>
<p>Retrieves a trusted <em>identity</em> from the <em>persona</em> based on the <em>index</em>
 number passed in.  This <em>identity</em> is a copy of the one stored in
 the <em>persona</em>, therefore it is perfectly fine to close the <em>persona</em>
 after this call is made.
<br /><br />

 The caller is responsible for freeing the memory of this object
 by calling nztiAbortIdentity it is no longer needed.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>uint <em>index</em></td>
<td>Which wallet <em>index</em> to remove (first element is zero).</td></tr>
<tr><td>nzttIdentity ** <em>identity</em></td>
<td>Trusted Identity from this <em>persona</em>.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztePriKey</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, ubyte** <em>vkey</em>, uint* <em>vkey_len</em>);
</span></dt>
<dd><p>Get the decrypted Private Key for the Persona.
</p>
<p>This function will only work for X.509 based <em>persona</em> which contain
 a private key.
 A copy of the private key is returned to the caller so that they do not
 have to worry about the key changing "underneath them."
 Memory will be allocated for the <em>vkey</em> and therefore, the caller
 will be responsible for freeing this memory.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>ubyte** <em>vkey</em></td>
<td>Private Key [B_KEY_OBJ].</td></tr>
<tr><td>uint* <em>vkey_len</em></td>
<td>Private Key Length.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_NO_MEMORY	ossctx is <strong>null</strong>.
	NZERROR_TK_BADPRL	Persona resource locator did not work.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nzteMyCert</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, ubyte** <em>cert</em>, uint* <em>cert_len</em>);
</span></dt>
<dd><p>Get the X.509 Certificate for a <em>persona</em>.
</p>
<p>This funiction will only work for X.509 based <em>persona</em> which contain
 a certificate for the self identity.
 A copy of the certificate is returned to the caller so that they do not
 have to worry about the certificate changing "underneath them."
 Memory will be allocated for the <em>cert</em> and therefore, the caller
 will be responsible for freeing this memory.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>ubyte** <em>cert</em></td>
<td>X.509 Certificate [BER encoded].</td></tr>
<tr><td>uint* <em>cert_len</em></td>
<td>Certificate length.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_NO_MEMORY	ossctx is <strong>null</strong>.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nzteX509CreatePersona</span>(nzctx * <em>osscntxt</em>, ubyte* <em>cert</em>, uint <em>cert_len</em>, nzttPersona ** <em>persona</em>);
</span></dt>
<dd><p>Create a <em>persona</em> gives a BER X.509 <em>cert</em>.
</p>
<p>Memory will be allocated for the <em>persona</em> and therefore, the caller
 will be responsible for freeing this memory.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>ubyte* <em>cert</em></td>
<td>X.509 Certificate [BER encoded].</td></tr>
<tr><td>uint <em>cert_len</em></td>
<td>Certificate length.</td></tr>
<tr><td>nzttPersona ** <em>persona</em></td>
<td>Persona.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_NO_MEMORY	ossctx is <strong>null</strong>.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztiCreateIdentity</span>(nzctx * <em>osscntxt</em>, nzttVersion <em>itype</em>, nzttIdentityDesc * <em>desc</em>, nzttIdentity ** <em>identity</em>);
</span></dt>
<dd><p>Create an <em>identity</em>.
</p>
<p>Memory is only allocated for the <em>identity</em> structure.  The elements in
 the description struct are not copied.  Rather their pointers are copied
 into the <em>identity</em> structure.  Therefore, the caller should not free
 the elements referenced by the description.  These elements will be freed
 when nztiDestroyIdentity is called.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttVersion <em>itype</em></td>
<td>Identity type.</td></tr>
<tr><td>nzttIdentityDesc * <em>desc</em></td>
<td>Description of <em>identity</em>.</td></tr>
<tr><td>nzttIdentity ** <em>identity</em></td>
<td>Identity.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_PARMS		Error in description.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztiAbortIdentity</span>(nzctx * <em>osscntxt</em>, nzttIdentity ** <em>identity</em>);
</span></dt>
<dd><p>Abort an unassociated <em>identity</em>.
</p>
<p>It is an error to try to abort an <em>identity</em> that can be
 referenced through a persona.
<br /><br />

 The <em>identity</em> pointer is set to <strong>null</strong> at the conclusion.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttIdentity ** <em>identity</em></td>
<td>Identity.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_CANTABORT	Identity is associated with persona.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztific_FreeIdentityContent</span>(nzctx * <em>ossctx</em>, nzttIdentity * <em>identity</em>);
</span></dt>
<dd><p>Free the contents of an <em>identity</em>.
</p>
<strong>Params:</strong><br /><table><tr><td>osscntxt</td>
<td>OSS context.</td></tr>
<tr><td>nzttIdentity * <em>identity</em></td>
<td>Identity to free.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztSign</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, nzttces <em>state</em>, uint <em>inlen</em>, ubyte* <em>input</em>, nzttBufferBlock * <em>tdubuf</em>);
</span></dt>
<dd><p>Create an attached signature.
</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Open <em>persona</em> acting as signer.</td></tr>
<tr><td>nzttces <em>state</em></td>
<td>State of signature.</td></tr>
<tr><td>uint <em>inlen</em></td>
<td>Length of this <em>input</em> part.</td></tr>
<tr><td>ubyte* <em>input</em></td>
<td>This <em>input</em> part.</td></tr>
<tr><td>nzttBufferBlock * <em>tdubuf</em></td>
<td>TDU buffer.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_CANTGROW	Needed to grow output buffer but could not.
	NZERROR_TK_NOTOPEN	Persona is not open.
	NZERROR_TK_NOTSUPP	Function not supported with <em>persona</em>.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztValidate</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, nzttIdentity * <em>identity</em>, int* <em>validated</em>);
</span></dt>
<dd><p>Validate an <em>identity</em>.
</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>nzttIdentity * <em>identity</em></td>
<td>Identity.</td></tr>
<tr><td>int* <em>validated</em></td>
<td>TRUE if <em>identity</em> was <em>validated</em>.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_NOTOPEN	Persona is not open.
	NZERROR_TK_NOTSUPP	Function not supported with <em>persona</em>.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztsd_SignDetached</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, nzttces <em>state</em>, uint <em>inlen</em>, ubyte* <em>input</em>, nzttBufferBlock * <em>tdubuf</em>);
</span></dt>
<dd><p>Generate a detached signature.
</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>nzttces <em>state</em></td>
<td>State of signature.</td></tr>
<tr><td>uint <em>inlen</em></td>
<td>Length of this <em>input</em> part.</td></tr>
<tr><td>ubyte* <em>input</em></td>
<td>The <em>input</em>.</td></tr>
<tr><td>nzttBufferBlock * <em>tdubuf</em></td>
<td>TDU buffer.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_CANTGROW	Needed to grow output buffer but could not.
	NZERROR_TK_NOTOPEN	Persona is not open.
	NZERROR_TK_NOTSUPP	Function not supported with <em>persona</em>.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztved_VerifyDetached</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, nzttces <em>state</em>, uint <em>inlen</em>, ubyte* <em>input</em>, uint <em>intdulen</em>, ubyte* <em>tdu</em>, int* <em>verified</em>, int* <em>validated</em>, nzttIdentity ** <em>identity</em>);
</span></dt>
<dd><p>Verify a detached signature.
</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>nzttces <em>state</em></td>
<td>State of verification.</td></tr>
<tr><td>uint <em>inlen</em></td>
<td>Length of data.</td></tr>
<tr><td>ubyte* <em>input</em></td>
<td>Data.</td></tr>
<tr><td>uint <em>intdulen</em></td>
<td>Input TDU length.</td></tr>
<tr><td>ubyte* <em>tdu</em></td>
<td>Input TDU.</td></tr>
<tr><td>int* <em>verified</em></td>
<td>TRUE if signature <em>verified</em>.</td></tr>
<tr><td>int* <em>validated</em></td>
<td>TRUE if signing <em>identity</em> <em>validated</em>.</td></tr>
<tr><td>nzttIdentity ** <em>identity</em></td>
<td>Identity of signing party.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_NOTOPEN	Persona is not open.
	NZERROR_TK_NOTSUPP	Function not supported with <em>persona</em>.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztkec_PKEncrypt</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, uint <em>nrecipients</em>, nzttIdentity * <em>recipients</em>, nzttces <em>state</em>, uint <em>inlen</em>, ubyte* <em>input</em>, nzttBufferBlock * <em>tdubuf</em>);
</span></dt>
<dd><p>Encrypt data symmetrically, encrypt key asymmetrically
</p>
<p>There is a limitation of 1 recipient (<em>nrecipients</em> = 1) at this time.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>uint <em>nrecipients</em></td>
<td>Number of <em>recipients</em> for this encryption.</td></tr>
<tr><td>nzttIdentity * <em>recipients</em></td>
<td>List of <em>recipients</em>.</td></tr>
<tr><td>nzttces <em>state</em></td>
<td>State of encryption.</td></tr>
<tr><td>uint <em>inlen</em></td>
<td>Length of this <em>input</em> part.</td></tr>
<tr><td>ubyte* <em>input</em></td>
<td>The <em>input</em>.</td></tr>
<tr><td>nzttBufferBlock * <em>tdubuf</em></td>
<td>TDU buffer.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_CANTGROW	Needed to grow output buffer but could not.
	NZERROR_TK_NOTOPEN	Persona is not open.
	NZERROR_TK_NOTSUPP	Function not supported with <em>persona</em>.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztxkec_PKEncryptExpansion</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, uint <em>nrecipients</em>, uint <em>inlen</em>, uint* <em>tdulen</em>);
</span></dt>
<dd><p>Determine the buffer size needed for PKEncrypt.
</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>uint <em>nrecipients</em></td>
<td>Number of recipients.</td></tr>
<tr><td>uint <em>inlen</em></td>
<td>Length of input.</td></tr>
<tr><td>uint* <em>tdulen</em></td>
<td>Length of buffer need.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_NOTOPEN	Persona is not open.
	NZERROR_TK_NOTSUPP	Function not supported with <em>persona</em>.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztkdc_PKDecrypt</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, nzttces <em>state</em>, uint <em>inlen</em>, ubyte* <em>input</em>, nzttBufferBlock * <em>tdubuf</em>);
</span></dt>
<dd><p>Decrypt a PKEncrypted message.
</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>nzttces <em>state</em></td>
<td>State of encryption.</td></tr>
<tr><td>uint <em>inlen</em></td>
<td>Length of this <em>input</em> part.</td></tr>
<tr><td>ubyte* <em>input</em></td>
<td>The <em>input</em>.</td></tr>
<tr><td>nzttBufferBlock * <em>tdubuf</em></td>
<td>TDU buffer.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_CANTGROW	Needed to grow output buffer but couldn't.
	NZERROR_TK_NOTOPEN	Persona is not open.
	NZERROR_TK_NOTSUPP	Function not supported with <em>persona</em>.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztHash</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, nzttces <em>state</em>, uint <em>inlen</em>, ubyte* <em>input</em>, nzttBufferBlock * <em>tdu</em>);
</span></dt>
<dd><p>Generate a hash.
</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>nzttces <em>state</em></td>
<td>State of hash.</td></tr>
<tr><td>uint <em>inlen</em></td>
<td>Length of this <em>input</em>.</td></tr>
<tr><td>ubyte* <em>input</em></td>
<td>The <em>input</em>.</td></tr>
<tr><td>nzttBufferBlock * <em>tdu</em></td>
<td>TDU buffer.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_CANTGROW	Needed to grow TDU buffer but could not.
	NZERROR_TK_NOTOPEN	Persona is not open.
	NZERROR_TK_NOTSUPP	Function not supported with <em>persona</em>.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztSeedRandom</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, uint <em>seedlen</em>, ubyte* <em>seed</em>);
</span></dt>
<dd><p>Seed the random function.
</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>uint <em>seedlen</em></td>
<td>Length of <em>seed</em>.</td></tr>
<tr><td>ubyte* <em>seed</em></td>
<td>Seed.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_NOTOPEN	Persona is not open.
	NZERROR_TK_NOTSUPP	Function not supported with <em>persona</em>.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztrb_RandomBytes</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, uint <em>nbytes</em>, nzttBufferBlock * <em>output</em>);
</span></dt>
<dd><p>Generate a buffer of random bytes.
</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>uint <em>nbytes</em></td>
<td>Number of bytes desired.</td></tr>
<tr><td>nzttBufferBlock * <em>output</em></td>
<td>Buffer block for bytes.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_CANTGROW	Needed to grow TDU buffer but could not.
	NZERROR_TK_NOTOPEN	Persona is not open.
	NZERROR_TK_NOTSUPP	Function not supported with <em>persona</em>.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztrn_RandomNumber</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, uint* <em>num</em>);
</span></dt>
<dd><p>Generate a random number.
</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>uint* <em>num</em></td>
<td>Number.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_NOTOPEN	Persona is not open.
	NZERROR_TK_NOTSUPP	Function not supported with <em>persona</em>.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztbbInitBlock</span>(nzctx * <em>osscntxt</em>, nzttBufferBlock * <em>block</em>);
</span></dt>
<dd><p>Initialize a buffer <em>block</em>.
</p>
<p>The buffer <em>block</em> is initialized to be empty (all members are set
 to 0/<strong>null</strong>).  Such a <em>block</em> will be allocated memory as needed.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttBufferBlock * <em>block</em></td>
<td>Buffer <em>block</em>.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztbbReuseBlock</span>(nzctx * <em>osscntxt</em>, nzttBufferBlock * <em>block</em>);
</span></dt>
<dd><p>Reuse an already initialized and possibly used <em>block</em>.
</p>
<p>This function simply sets the used length member of the buffer
 <em>block</em> to 0.  If the <em>block</em> already has memory allocated to it,
 this will cause it to be reused.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttBufferBlock * <em>block</em></td>
<td>Buffer <em>block</em>.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztbbSizeBlock</span>(nzctx * <em>osscntxt</em>, uint <em>len</em>, nzttBufferBlock * <em>block</em>);
</span></dt>
<dd><p>Resize an initialized <em>block</em> to a particular size.
</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>uint <em>len</em></td>
<td>Minimum number of unused bytes desired.</td></tr>
<tr><td>nzttBufferBlock * <em>block</em></td>
<td>Buffer <em>block</em>.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztbbGrowBlock</span>(nzctx * <em>osscntxt</em>, uint <em>inc</em>, nzttBufferBlock * <em>block</em>);
</span></dt>
<dd><p>Increase the size of a buffer <em>block</em>.
</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>uint <em>inc</em></td>
<td>Number of bytes to increase.</td></tr>
<tr><td>nzttBufferBlock * <em>block</em></td>
<td>Buffer <em>block</em>.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztbbPurgeBlock</span>(nzctx * <em>osscntxt</em>, nzttBufferBlock * <em>block</em>);
</span></dt>
<dd><p>Purge a buffer <em>block</em> of its memory.
</p>
<p>The memory used by the buffer <em>block</em> as the buffer is released.
 The buffer <em>block</em> itself is not affected.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttBufferBlock * <em>block</em></td>
<td>Buffer <em>block</em>.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztbbSetBlock</span>(nzctx * <em>osscntxt</em>, uint <em>flags</em>, uint <em>buflen</em>, uint <em>usedlen</em>, ubyte* <em>buffer</em>, nzttBufferBlock * <em>block</em>);
</span></dt>
<dd><p>Set a <em>buffer</em> <em>block</em> to a known state.
</p>
<p>If <em>buflen</em> &gt; 0, objlen == 0, and obj == <strong>null</strong>, then <em>buflen</em> bytes
 of memory is allocated and a pointer is stored in the <em>buffer</em>
 <em>block</em>.
<br /><br />

 The <em>buffer</em> parameter remains unchanged.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>uint <em>flags</em></td>
<td>Flags to set.</td></tr>
<tr><td>uint <em>buflen</em></td>
<td>Length of <em>buffer</em>.</td></tr>
<tr><td>uint <em>usedlen</em></td>
<td>Used length.</td></tr>
<tr><td>ubyte* <em>buffer</em></td>
<td>Buffer.</td></tr>
<tr><td>nzttBufferBlock * <em>block</em></td>
<td>Buffer <em>block</em>.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztiGetSecInfo</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, char** <em>dname</em>, uint* <em>dnamelen</em>, char** <em>issuername</em>, uint*, ubyte**, uint*);
</span></dt>
<dd><p>Get some security information for SSL.
</p>
<p>This function allocate memories for <em>issuername</em>, certhash, and <em>dname</em>.
 To deallocate memory for those params, you should call nztdbuf_DestroyBuf.

</p>
<p><span class="red">BUGS:</span><br />An unknown parameter is missing from the documentation.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>char** <em>dname</em></td>
<td>Distinguished name of the certificate.</td></tr>
<tr><td>uint* <em>dnamelen</em></td>
<td>Length of the distinguished name.</td></tr>
<tr><td>char** <em>issuername</em></td>
<td>Issuer name of the certificate.</td></tr>
<tr><td>certhash</td>
<td>SHA1 hash of the certificate.</td></tr>
<tr><td>certhashlen</td>
<td>Length of the hash.</td></tr>
</table>
<p><strong>Returns:</strong><br /></p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztiGetDName</span>(nzctx * <em>osscntxt</em>, nzttIdentity * <em>identity</em>, char** <em>dn</em>, uint* <em>dnlen</em>);
</span></dt>
<dd><p>Get the distinguished name for the given <em>identity</em>.
</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttIdentity * <em>identity</em></td>
<td>Identity to get dname from.</td></tr>
<tr><td>char** <em>dn</em></td>
<td>Distinguished name.</td></tr>
<tr><td>uint* <em>dnlen</em></td>
<td>Length of the dname.</td></tr>
</table>
<p><strong>Returns:</strong><br /></p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztiGetIssuerName</span>(nzctx * <em>osscntxt</em>, nzttIdentity * <em>identity</em>, char** <em>issuername</em>, uint* <em>issuernamelen</em>);
</span></dt>
<dd><p>Get the IssuerName of an <em>identity</em>.
</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttIdentity * <em>identity</em></td>
<td>Identity need to get <em>issuername</em> from</td></tr>
<tr><td>char** <em>issuername</em></td>
<td>Issuer's name</td></tr>
<tr><td>uint* <em>issuernamelen</em></td>
<td>Length of the issuer's name</td></tr>
</table>
<p><strong>Returns:</strong><br /></p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztgch_GetCertHash</span>(nzctx * <em>osscntxt</em>, nzttIdentity * <em>identity</em>, ubyte** <em>certHash</em>, uint* <em>hashLen</em>);
</span></dt>
<dd><p>Get the SHA1 hash for the certificate of an <em>identity</em>.
</p>
<p>Need to call nztdbuf_DestroyBuf to deallocate memory for <em>certHash</em>.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttIdentity * <em>identity</em></td>
<td>Identity need to get issuername from.</td></tr>
<tr><td>ubyte** <em>certHash</em></td>
<td>SHA1 hash buffer.</td></tr>
<tr><td>uint* <em>hashLen</em></td>
<td>Length of the <em>certHash</em>.</td></tr>
</table>
<p><strong>Returns:</strong><br /></p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztdbuf_DestroyBuf</span>(nzctx * <em>osscntxt</em>, void** <em>buf</em>);
</span></dt>
<dd><p>Deallocate a ub1 or text buffer.
</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>void** <em>buf</em></td>
<td>Allocated buffer to be destroyed.</td></tr>
</table>
<p><strong>Returns:</strong><br /></p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztGetCertChain</span>(nzctx * <em>osscntxt</em>, nzttWallet *);
</span></dt>
<dd><p><span class="red">BUGS:</span><br />An unknown parameter is missing from the documentation.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
</table>
<p><strong>Returns:</strong><br /></p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztCompareDN</span>(nzctx * <em>osscntxt</em>, ubyte*, uint, ubyte*, uint, int*);
</span></dt>
<dd><p><span class="red">BUGS:</span><br />An unknown parameter is missing from the documentation.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>dn1</td>
<td>Distinguished name 1.</td></tr>
<tr><td>dn2</td>
<td>Distinguished name 2.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	others			Failure.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztCheckValidity</span>(nzctx * <em>osscntxt</em>, uint <em>start_time</em>, uint <em>end_time</em>);
</span></dt>
<dd><p>Check the validity of a certificate.
</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>uint <em>start_time</em></td>
<td>Start time of the certificate.</td></tr>
<tr><td>uint <em>end_time</em></td>
<td>End time of the certificate.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	others			Failure.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztwCreateWallet</span>(nzctx * <em>osscntxt</em>, uint <em>wrllen</em>, char* <em>wrl</em>, uint <em>pwdlen</em>, char* <em>pwd</em>, nzttWallet * <em>wallet</em>);
</span></dt>
<dd><p>Create a new <em>wallet</em>.
</p>
<p>It is an error to try to create a <em>wallet</em> that already exists.  The
 existing <em>wallet</em> must be destroyed first.
<br /><br />

 The <em>wallet</em> itself is not encrypted.  Rather, all the personas in the
 <em>wallet</em> are encrypted under the same password.  A hash of the password
 is stored in the <em>wallet</em>.
<br /><br />

 Upon success, an empty open <em>wallet</em> is stored in the <em>wallet</em> parameter.

</p>
<p><span class="red">BUGS:</span><br />This function is unsupported at this time.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>uint <em>wrllen</em></td>
<td>Length of <em>wallet</em> resource locator.</td></tr>
<tr><td>char* <em>wrl</em></td>
<td>WRL.</td></tr>
<tr><td>uint <em>pwdlen</em></td>
<td>Length of password (see notes below).</td></tr>
<tr><td>char* <em>pwd</em></td>
<td>Password.</td></tr>
<tr><td>nzttWallet * <em>wallet</em></td>
<td>Wallet.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK			Success.
	NZERROR_TK_WALLET_EXISTS	Wallet already exists.
	NZERROR_RIO_OPEN		RIO could not create <em>wallet</em> (see trace file).
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztwDestroyWallet</span>(nzctx * <em>osscntxt</em>, uint <em>wrllen</em>, char* <em>wrl</em>, uint <em>pwdlen</em>, char* <em>pwd</em>);
</span></dt>
<dd><p>Destroy an existing wallet.
</p>
<p><span class="red">BUGS:</span><br />This function is unsupported at this time.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>uint <em>wrllen</em></td>
<td>Length of wallet resource locator.</td></tr>
<tr><td>char* <em>wrl</em></td>
<td>WRL.</td></tr>
<tr><td>uint <em>pwdlen</em></td>
<td>Length of password.</td></tr>
<tr><td>char* <em>pwd</em></td>
<td>Password.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_PASSWORD	Password verification failed.
	NZERROR_RIO_OPEN	RIO could not open wallet (see trace file).
	NZERROR_RIO_DELETE	Delete failed (see trace file).
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nzteStorePersona</span>(nzctx * <em>osscntxt</em>, nzttPersona ** <em>persona</em>, nzttWallet * <em>wallet</em>);
</span></dt>
<dd><p>Store an open <em>persona</em> in a <em>wallet</em>.
</p>
<p>If the open <em>persona</em> is not associated with any <em>wallet</em> (it was
 created via the nzteClosePersona function), then storing the
 <em>persona</em> creates that association.  The <em>wallet</em> will also have an
 updated <em>persona</em> list that reflects this association.
<br /><br />

 If the open <em>persona</em> was associated with <em>wallet</em> 'A' (it was
 opened via the nztwOpenWallet function), and is stored back into
 <em>wallet</em> 'A', then then the old <em>persona</em> is overwritten by the new
 <em>persona</em> if the password can be verified.  Recall that all
 personas have a unique identity id.  If that id changes then
 storing the <em>persona</em> will put a new <em>persona</em> in the <em>wallet</em>.
<br /><br />

 If the open <em>persona</em> was associated with <em>wallet</em> 'A' and is stored
 into <em>wallet</em> 'B', and if <em>wallet</em> 'B' does not contain a <em>persona</em>
 with that unique identity id, then the <em>persona</em> will be copied
 into <em>wallet</em> 'B', <em>wallet</em> 'B''s <em>persona</em> list will be updated, and
 the <em>persona</em> structure will be updated to be associated with
 <em>wallet</em> 'B'.  If <em>wallet</em> 'B' already contained the <em>persona</em>, it
 would be overwritten by the new <em>persona</em>.
<br /><br />

 The <em>persona</em> parameter is doubly indirect so that at the
 conclusion of the function call, the pointer can be directed to
 the <em>persona</em> in the <em>wallet</em>.

</p>
<p><span class="red">BUGS:</span><br />This function is unsupported at this time.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona ** <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>nzttWallet * <em>wallet</em></td>
<td>Wallet.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_PASSWORD	Password verification failed.
	NZERROR_RIO_STORE	Store failed (see network trace file).
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nzteRemovePersona</span>(nzctx * <em>osscntxt</em>, nzttPersona ** <em>persona</em>);
</span></dt>
<dd><p>Remove a <em>persona</em> from the wallet.
</p>
<p>The password is verified before trying to remove the <em>persona</em>.
<br /><br />

 If the <em>persona</em> is open, it is closed.  The <em>persona</em> is removed
 from the wallet list and the <em>persona</em> pointer is set to <strong>null</strong>.
<br /><br />

 A double indirect pointer to the <em>persona</em> is required so that the
 <em>persona</em> pointer can be set to <strong>null</strong> upon completion.

</p>
<p><span class="red">BUGS:</span><br />This function is unsupported at this time.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona ** <em>persona</em></td>
<td>Persona.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_PASSWORD	Password verification failed.
	NZERROR_RIO_DELETE	Delete failed.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nzteCreatePersona</span>(nzctx * <em>osscntxt</em>, nzttVersion <em>itype</em>, nzttCipherType <em>ctype</em>, nzttPersonaDesc * <em>desc</em>, nzttPersona ** <em>persona</em>);
</span></dt>
<dd><p>Create a <em>persona</em>.
</p>
<p>The resulting <em>persona</em> is created in the open state, but it will
 not be associated with a wallet.
<br /><br />

 The memory for the <em>persona</em> is allocated by the function.

</p>
<p><span class="red">BUGS:</span><br />This function is unsupported at this time.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttVersion <em>itype</em></td>
<td>Identity type.</td></tr>
<tr><td>nzttCipherType <em>ctype</em></td>
<td>Cipher type.</td></tr>
<tr><td>nzttPersonaDesc * <em>desc</em></td>
<td>Persona description.</td></tr>
<tr><td>nzttPersona ** <em>persona</em></td>
<td>Persona.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_TYPE		Unsupported <em>itype</em>/<em>ctype</em> combination.
	NZERROR_TK_PARMS	Error in <em>persona</em> description.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztiStoreTrustedIdentity</span>(nzctx * <em>osscntxt</em>, nzttIdentity ** <em>identity</em>, nzttPersona * <em>persona</em>);
</span></dt>
<dd><p>Store an <em>identity</em> into a <em>persona</em>.
</p>
<p>The <em>identity</em> is not saved with the <em>persona</em> in the wallet until
 the <em>persona</em> is stored.
<br /><br />

 The <em>identity</em> parameter is double indirect so that it can point
 into the <em>persona</em> at the conclusion of the call.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>Success.</td></tr>
<tr><td>nzttIdentity ** <em>identity</em></td>
<td>Trusted Identity.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nzteSetProtection</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, nzttcef <em>func</em>, nztttdufmt <em>tdufmt</em>, nzttProtInfo * <em>protinfo</em>);
</span></dt>
<dd><p>Set the protection type for a CE function.
</p>
<p><span class="red">BUGS:</span><br />This function is unsupported at this time.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>nzttcef <em>func</em></td>
<td>CE function.</td></tr>
<tr><td>nztttdufmt <em>tdufmt</em></td>
<td>TDU Format.</td></tr>
<tr><td>nzttProtInfo * <em>protinfo</em></td>
<td>Protection information specific to this format.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_PROTECTION	Unsupported protection.
	NZERROR_TK_PARMS	Error in protection info.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nzteGetProtection</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, nzttcef <em>func</em>, nztttdufmt* <em>tdufmt</em>, nzttProtInfo * <em>protinfo</em>);
</span></dt>
<dd><p>Get the protection type for a CE function.
</p>
<p><span class="red">BUGS:</span><br />This function is unsupported at this time.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>nzttcef <em>func</em></td>
<td>CE function.</td></tr>
<tr><td>nztttdufmt* <em>tdufmt</em></td>
<td>TDU format.</td></tr>
<tr><td>nzttProtInfo * <em>protinfo</em></td>
<td>Protection information.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztiRemoveIdentity</span>(nzctx * <em>osscntxt</em>, nzttIdentity ** <em>identity</em>);
</span></dt>
<dd><p>Remove an <em>identity</em> from an open persona.
</p>
<p>If the persona is not stored, this <em>identity</em> will still be in the
 persona stored in the wallet.
<br /><br />

 The <em>identity</em> parameter is doubly indirect so that at the
 conclusion of the function, the pointer can be set to <strong>null</strong>.

</p>
<p><span class="red">BUGS:</span><br />This function is unsupported at this time.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttIdentity ** <em>identity</em></td>
<td>Identity.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_NOTFOUND	Identity not found.
	NZERROR_TK_NOTOPEN	Persona is not open.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztifdn</span>(nzctx * <em>ossctx</em>, uint <em>length</em>, char* <em>distinguished_name</em>, nzttIdentity ** <em>ppidentity</em>);
</span></dt>
<dd><p>Create an Identity From a Distinguished Name.
</p>
<p>PARAMETERS
    osscntxt = OSS context.
    <em>length</em> = Length of <em>distinguished_name</em>.
    <em>distinguished_name</em> = Distinguished Name string.
    <em>ppidentity</em> = Created identity.

</p>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztxSignExpansion</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, uint <em>inlen</em>, uint* <em>tdulen</em>);
</span></dt>
<dd><p>Determine the size of the attached signature buffer.
</p>
<p><span class="red">BUGS:</span><br />This function is unsupported at this time.

</p>
<strong>Parameters:</strong>
<em>osscntxt</em> = OSS context.
	<em>persona</em> = Persona.
	<em>inlen</em> = Length of input.
	<em>tdulen</em> = Buffer needed for signature.


<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_NOTOPEN	Persona is not open.
	NZERROR_TK_NOTSUPP	Function not supported with <em>persona</em>.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztxsd_SignDetachedExpansion</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, uint <em>inlen</em>, uint* <em>tdulen</em>);
</span></dt>
<dd><p>Determine the size of buffer needed.
</p>
<p><span class="red">BUGS:</span><br />This function is unsupported at this time.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>uint <em>inlen</em></td>
<td>Length of input.</td></tr>
<tr><td>uint* <em>tdulen</em></td>
<td>Buffer needed for signature.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_NOTOPEN	Persona is not open.
	NZERROR_TK_NOTSUPP	Function not supported with <em>persona</em>.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztEncrypt</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, nzttces <em>state</em>, uint <em>inlen</em>, ubyte* <em>input</em>, nzttBufferBlock * <em>tdubuf</em>);
</span></dt>
<dd><p>Symmetrically encrypt.
</p>
<p><span class="red">BUGS:</span><br />An unknown parameter is missing from the documentation.
	This function is unsupported at this time.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>nzttces <em>state</em></td>
<td>?  Is this even <em>state</em>  ?</td></tr>
<tr><td>uint <em>inlen</em></td>
<td>Length of this <em>input</em> part.</td></tr>
<tr><td>ubyte* <em>input</em></td>
<td>This <em>input</em> part.</td></tr>
<tr><td>nzttBufferBlock * <em>tdubuf</em></td>
<td>TDU buffer.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_CANTGROW	Needed to grow TDU buffer but could not.
	NZERROR_TK_NOTOPEN	Persona is not open.
	NZERROR_TK_NOTSUPP	Function not supported with <em>persona</em>.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztxEncryptExpansion</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, uint <em>inlen</em>, uint* <em>tdulen</em>);
</span></dt>
<dd><p>Determine the size of the TDU to encrypt.
</p>
<p><span class="red">BUGS:</span><br />This function is unsupported at this time.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>uint <em>inlen</em></td>
<td>Length of this input part.</td></tr>
<tr><td>uint* <em>tdulen</em></td>
<td>Length of TDU.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_NOTOPEN	Persona is not open.
	NZERROR_TK_NOTSUPP	Function not supported with <em>persona</em>.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztDecrypt</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, nzttces <em>state</em>, uint <em>inlen</em>, ubyte* <em>input</em>, nzttBufferBlock * <em>output</em>);
</span></dt>
<dd><p>Decrypt an encrypted message.
</p>
<p><span class="red">BUGS:</span><br />This function is unsupported at this time.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>nzttces <em>state</em></td>
<td>State of decryption.</td></tr>
<tr><td>uint <em>inlen</em></td>
<td>Length of this <em>input</em> part.</td></tr>
<tr><td>ubyte* <em>input</em></td>
<td>This <em>input</em> part.</td></tr>
<tr><td>nzttBufferBlock * <em>output</em></td>
<td>Decrypted message.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK           Success.
	NZERROR_TK_CANTGROW  Needed to grow TDU buffer but could not.
	NZERROR_TK_NOTOPEN   Persona is not open.
	NZERROR_TK_NOTSUPP   Function not supported with <em>persona</em>.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztEnvelope</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, uint <em>nrecipients</em>, nzttIdentity * <em>recipients</em>, nzttces <em>state</em>, uint <em>inlen</em>, ubyte* <em>input</em>, nzttBufferBlock * <em>tdubuf</em>);
</span></dt>
<dd><p>Sign and PKEncrypt a message.
</p>
<p><span class="red">BUGS:</span><br />This function is unsupported at this time.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>uint <em>nrecipients</em></td>
<td>Number of <em>recipients</em> for this encryption.</td></tr>
<tr><td>nzttIdentity * <em>recipients</em></td>
<td>List of <em>recipients</em>.</td></tr>
<tr><td>nzttces <em>state</em></td>
<td>State of encryption.</td></tr>
<tr><td>uint <em>inlen</em></td>
<td>Length of this <em>input</em> part.</td></tr>
<tr><td>ubyte* <em>input</em></td>
<td>This <em>input</em> part.</td></tr>
<tr><td>nzttBufferBlock * <em>tdubuf</em></td>
<td>TDU buffer.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_CANTGROW	Needed to grow output buffer but could not.
	NZERROR_TK_NOTOPEN	Persona is not open.
	NZERROR_TK_NOTSUPP	Function not supported with <em>persona</em>.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztDeEnvelope</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, nzttces <em>state</em>, uint <em>inlen</em>, ubyte* <em>input</em>, nzttBufferBlock * <em>output</em>, int* <em>verified</em>, int* <em>validated</em>, nzttIdentity ** <em>sender</em>);
</span></dt>
<dd><p>PKDecrypt and verify a message.
</p>
<p><span class="red">BUGS:</span><br />This function is unsupported at this time.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>nzttces <em>state</em></td>
<td>State of encryption.</td></tr>
<tr><td>uint <em>inlen</em></td>
<td>Length of this <em>input</em> part.</td></tr>
<tr><td>ubyte* <em>input</em></td>
<td>This <em>input</em> part.</td></tr>
<tr><td>nzttBufferBlock * <em>output</em></td>
<td>Message from TDU.</td></tr>
<tr><td>int* <em>verified</em></td>
<td>TRUE if <em>verified</em>.</td></tr>
<tr><td>int* <em>validated</em></td>
<td>TRUE if <em>validated</em>.</td></tr>
<tr><td>nzttIdentity ** <em>sender</em></td>
<td>Identity of <em>sender</em>.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_CANTGROW	Needed to grow TDU buffer but could not.
	NZERROR_TK_NOTOPEN	Persona is not open.
	NZERROR_TK_NOTSUPP	Function not supported with <em>persona</em>.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztKeyedHash</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, nzttces <em>state</em>, uint <em>inlen</em>, ubyte* <em>input</em>, nzttBufferBlock * <em>tdu</em>);
</span></dt>
<dd><p>Generate a keyed hash.
</p>
<p><span class="red">BUGS:</span><br />This function is unsupported at this time.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>nzttces <em>state</em></td>
<td>State of hash.</td></tr>
<tr><td>uint <em>inlen</em></td>
<td>Length of this <em>input</em>.</td></tr>
<tr><td>ubyte* <em>input</em></td>
<td>This <em>input</em>.</td></tr>
<tr><td>nzttBufferBlock * <em>tdu</em></td>
<td>Output <em>tdu</em>.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_CANTGROW	Needed to grow TDU buffer but could not.
	NZERROR_TK_NOTOPEN	Persona is not open.
	NZERROR_TK_NOTSUPP	Function not supported with <em>persona</em>.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztxKeyedHashExpansion</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, uint <em>inlen</em>, uint* <em>tdulen</em>);
</span></dt>
<dd><p>Determine the space needed for a keyed hash.
</p>
<p><span class="red">BUGS:</span><br />This function is unsupported at this time.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>uint <em>inlen</em></td>
<td>Length of this input.</td></tr>
<tr><td>uint* <em>tdulen</em></td>
<td>TDU length.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_NOTOPEN	Persona is not open.
	NZERROR_TK_NOTSUPP	Function not supported with <em>persona</em>.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztxHashExpansion</span>(nzctx * <em>osscntxt</em>, nzttPersona * <em>persona</em>, uint <em>inlen</em>, uint* <em>tdulen</em>);
</span></dt>
<dd><p>Determine the size of the TDU for a hash.
</p>
<p><span class="red">BUGS:</span><br />This function is unsupported at this time.

</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>osscntxt</em></td>
<td>OSS context.</td></tr>
<tr><td>nzttPersona * <em>persona</em></td>
<td>Persona.</td></tr>
<tr><td>uint <em>inlen</em></td>
<td>Length of this input.</td></tr>
<tr><td>uint* <em>tdulen</em></td>
<td>TDU length.</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_NOTOPEN	Persona is not open.
	NZERROR_TK_NOTSUPP	Function not supported with <em>persona</em>.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztiae_IsAuthEnabled</span>(nzctx * <em>ctx</em>, ushort <em>ncipher</em>, int* <em>authEnabled</em>);
</span></dt>
<dd><p>Check to see if authentication is enabled in the current Cipher Spec.
</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>ctx</em></td>
<td>Oracle SSL context.</td></tr>
<tr><td>ushort <em>ncipher</em></td>
<td>CipherSuite.</td></tr>
<tr><td>int* <em>authEnabled</em></td>
<td>Boolean for is Auth Enabled?</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
      NZERROR_TK_INV_CIPHR_TYPE Cipher Spec is not recognized.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztiee_IsEncrEnabled</span>(nzctx * <em>ctx</em>, ushort <em>ncipher</em>, int* <em>encrEnabled</em>);
</span></dt>
<dd><p>Check to see if encryption is enabled in the current Cipher Spec.
</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>ctx</em></td>
<td>Oracle SSL context.</td></tr>
<tr><td>ushort <em>ncipher</em></td>
<td>CipherSuite.</td></tr>
<tr><td>int* <em>encrEnabled</em></td>
<td>Boolean for is Auth Enabled?</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
      NZERROR_TK_INV_CIPHR_TYPE Cipher Spec is not recognized.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztihe_IsHashEnabled</span>(nzctx * <em>ctx</em>, ushort <em>ncipher</em>, int* <em>hashEnabled</em>);
</span></dt>
<dd><p>Check to see if hashing is enabled in the current Cipher Spec.
</p>
<strong>Params:</strong><br /><table><tr><td>nzctx * <em>ctx</em></td>
<td>Oracle SSL context.</td></tr>
<tr><td>ushort <em>ncipher</em></td>
<td>CipherSuite.</td></tr>
<tr><td>int* <em>hashEnabled</em></td>
<td>Boolean for is Auth Enabled?</td></tr>
</table>
<p><strong>Returns:</strong><br />NZERROR_OK		Success.
	NZERROR_TK_INV_CIPHR_TYPE Cipher Spec is not recognized.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztGetIssuerName</span>(nzctx *, nzttIdentity *, ubyte**, uint*);
</span></dt>
<dd><p><span class="red">BUGS:</span><br />An unknown parameter is missing from the documentation.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztGetSubjectName</span>(nzctx *, nzttIdentity *, ubyte**, uint*);
</span></dt>
<dd><p><span class="red">BUGS:</span><br />An unknown parameter is missing from the documentation.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztGetBase64Cert</span>(nzctx *, nzttIdentity *, ubyte**, uint*);
</span></dt>
<dd><p><span class="red">BUGS:</span><br />An unknown parameter is missing from the documentation.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztGetSerialNumber</span>(nzctx *, nzttIdentity *, ubyte**, uint*);
</span></dt>
<dd><p><span class="red">BUGS:</span><br />An unknown parameter is missing from the documentation.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztGetValidDate</span>(nzctx *, nzttIdentity *, uint*, uint*);
</span></dt>
<dd><p><span class="red">BUGS:</span><br />An unknown parameter is missing from the documentation.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztGetVersion</span>(nzctx *, nzttIdentity *, nzstrc *);
</span></dt>
<dd><p><span class="red">BUGS:</span><br />An unknown parameter is missing from the documentation.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztGetPublicKey</span>(nzctx *, nzttIdentity *, ubyte**, uint*);
</span></dt>
<dd><p><span class="red">BUGS:</span><br />An unknown parameter is missing from the documentation.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztGenericDestroy</span>(nzctx *, ubyte**);
</span></dt>
<dd><p><span class="red">BUGS:</span><br />An unknown parameter is missing from the documentation.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztSetAppDefaultLocation</span>(nzctx *, char*, uint);
</span></dt>
<dd><p><span class="red">BUGS:</span><br />An unknown parameter is missing from the documentation.
 
</p>

</dd>
<dt><span class="big">nzerror <span class="underline">nztSearchNZDefault</span>(nzctx *, int*);
</span></dt>
<dd><p><span class="red">BUGS:</span><br />An unknown parameter is missing from the documentation.
 
</p>

</dd>
</dl>

<hr />
<p><span class="small">Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. BSD license
 
</span></p>
</body>
</html>
