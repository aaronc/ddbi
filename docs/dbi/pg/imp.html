<html><head>
	<META http-equiv="content-type" content="text/html; charset=utf-8">
	<title>dbi.pg.imp</title>
	</head><body>
	<h1>dbi.pg.imp</h1>
	<!-- Generated by Ddoc from dbi\pg\imp.d -->
PostgreSQL import library.
 Part of the D DBI project.
<br><br>
PostgreSQL version 8.1.4
 Import library version 1.00

<br><br>

<dl><dt><big>alias <u>pqbool</u>;
</big></dt>
<dd>This type is used with PQprint because C doesn't have a true boolean type.
 
<br><br>

</dd>
<dt><big>alias <u>Oid</u>;
</big></dt>
<dd>Object ID is a fundamental type in PostgreSQL.
 
<br><br>

</dd>
<dt><big>const uint <u>InvalidOid</u>;
</big></dt>
<dd><u>InvalidOid</u> indicates that something went wrong.  Try checking for errors.
 
<br><br>

</dd>
<dt><big>deprecated const uint <u>OID_MAX</u>;
</big></dt>
<dd><font color=red>Deprecated:</font><br>
Use Oid.max directly.
 
<br><br>

</dd>
<dt><big>const uint <u>NAMEDATALEN</u>;
</big></dt>
<dd>This is the max length for system identifiers.  It must be a multiple of int.sizeof.
<br><br>
Databases with different <u>NAMEDATALEN</u> values cannot interoperate!
 
<br><br>

</dd>
<dt><big>const char <u>PG_DIAG_SEVERITY</u>;
</big></dt>
<dd>Identifiers of error message fields.
 
<br><br>

</dd>
<dt><big>const uint <u>INV_WRITE</u>;
</big></dt>
<dd>Read/write mode flags for inversion (large object) calls.
 
<br><br>

</dd>
<dt><big>const char[] <u>PQnoPasswordSupplied</u>;
</big></dt>
<dd>Define the string so all uses are consistent.
 
<br><br>

</dd>
<dt><big>enum <u>ConnStatusType</u>;
</big></dt>
<dd><u>ConnStatusType</u> is the structure that describes the current status of the
 connection to the server.
 
<br><br>

<dl><dt><big><u>CONNECTION_OK</u></big></dt>
<dd>Everything is working.
<br><br>

</dd>
<dt><big><u>CONNECTION_BAD</u></big></dt>
<dd>Error in the connection.
<br><br>

</dd>
<dt><big><u>CONNECTION_STARTED</u></big></dt>
<dd>Waiting for connection to be made.
<br><br>

</dd>
<dt><big><u>CONNECTION_MADE</u></big></dt>
<dd>Connection OK; waiting to send.
<br><br>

</dd>
<dt><big><u>CONNECTION_AWAITING_RESPONSE</u></big></dt>
<dd>Waiting for a response from the postmaster.
<br><br>

</dd>
<dt><big><u>CONNECTION_AUTH_OK</u></big></dt>
<dd>Received authentication; waiting for backend startup.
<br><br>

</dd>
<dt><big><u>CONNECTION_SETENV</u></big></dt>
<dd>Negotiating environment.
<br><br>

</dd>
<dt><big><u>CONNECTION_SSL_STARTUP</u></big></dt>
<dd>Negotiating SSL.
<br><br>

</dd>
<dt><big><u>CONNECTION_NEEDED</u></big></dt>
<dd>Internal state: connect() needed.
<br><br>

</dd>
</dl>
</dd>
<dt><big>enum <u>PostgresPollingStatusType</u>;
</big></dt>
<dd><u>PostgresPollingStatusType</u> is the structure that describes the current status of a non-blocking command.
 
<br><br>

<dl><dt><big><u>PGRES_POLLING_FAILED</u></big></dt>
<dd>Something went wrong.
<br><br>

</dd>
<dt><big><u>PGRES_POLLING_READING</u></big></dt>
<dd>You may use select before polling again.
<br><br>

</dd>
<dt><big><u>PGRES_POLLING_WRITING</u></big></dt>
<dd>You may use select before polling again.
<br><br>

</dd>
<dt><big><u>PGRES_POLLING_OK</u></big></dt>
<dd>The work has been completed.
<br><br>

</dd>
<dt><big><u>PGRES_POLLING_ACTIVE</u></big></dt>
<dd>Unused; keep for awhile for backwards compatibility.
<br><br>

</dd>
</dl>
</dd>
<dt><big>enum <u>ExecStatusType</u>;
</big></dt>
<dd><u>ExecStatusType</u> is the structure that describes the results.
 
<br><br>

<dl><dt><big><u>PGRES_EMPTY_QUERY</u></big></dt>
<dd>Empty query string was executed.
<br><br>

</dd>
<dt><big><u>PGRES_COMMAND_OK</u></big></dt>
<dd>A query command that doesn't return anything was executed properly by the backend.
<br><br>

</dd>
<dt><big><u>PGRES_TUPLES_OK</u></big></dt>
<dd>A query command that returns tuples was executed properly by the backend, PGresult contains the result tuples.
<br><br>

</dd>
<dt><big><u>PGRES_COPY_OUT</u></big></dt>
<dd>Copy Out data transfer in progress.
<br><br>

</dd>
<dt><big><u>PGRES_COPY_IN</u></big></dt>
<dd>Copy In data transfer in progress.
<br><br>

</dd>
<dt><big><u>PGRES_BAD_RESPONSE</u></big></dt>
<dd>An unexpected response was received from the backend.
<br><br>

</dd>
<dt><big><u>PGRES_NONFATAL_ERROR</u></big></dt>
<dd>Notice or warning message.
<br><br>

</dd>
<dt><big><u>PGRES_FATAL_ERROR</u></big></dt>
<dd>Query failed.
<br><br>

</dd>
</dl>
</dd>
<dt><big>enum <u>PGTransactionStatusType</u>;
</big></dt>
<dd><u>PGTransactionStatusType</u> is the structure that describes the current status of the transaction.
 
<br><br>

<dl><dt><big><u>PQTRANS_IDLE</u></big></dt>
<dd>Connection idle.
<br><br>

</dd>
<dt><big><u>PQTRANS_ACTIVE</u></big></dt>
<dd>Command in progress.
<br><br>

</dd>
<dt><big><u>PQTRANS_INTRANS</u></big></dt>
<dd>Idle, within transaction block.
<br><br>

</dd>
<dt><big><u>PQTRANS_INERROR</u></big></dt>
<dd>Idle, within failed transaction.
<br><br>

</dd>
<dt><big><u>PQTRANS_UNKNOWN</u></big></dt>
<dd>Cannot determine status.
<br><br>

</dd>
</dl>
</dd>
<dt><big>enum <u>PGVerbosity</u>;
</big></dt>
<dd><u>PGVerbosity</u> is the structure that describes how verbose error message should be.
 
<br><br>

<dl><dt><big><u>PQERRORS_TERSE</u></big></dt>
<dd>Single-line error messages.
<br><br>

</dd>
<dt><big><u>PQERRORS_DEFAULT</u></big></dt>
<dd>Recommended style.
<br><br>

</dd>
<dt><big><u>PQERRORS_VERBOSE</u></big></dt>
<dd>All the facts.
<br><br>

</dd>
</dl>
</dd>
<dt><big>struct <u>PGconn</u>;
</big></dt>
<dd><u>PGconn</u> encapsulates a connection to the backend.
 The contents of this struct are not supposed to be known to applications.
 
<br><br>

<dl></dl>
</dd>
<dt><big>struct <u>PGresult</u>;
</big></dt>
<dd><u>PGresult</u> encapsulates the result of a query (or more precisely, of a single
 SQL command --- a query string given to PQsendQuery can contain multiple
 commands and thus return multiple <u>PGresult</u> objects).
 The contents of this struct are not supposed to be known to applications.
 
<br><br>

<dl></dl>
</dd>
<dt><big>struct <u>PGcancel</u>;
</big></dt>
<dd><u>PGcancel</u> encapsulates the information needed to cancel a running
 query on an existing connection.
 The contents of this struct are not supposed to be known to applications.
 
<br><br>

<dl></dl>
</dd>
<dt><big>struct <u>pgNotify</u>;
</big></dt>
<dd>PGnotify represents the occurrence of a NOTIFY message.
 Ideally this would be an opaque typedef, but it's so simple that it's
 unlikely to change.
<br><br>
<b>NOTE:</b><br>
In Postgres 6.4 and later, the be_pid is the notifying backend's,
 whereas in earlier versions it was always your own backend's PID.
 
<br><br>

<dl><dt><big>char* <u>relname</u>;
</big></dt>
<dd>Notification condition name.
<br><br>

</dd>
<dt><big>int <u>be_pid</u>;
</big></dt>
<dd>Process ID of server process.
<br><br>

</dd>
<dt><big>char* <u>extra</u>;
</big></dt>
<dd>Notification parameter.
<br><br>

</dd>
<dt><big>pgNotify * <u>next</u>;
</big></dt>
<dd>List link.
<br><br>

</dd>
</dl>
</dd>
<dt><big>alias <u>PQnoticeReceiver</u>;
</big></dt>
<dd>Function types for notice-handling callbacks.
 
<br><br>

</dd>
<dt><big>struct <u>_PQprintOpt</u>;
</big></dt>
<dd>Print options for PQprint().
 
<br><br>

<dl><dt><big>byte <u>header</u>;
</big></dt>
<dd>Print output field headings and row count.
<br><br>

</dd>
<dt><big>byte <u>alignment</u>;
</big></dt>
<dd>Fill align the fields.
<br><br>

</dd>
<dt><big>byte <u>standard</u>;
</big></dt>
<dd>Old brain dead format.
<br><br>

</dd>
<dt><big>byte <u>html3</u>;
</big></dt>
<dd>Output html tables.
<br><br>

</dd>
<dt><big>byte <u>expanded</u>;
</big></dt>
<dd>Expand tables.
<br><br>

</dd>
<dt><big>byte <u>pager</u>;
</big></dt>
<dd>Use <u>pager</u> for output if needed.
<br><br>

</dd>
<dt><big>char* <u>fieldSep</u>;
</big></dt>
<dd>Field separator.
<br><br>

</dd>
<dt><big>char* <u>tableOpt</u>;
</big></dt>
<dd>Insert a table in HTML.
<br><br>

</dd>
<dt><big>char* <u>caption</u>;
</big></dt>
<dd>Insert a <u>caption</u> in HTML.
<br><br>

</dd>
<dt><big>char** <u>fieldName</u>;
</big></dt>
<dd>Null terminated array of replacement field names.
<br><br>

</dd>
</dl>
</dd>
<dt><big>struct <u>_PQconninfoOption</u>;
</big></dt>
<dd>Structure for the conninfo parameter definitions returned by PQconndefaults
<br><br>
All fields except "val" point at static strings which must not be altered.
 "val" is either NULL or a malloc'd current-value string.  PQconninfoFree()
 will release both the val strings and the PQconninfoOption array itself.
 
<br><br>

<dl><dt><big>char* <u>keyword</u>;
</big></dt>
<dd>The <u>keyword</u> of the option.
<br><br>

</dd>
<dt><big>char* <u>envvar</u>;
</big></dt>
<dd>Fallback environment variable name.
<br><br>

</dd>
<dt><big>char* <u>compiled</u>;
</big></dt>
<dd>Fallback <u>compiled</u> in default value.
<br><br>

</dd>
<dt><big>char* <u>val</u>;
</big></dt>
<dd>Option's current value, or <b>null</b>.
<br><br>

</dd>
<dt><big>char* <u>label</u>;
</big></dt>
<dd>Label for field in connect dialog.
<br><br>

</dd>
<dt><big>char* <u>dispchar</u>;
</big></dt>
<dd>Character to display for this field in a connect dialog. Values are: "" Display entered value as is "*" Password field - hide value "D"  Debug option - don't show by default.
<br><br>

</dd>
<dt><big>int <u>dispsize</u>;
</big></dt>
<dd>Field size in characters for dialog.
<br><br>

</dd>
</dl>
</dd>
<dt><big>struct <u>PQArgBlock</u>;
</big></dt>
<dd><u>PQArgBlock</u> is the structure used for PQfn arguments.
<br><br>
<font color=red>Deprecated:</font><br>
This is only used for PQfn and that is deprecated.
 
<br><br>

<dl></dl>
</dd>
<dt><big>PGconn * <u>PQconnectStart</u>(char* <i>conninfo</i>);
</big></dt>
<dd>Make a new connection to the database server in a nonblocking manner.
<br><br>
<b>Params:</b><br>
<table><tr><td>char* <i>conninfo</i></td>
<td>Parameters to use when connecting.</td></tr>
</table><br>
<b>Returns:</b><br>
A PostgreSQL connection that is inactive.

<br><br>
<b>See Also:</b><br>
The online PostgreSQL documentation describes what you can use in <i>conninfo</i>.
 
<br><br>

</dd>
<dt><big>PostgresPollingStatusType <u>PQconnectPoll</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Get the current status of the nonblocking PostgreSQL connection.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The nonblocking PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
A PostgrePollingStatusType describing the current condition of the connection.
 
<br><br>

</dd>
<dt><big>PGconn * <u>PQconnectdb</u>(char* <i>conninfo</i>);
</big></dt>
<dd>Make a new connection to the database server in a blocking manner.
<br><br>
<b>Params:</b><br>
<table><tr><td>char* <i>conninfo</i></td>
<td>Parameters to use when connecting.</td></tr>
</table><br>
<b>Returns:</b><br>
The PostgreSQL connection.

<br><br>
<b>See Also:</b><br>
The online PostgreSQL documentation describes what you can use in <i>conninfo</i>.
 
<br><br>

</dd>
<dt><big>PGconn * <u>PQsetdbLogin</u>(char* <i>pghost</i>, char* <i>pgport</i>, char* <i>pgoptions</i>, char* <i>pgtty</i>, char* <i>dbName</i>, char* <i>login</i>, char* <i>pwd</i>);
</big></dt>
<dd>Make a new connection to the database server in a blocking manner.
<br><br>
<font color=red>Deprecated:</font><br>
Although this isn't actually deprecated, it is preferred that you use PQconnectdb.

<br><br>
<b>Params:</b><br>
<table><tr><td>char* <i>pghost</i></td>
<td>Name of the host to connect to.  Defaults to either a Unix socket or localhost.</td></tr>
<tr><td>char* <i>pgport</i></td>
<td>Port number to connect to the server with.  Defaults to nothing.</td></tr>
<tr><td>char* <i>pgoptions</i></td>
<td>Command line options to send to the server.  Defaults to nothing.</td></tr>
<tr><td>char* <i>pgtty</i></td>
<td>Currently ignored.</td></tr>
<tr><td>char* <i>dbName</i></td>
<td>The name of the database to use.  Defaults to <i>login</i>.</td></tr>
<tr><td>char* <i>login</i></td>
<td>Username to authenticate with.  Defaults to the current OS username.</td></tr>
<tr><td>char* <i>pwd</i></td>
<td>Password to authenticate with.</td></tr>
</table><br>
<b>Returns:</b><br>
The PostgreSQL connection.
 
<br><br>

</dd>
<dt><big>deprecated void <u>PQsetdb</u>(char* <i>M_PGHOST</i>, char* <i>M_PGPORT</i>, char* <i>M_PGOPT</i>, char* <i>M_PGTTY</i>, char* <i>M_DBNAME</i>);
</big></dt>
<dd>Make a new connection to the database server in a blocking manner.
<br><br>
<font color=red>Deprecated:</font><br>
This is deprecated in favor of PQsetdbLogin, but PQconnectdb is an even better choice.

<br><br>
<b>Params:</b><br>
<table><tr><td>pghost</td>
<td>Name of the host to connect to.  Defaults to either a Unix socket or localhost.</td></tr>
<tr><td>pgport</td>
<td>Port number to connect to the server with.  Defaults to nothing.</td></tr>
<tr><td>pgoptions</td>
<td>Command line options to send to the server.  Defaults to nothing.</td></tr>
<tr><td>pgtty</td>
<td>Currently ignored.</td></tr>
<tr><td>dbName</td>
<td>The name of the database to use.  Defaults to the login username.</td></tr>
</table><br>
<b>Returns:</b><br>
The PostgreSQL connection.
 
<br><br>

</dd>
<dt><big>void <u>PQfinish</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Close the PostgreSQL connection and free the memory it used.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>

</dd>
<dt><big>_PQconninfoOption * <u>PQconndefaults</u>();
</big></dt>
<dd>Get the default connection options.
<br><br>
<b>Returns:</b><br>
A PQconninfoOption structure with all of the default values filled in.
 
<br><br>

</dd>
<dt><big>void <u>PQconninfoFree</u>(_PQconninfoOption * <i>connOptions</i>);
</big></dt>
<dd>Free the memory used by a PQconninfoOption structure.
<br><br>
<b>Params:</b><br>
<table><tr><td>_PQconninfoOption * <i>connOptions</i></td>
<td>The PQconnifoOption structure to erase.</td></tr>
</table><br>

</dd>
<dt><big>int <u>PQresetStart</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Reset the connection to PostgreSQL in a nonblocking manner.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
1 on success and 0 on failure.
 
<br><br>

</dd>
<dt><big>PostgresPollingStatusType <u>PQresetPoll</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Get the current status of the nonblocking reset of the PostgreSQL connection.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
A PostgrePollingStatusType describing the current condition of the connection.
 
<br><br>

</dd>
<dt><big>void <u>PQreset</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Reset the connection to PostgreSQL in a blocking manner.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>

</dd>
<dt><big>PGcancel * <u>PQgetCancel</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Create the structure used to cancel commands.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
The PGcancel structure on success or <b>null</b> on failure.
 
<br><br>

</dd>
<dt><big>void <u>PQfreeCancel</u>(PGcancel * <i>cancel</i>);
</big></dt>
<dd>Free the memory used by a PGcancel structure.
<br><br>
<b>Params:</b><br>
<table></table><br>

</dd>
<dt><big>int <u>PQcancel</u>(PGcancel * <i>cancel</i>, char* <i>errbuf</i>, int <i>errbufsize</i>);
</big></dt>
<dd>Request that the server stops processing the current command.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGcancel * <i>cancel</i></td>
<td>The PGcancel structure returned by PQgetCancel.</td></tr>
<tr><td>char* <i>errbuf</i></td>
<td>A buffer to place the reason <u>PQcancel</u> failed in.</td></tr>
<tr><td>int <i>errbufsize</i></td>
<td>The size of <i>errbuf</i>.  The recommended size is 256.</td></tr>
</table><br>
<b>Returns:</b><br>
1 on success and 0 on failure.
 
<br><br>

</dd>
<dt><big>deprecated int <u>PQrequestCancel</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Request that the server stops processing the current command.
<br><br>
<font color=red>Deprecated:</font><br>
PQcancel should be used instead because it is thread-safe.

<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>

</dd>
<dt><big>char* <u>PQdb</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Get the name of the database used in the connection.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
The database name.
 
<br><br>

</dd>
<dt><big>char* <u>PQuser</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Get the username used in the connection.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
The username.
 
<br><br>

</dd>
<dt><big>char* <u>PQpass</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Get the password used in the connection.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
The password.
 
<br><br>

</dd>
<dt><big>char* <u>PQhost</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Get the server host name used in the connection.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
The server host name.
 
<br><br>

</dd>
<dt><big>char* <u>PQport</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Get the port used in the connection.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
The port.
 
<br><br>

</dd>
<dt><big>deprecated char* <u>PQtty</u>(PGconn * <i>conn</i>);
</big></dt>
<dd><font color=red>Deprecated:</font><br>
This no longer has any effect.  Don't use it.
 
<br><br>

</dd>
<dt><big>char* <u>PQoptions</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Get the command line options used in the connection.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
The command line options.
 
<br><br>

</dd>
<dt><big>ConnStatusType <u>PQstatus</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Get the status of the connection.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
A ConnStatusType value describing the current connection.
 
<br><br>

</dd>
<dt><big>PGTransactionStatusType <u>PQtransactionStatus</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Get the current in-transaction status of the server.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
A PGTransactionStatusType value describing the status of the transaction.
 
<br><br>

</dd>
<dt><big>char* <u>PQparameterStatus</u>(PGconn * <i>conn</i>, char* <i>paramName</i>);
</big></dt>
<dd>Get the current parameter settings of the server.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
A string containing various parameter settings of the server.

<br><br>
<b>See Also:</b><br>
The online PostgreSQL documentation describes what is in the returned string.
 
<br><br>

</dd>
<dt><big>int <u>PQprotocolVersion</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Get the version of the protocol used in the connection.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
The protocol version.
 
<br><br>

</dd>
<dt><big>int <u>PQserverVersion</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Get the version of PostgreSQL used by the server..
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
The version of PostgreSQL.
 
<br><br>

</dd>
<dt><big>char* <u>PQerrorMessage</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Get the most recent error message from the connection.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
The most recent error message.
 
<br><br>

</dd>
<dt><big>int <u>PQsocket</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Get the socket used in the connection.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
The number that represents the socket.  A negative number is returned if no connection is open.
 
<br><br>

</dd>
<dt><big>int <u>PQbackendPID</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Get the PID of PostgreSQL on the server..
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
The PID.
 
<br><br>

</dd>
<dt><big>int <u>PQclientEncoding</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Get the character encoding currently being used.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
The integer representation of the character encoding.
 
<br><br>

</dd>
<dt><big>int <u>PQsetClientEncoding</u>(PGconn * <i>conn</i>, char* <i>encoding</i>);
</big></dt>
<dd>Change the character <i>encoding</i> used in the connection.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <i>encoding</i></td>
<td>The string representation of the desired character encoding.</td></tr>
</table><br>
<b>Returns:</b><br>
0 on success and -1 on failure.
 
<br><br>

</dd>
<dt><big>void* <u>PQgetssl</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Get the SSL structure associated with a connection.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
The SSL structure used in the connection or <b>null</b> if SSL is not in use.
 
<br><br>

</dd>
<dt><big>void <u>PQinitSSL</u>(int <i>do_init</i>);
</big></dt>
<dd>Tell the interface that SSL has already been initialized within your application.
<br><br>
<b>Params:</b><br>
<table><tr><td>int <i>do_init</i></td>
<td>Set to 1 if you use SSL within your application and 0 otherwise.</td></tr>
</table><br>

</dd>
<dt><big>PGVerbosity <u>PQsetErrorVerbosity</u>(PGconn * <i>conn</i>, PGVerbosity <i>verbosity</i>);
</big></dt>
<dd>Set how verbose the error messages should be.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>PGVerbosity <i>verbosity</i></td>
<td>A PGVerbosity value of the desired setting.</td></tr>
</table><br>
<b>Returns:</b><br>
A PGVerbosity value with the previous setting.
 
<br><br>

</dd>
<dt><big>void <u>PQtrace</u>(PGconn * <i>conn</i>, _iobuf * <i>debug_port</i>);
</big></dt>
<dd>Start copying all of the communications with the server to a stream.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>_iobuf * <i>debug_port</i></td>
<td>The CStream to send the data to.</td></tr>
</table><br>

</dd>
<dt><big>void <u>PQuntrace</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Stop copying all of the communications with the server to a stream.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>

</dd>
<dt><big>void(* <u>PQsetNoticeReceiver</u>(PGconn * <i>conn</i>, void(* <i>proc</i>)(void* <i>arg</i>, PGresult * res), void* <i>arg</i>))(void* <i>arg</i>, PGresult * res);
</big></dt>
<dd>Change the function that formats the notices.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>void(* <i>proc</i>)(void* <i>arg</i>, PGresult * res)</td>
<td>The new function.</td></tr>
<tr><td>void* <i>arg</i></td>
<td>Arguments to pass to the function whenever it is called.</td></tr>
</table><br>
<b>Returns:</b><br>
The previous function.
 
<br><br>

</dd>
<dt><big>void(* <u>PQsetNoticeProcessor</u>(PGconn * <i>conn</i>, void(* <i>proc</i>)(void* <i>arg</i>, char* message), void* <i>arg</i>))(void* <i>arg</i>, char* message);
</big></dt>
<dd>Change the function that handles the notices.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>void(* <i>proc</i>)(void* <i>arg</i>, char* message)</td>
<td>The new function.</td></tr>
<tr><td>void* <i>arg</i></td>
<td>Arguments to pass to the function whenever it is called.</td></tr>
</table><br>
<b>Returns:</b><br>
The previous function.
 
<br><br>

</dd>
<dt><big>alias <u>pgthreadlock_t</u>;
</big></dt>
<dd>Used to set callback that prevents concurrent access to
 non-thread safe functions that libpq needs.
 The default implementation uses a libpq internal mutex.
 Only required for multithreaded apps that use kerberos
 both within their app and for postgresql connections.
 
<br><br>

</dd>
<dt><big>void(* <u>PQregisterThreadLock</u>(void(* <i>newhandler</i>)(int acquire)))(int acquire);
</big></dt>
<dd><br><br>
</dd>
<dt><big>PGresult * <u>PQexec</u>(PGconn * <i>conn</i>, char* <i>query</i>);
</big></dt>
<dd>Submit a command to the server and wait for the results.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <i>query</i></td>
<td>The SQL command(s) to execute.</td></tr>
</table><br>
<b>Results:</b><br>
A PGresult structure containing the results or <b>null</b> on a serious error.
 
<br><br>

</dd>
<dt><big>PGresult * <u>PQexecParams</u>(PGconn * <i>conn</i>, char* <i>command</i>, int <i>nParams</i>, uint* <i>paramTypes</i>, char** <i>paramValues</i>, int* <i>paramLengths</i>, int* <i>paramFormats</i>, int <i>resultFormat</i>);
</big></dt>
<dd>Submit a <i>command</i> to the server and wait for the results.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <i>command</i></td>
<td>The SQL command to execute.</td></tr>
<tr><td>int <i>nParams</i></td>
<td>The number of parameters.</td></tr>
<tr><td>uint* <i>paramTypes</i></td>
<td>An array of types specified using Oid.  Use <b>null</b> or 0 to have the server guess.</td></tr>
<tr><td>char** <i>paramValues</i></td>
<td>The parameters themselves in the expected format.</td></tr>
<tr><td>int* <i>paramLengths</i></td>
<td>An array of lengths of the parameters.  This is ignored for non-binary data.</td></tr>
<tr><td>int* <i>paramFormats</i></td>
<td>An array of formats of the parameters.  Use 0 for text and 1 for binary.</td></tr>
<tr><td>int <i>resultFormat</i></td>
<td>Use 0 to obtain the results in text format and 1 for binary.</td></tr>
</table><br>
<b>Returns:</b><br>
A PGresult structure containing the results or <b>null</b> on a serious error.
 
<br><br>

</dd>
<dt><big>PGresult * <u>PQprepare</u>(PGconn * <i>conn</i>, char* <i>stmtName</i>, char* <i>query</i>, int <i>nParams</i>, uint* <i>paramTypes</i>);
</big></dt>
<dd>Create a prepared statement and wait for completion.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <i>stmtName</i></td>
<td>The name to assign to the prepared statement.</td></tr>
<tr><td>char* <i>query</i></td>
<td>The SQL command to prepare.</td></tr>
<tr><td>int <i>nParams</i></td>
<td>The number of parameters.</td></tr>
<tr><td>uint* <i>paramTypes</i></td>
<td>An array of types specified using Oid.  Use <b>null</b> or 0 to have the server guess.</td></tr>
</table><br>
<b>Results:</b><br>
A PGresult structure containing the results or <b>null</b> on a serious error.
 
<br><br>

</dd>
<dt><big>PGresult * <u>PQexecPrepared</u>(PGconn * <i>conn</i>, char* <i>stmtName</i>, int <i>nParams</i>, char** <i>paramValues</i>, int* <i>paramLengths</i>, int* <i>paramFormats</i>, int <i>resultFormat</i>);
</big></dt>
<dd>Execute a prepared statement and wait for the results.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <i>stmtName</i></td>
<td>The name of the prepared statement to execute.</td></tr>
<tr><td>int <i>nParams</i></td>
<td>The number of parameters.</td></tr>
<tr><td>char** <i>paramValues</i></td>
<td>The parameters themselves in the expected format.</td></tr>
<tr><td>int* <i>paramLengths</i></td>
<td>An array of lengths of the parameters.  This is ignored for non-binary data.</td></tr>
<tr><td>int* <i>paramFormats</i></td>
<td>An array of formats of the parameters.  Use 0 for text and 1 for binary.</td></tr>
<tr><td>int <i>resultFormat</i></td>
<td>Use 0 to obtain the results in text format and 1 for binary.</td></tr>
</table><br>
<b>Results:</b><br>
A PGresult structure containing the results or <b>null</b> on a serious error.
 
<br><br>

</dd>
<dt><big>int <u>PQsendQuery</u>(PGconn * <i>conn</i>, char* <i>query</i>);
</big></dt>
<dd>Submit a command to the server without waiting for the results.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <i>query</i></td>
<td>The SQL command(s) to execute.</td></tr>
</table><br>
<b>Returns:</b><br>
1 on success or 0 on failure.
 
<br><br>

</dd>
<dt><big>int <u>PQsendQueryParams</u>(PGconn * <i>conn</i>, char* <i>command</i>, int <i>nParams</i>, uint* <i>paramTypes</i>, char** <i>paramValues</i>, int* <i>paramLengths</i>, int* <i>paramFormats</i>, int <i>resultFormat</i>);
</big></dt>
<dd>Submit a command to the server without waiting for the results.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <i>command</i></td>
<td>The SQL command to execute.</td></tr>
<tr><td>int <i>nParams</i></td>
<td>The number of parameters.</td></tr>
<tr><td>uint* <i>paramTypes</i></td>
<td>An array of types specified using Oid.  Use <b>null</b> or 0 to have the server guess.</td></tr>
<tr><td>char** <i>paramValues</i></td>
<td>The parameters themselves in the expected format.</td></tr>
<tr><td>int* <i>paramLengths</i></td>
<td>An array of lengths of the parameters.  This is ignored for non-binary data.</td></tr>
<tr><td>int* <i>paramFormats</i></td>
<td>An array of formats of the parameters.  Use 0 for text and 1 for binary.</td></tr>
<tr><td>int <i>resultFormat</i></td>
<td>Use 0 to obtain the results in text format and 1 for binary.</td></tr>
</table><br>
<b>Returns:</b><br>
1 on success or 0 on failure.
 
<br><br>

</dd>
<dt><big>int <u>PQsendPrepare</u>(PGconn * <i>conn</i>, char* <i>stmtName</i>, char* <i>query</i>, int <i>nParams</i>, uint* <i>paramTypes</i>);
</big></dt>
<dd>Create a prepared statement without waiting for completion.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <i>stmtName</i></td>
<td>The name to assign to the prepared statement.</td></tr>
<tr><td>char* <i>query</i></td>
<td>The SQL command to prepare.</td></tr>
<tr><td>int <i>nParams</i></td>
<td>The number of parameters.</td></tr>
<tr><td>uint* <i>paramTypes</i></td>
<td>An array of types specified using Oid.  Use <b>null</b> or 0 to have the server guess.</td></tr>
</table><br>
<b>Returns:</b><br>
1 on success or 0 on failure.
 
<br><br>

</dd>
<dt><big>int <u>PQsendQueryPrepared</u>(PGconn * <i>conn</i>, char* <i>stmtName</i>, int <i>nParams</i>, char** <i>paramValues</i>, int* <i>paramLengths</i>, int* <i>paramFormats</i>, int <i>resultFormat</i>);
</big></dt>
<dd>Execute a prepared statement without waiting for the results.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <i>stmtName</i></td>
<td>The name of the prepared statement to execute.</td></tr>
<tr><td>int <i>nParams</i></td>
<td>The number of parameters.</td></tr>
<tr><td>char** <i>paramValues</i></td>
<td>The parameters themselves in the expected format.</td></tr>
<tr><td>int* <i>paramLengths</i></td>
<td>An array of lengths of the parameters.  This is ignored for non-binary data.</td></tr>
<tr><td>int* <i>paramFormats</i></td>
<td>An array of formats of the parameters.  Use 0 for text and 1 for binary.</td></tr>
<tr><td>int <i>resultFormat</i></td>
<td>Use 0 to obtain the results in text format and 1 for binary.</td></tr>
</table><br>
<b>Returns:</b><br>
1 on success or 0 on failure.
 
<br><br>

</dd>
<dt><big>PGresult * <u>PQgetResult</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Get the current result set.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
A PGresult structure describing the current status or <b>null</b> if no command is being processed.
 
<br><br>

</dd>
<dt><big>int <u>PQisBusy</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Determine if the server is currently busy with a command.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
1 if a command is busy and 0 if it is safe to call PQgetResult.
 
<br><br>

</dd>
<dt><big>int <u>PQconsumeInput</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Get any input from the server.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
1 on success and 0 on failure.
 
<br><br>

</dd>
<dt><big>pgNotify * <u>PQnotifies</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Get the next unhandled notification event.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
The PGnotify structure representing the notification event.
 
<br><br>

</dd>
<dt><big>int <u>PQputCopyData</u>(PGconn * <i>conn</i>, char* <i>buffer</i>, int <i>nbytes</i>);
</big></dt>
<dd>Send data to the server after a copy command.
<br><br>
This function will only be unable to send the data if nonblocking is set.

<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <i>buffer</i></td>
<td>The data to send to the server.</td></tr>
<tr><td>int <i>nbytes</i></td>
<td>The length of <i>buffer</i>.</td></tr>
</table><br>
<b>Returns:</b><br>
1 on success, -1 on failure, or 0 if the data wasn't sent.
 
<br><br>

</dd>
<dt><big>int <u>PQputCopyEnd</u>(PGconn * <i>conn</i>, char* <i>errormsg</i>);
</big></dt>
<dd>Tell the server that no more data needs to be copied.
<br><br>
This function will only be unable to send the data if nonblocking is set.

<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <i>errormsg</i></td>
<td><b>null</b> on success and the error message on failure.</td></tr>
</table><br>
<b>Returns:</b><br>
1 on success, -1 on failure, or 0 if the data wasn't sent.
 
<br><br>

</dd>
<dt><big>int <u>PQgetCopyData</u>(PGconn * <i>conn</i>, char** <i>buffer</i>, int <i>async</i>);
</big></dt>
<dd>Get the data from the server after a copy command.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char** <i>buffer</i></td>
<td>A pointer to the buffer.  The memory will be allocated by PostgreSQL.</td></tr>
<tr><td>int <i>async</i></td>
<td>Use 0 for nonblocking and any other number for blocking.</td></tr>
</table><br>
<b>Returns:</b><br>
-1 on success, -2 on failure, or 0 if the command is still in progress.
 
<br><br>

</dd>
<dt><big>deprecated int <u>PQgetline</u>(PGconn * <i>conn</i>, char* <i>string</i>, int <i>length</i>);
<br>deprecated int <u>PQputline</u>(PGconn * <i>conn</i>, char* <i>string</i>);
<br>deprecated int <u>PQgetlineAsync</u>(PGconn * <i>conn</i>, char* <i>buffer</i>, int <i>bufsize</i>);
<br>deprecated int <u>PQputnbytes</u>(PGconn * <i>conn</i>, char* <i>buffer</i>, int <i>nbytes</i>);
<br>deprecated int <u>PQendcopy</u>(PGconn * <i>conn</i>);
</big></dt>
<dd><font color=red>Deprecated:</font><br>
These functions have poor error handling, nonblocking transfers, binary data,
	or easy end of data detection.  Use PQputCopyData, PQputCopyEnd, and PQgetCopyData instead.
 
<br><br>

</dd>
<dt><big>int <u>PQsetnonblocking</u>(PGconn * <i>conn</i>, int <i>arg</i>);
</big></dt>
<dd>Set the nonblocking status of the connection.
<br><br>
PQexec will ignore this setting.

<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>int <i>arg</i></td>
<td>1 for nonblocking and 0 for blocking.</td></tr>
</table><br>
<b>Returns:</b><br>
0 on success and -1 on failure.
 
<br><br>

</dd>
<dt><big>int <u>PQisnonblocking</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Get the current nonblocking status of the connection.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
1 if the connection is nonblocking and 0 if it is blocking.
 
<br><br>

</dd>
<dt><big>int <u>PQflush</u>(PGconn * <i>conn</i>);
</big></dt>
<dd>Attempt to send all queries to the server immediately.
<br><br>
This function will only be unable to send the data if nonblocking is set.

<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
</table><br>
<b>Returns:</b><br>
0 on success, -1 on failure, or 1 if not all of the data was sent.
 
<br><br>

</dd>
<dt><big>deprecated PGresult * <u>PQfn</u>(PGconn * <i>conn</i>, int <i>fnid</i>, int* <i>result_buf</i>, int* <i>result_len</i>, int <i>result_is_int</i>, PQArgBlock * <i>args</i>, int <i>nargs</i>);
</big></dt>
<dd>Send a simple command to the query very quickly.
<br><br>
<font color=red>Deprecated:</font><br>
Prepared functions are just as fast and more powerful.  Use them instead.

<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>int <i>fnid</i></td>
<td>The Oid of the function to execute.</td></tr>
<tr><td>int* <i>result_buf</i></td>
<td>The buffer the return value will be placed in.</td></tr>
<tr><td>int* <i>result_len</i></td>
<td>The length of <i>result_buf</i>.</td></tr>
<tr><td>int <i>result_is_int</i></td>
<td>This is 1 if an integer of 4 bytes or less is to be returned.  Use 0 otherwise.</td></tr>
<tr><td>PQArgBlock * <i>args</i></td>
<td>An array of PQArgBlock structures.</td></tr>
<tr><td>int <i>nargs</i></td>
<td>The length of <i>args</i>.</td></tr>
</table><br>
<b>Returns:</b><br>
A PGresult structure describing the current status.
 
<br><br>

</dd>
<dt><big>ExecStatusType <u>PQresultStatus</u>(PGresult * <i>res</i>);
</big></dt>
<dd>Get the result status of a command.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure returned by the server.</td></tr>
</table><br>
<b>Returns:</b><br>
An ExecStatusType value describing the result status.
 
<br><br>

</dd>
<dt><big>char* <u>PQresStatus</u>(ExecStatusType <i>status</i>);
</big></dt>
<dd>Get the string representing an ExecStatusType value.
<br><br>
<b>Params:</b><br>
<table><tr><td>ExecStatusType <i>status</i></td>
<td>The ExecStatusType value.</td></tr>
</table><br>
<b>Returns:</b><br>
The representative string.
 
<br><br>

</dd>
<dt><big>char* <u>PQresultErrorMessage</u>(PGresult * <i>res</i>);
</big></dt>
<dd>Get the error message associated with a command.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure returned by the server.</td></tr>
</table><br>
<b>Returns:</b><br>
The string form of the error if there is one or an empty string otherwise.
 
<br><br>

</dd>
<dt><big>char* <u>PQresultErrorField</u>(PGresult * <i>res</i>, char <i>fieldcode</i>);
</big></dt>
<dd>Get an individual field of an error report.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>char <i>fieldcode</i></td>
<td>The error filed to return.  Accepted values start with PG_DIAG_</td></tr>
</table><br>
<b>Returns:</b><br>
The string form of the error if there is one or <b>null</b> otherwise.

<br><br>
<b>See Also:</b><br>
The online PostgreSQL documentation describes what you can use in <i>fieldcode</i>.
 
<br><br>

</dd>
<dt><big>int <u>PQntuples</u>(PGresult * <i>res</i>);
</big></dt>
<dd>Get the number of tuples in a query result.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure returned by the server.</td></tr>
</table><br>
<b>Returns:</b><br>
The number of tuples.
 
<br><br>

</dd>
<dt><big>int <u>PQnfields</u>(PGresult * <i>res</i>);
</big></dt>
<dd>Get the number of fields in a query result.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure returned by the server.</td></tr>
</table><br>
<b>Returns:</b><br>
The number of fields.
 
<br><br>

</dd>
<dt><big>int <u>PQbinaryTuples</u>(PGresult * <i>res</i>);
</big></dt>
<dd>Get whether a query result contains binary data or not.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure returned by the server.</td></tr>
</table><br>
<b>Returns:</b><br>
1 if the result set contains binary data and 0 otherwise.
 
<br><br>

</dd>
<dt><big>char* <u>PQfname</u>(PGresult * <i>res</i>, int <i>field_num</i>);
</big></dt>
<dd>Get the column name associated with a column number in a query result.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>int <i>field_num</i></td>
<td>The number of the column.</td></tr>
</table><br>
<b>Returns:</b><br>
The name of the column if it exists or <b>null</b> otherwise.
 
<br><br>

</dd>
<dt><big>int <u>PQfnumber</u>(PGresult * <i>res</i>, char* <i>field_name</i>);
</big></dt>
<dd>Get the column number associated with a column name in a query result.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>char* <i>field_name</i></td>
<td>The name of the column.</td></tr>
</table><br>
<b>Returns:</b><br>
The number of the column if it exists or -1 otherwise.
 
<br><br>

</dd>
<dt><big>uint <u>PQftable</u>(PGresult * <i>res</i>, int <i>field_num</i>);
</big></dt>
<dd>Get the Oid of the table from which a column in a query result was fetched.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>int <i>field_num</i></td>
<td>The number of the column.</td></tr>
</table><br>
<b>Returns:</b><br>
The Oid of the table if it exists or InvalidOid otherwise.
 
<br><br>

</dd>
<dt><big>int <u>PQftablecol</u>(PGresult * <i>res</i>, int <i>field_num</i>);
</big></dt>
<dd>Get the number of a column in its table from its number in a query result.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>int <i>field_num</i></td>
<td>The number of the column within the query result.</td></tr>
</table><br>
<b>Returns:</b><br>
The column number if it exists or 0 otherwise.
 
<br><br>

</dd>
<dt><big>int <u>PQfformat</u>(PGresult * <i>res</i>, int <i>field_num</i>);
</big></dt>
<dd>Get the format code of a column in a query result.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>int <i>field_num</i></td>
<td>The number of the column.</td></tr>
</table><br>
<b>Returns:</b><br>
0 if the format is text and 1 if it is binary.
 
<br><br>

</dd>
<dt><big>uint <u>PQftype</u>(PGresult * <i>res</i>, int <i>field_num</i>);
</big></dt>
<dd>Get the data type of a column in a query result.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>int <i>field_num</i></td>
<td>The number of the column.</td></tr>
</table><br>
<b>Returns:</b><br>
The Oid representing the data type.
 
<br><br>

</dd>
<dt><big>int <u>PQfsize</u>(PGresult * <i>res</i>, int <i>field_num</i>);
</big></dt>
<dd>Get the number of bytes4/17/2006 in a column in a query result.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>int <i>field_num</i></td>
<td>The number of the column.</td></tr>
</table><br>
<b>Returns:</b><br>
The number of bytes.
 
<br><br>

</dd>
<dt><big>int <u>PQfmod</u>(PGresult * <i>res</i>, int <i>field_num</i>);
</big></dt>
<dd>Get the type modifier of a column in a query result.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>int <i>field_num</i></td>
<td>The number of the column.</td></tr>
</table><br>
<b>Returns:</b><br>
The type modifier if it exists or -1 otherwise.
 
<br><br>

</dd>
<dt><big>char* <u>PQcmdStatus</u>(PGresult * <i>res</i>);
</big></dt>
<dd>Get the command status tag from a query result.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure returned by the server.</td></tr>
</table><br>
<b>Returns:</b><br>
The command status tag.
 
<br><br>

</dd>
<dt><big>deprecated char* <u>PQoidStatus</u>(PGresult * <i>res</i>);
</big></dt>
<dd>Get the Oid in string format of a valid insert in a query result.
<br><br>
<font color=red>Deprecated:</font><br>
Use PQoidValue instead.  It is thread-safe.

<br><br>
<b>Params:</b><br>
<table><tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure returned by the server.</td></tr>
</table><br>
<b>Returns:</b><br>
The Oid if it exists and is valid. "0" or "" is returned otherwise.
 
<br><br>

</dd>
<dt><big>uint <u>PQoidValue</u>(PGresult * <i>res</i>);
</big></dt>
<dd>Get the Oid of a valid insert in a query result.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure returned by the server.</td></tr>
</table><br>
<b>Returns:</b><br>
The Oid if it exists and is valid or InvalidOid if it isn't.
 
<br><br>

</dd>
<dt><big>char* <u>PQcmdTuples</u>(PGresult * <i>res</i>);
</big></dt>
<dd>Get the number of tuples affected by a query.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure returned by the server.</td></tr>
</table><br>
<b>Returns:</b><br>
The number of affected tuples.
 
<br><br>

</dd>
<dt><big>char* <u>PQgetvalue</u>(PGresult * <i>res</i>, int <i>tup_num</i>, int <i>field_num</i>);
</big></dt>
<dd>Get the value of a single field in a query result.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>int <i>tup_num</i></td>
<td>The number of the row.</td></tr>
<tr><td>int <i>field_num</i></td>
<td>The number of the column.</td></tr>
</table><br>
<b>Returns:</b><br>
The value of the field.
 
<br><br>

</dd>
<dt><big>int <u>PQgetlength</u>(PGresult * <i>res</i>, int <i>tup_num</i>, int <i>field_num</i>);
</big></dt>
<dd>Get the number of bytes in the length of a single field in a query result.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>int <i>tup_num</i></td>
<td>The number of the row.</td></tr>
<tr><td>int <i>field_num</i></td>
<td>The number of the column.</td></tr>
</table><br>
<b>Returns:</b><br>
The number of bytes in the length of the field.
 
<br><br>

</dd>
<dt><big>int <u>PQgetisnull</u>(PGresult * <i>res</i>, int <i>tup_num</i>, int <i>field_num</i>);
</big></dt>
<dd>Get whether or not a single field in a query result is <b>null</b>.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>int <i>tup_num</i></td>
<td>The number of the row.</td></tr>
<tr><td>int <i>field_num</i></td>
<td>The number of the column.</td></tr>
</table><br>
<b>Returns:</b><br>
1 if it is <b>null</b> or 0 otherwise.
 
<br><br>

</dd>
<dt><big>void <u>PQclear</u>(PGresult * <i>res</i>);
</big></dt>
<dd>Free all memory associated with a result.  This includes all returned strings.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure to erase.</td></tr>
</table><br>

</dd>
<dt><big>void <u>PQfreemem</u>(void* <i>ptr</i>);
</big></dt>
<dd>Free memory allocated by the the interface library.
<br><br>
This is necessary only on Windows.  Users of other operating systems can simply use free.

<br><br>
<b>Params:</b><br>
<table><tr><td>void* <i>ptr</i></td>
<td>A pointer to the memory to free.</td></tr>
</table><br>

</dd>
<dt><big>deprecated alias <u>PQfreeNotify</u>;
</big></dt>
<dd><font color=red>Deprecated:</font><br>
Use PQfreemem or free directly.
 
<br><br>

</dd>
<dt><big>PGresult * <u>PQmakeEmptyPGresult</u>(PGconn * <i>conn</i>, ExecStatusType <i>status</i>);
</big></dt>
<dd>Make an empty PGresult structure with a given status.
<br><br>
Note that anything from the PostgreSQL connection will be added in.

<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.  This can be <b>null</b>.</td></tr>
<tr><td>ExecStatusType <i>status</i></td>
<td>The error message to add to the PGresult structure.</td></tr>
</table><br>
<b>Returns:</b><br>
The created PGresult structure.
 
<br><br>

</dd>
<dt><big>uint <u>PQescapeStringConn</u>(PGconn * <i>conn</i>, char* <i>to</i>, char* <i>from</i>, uint <i>length</i>, int* <i>error</i>);
</big></dt>
<dd>Escape a string for use within a SQL command.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <i>to</i></td>
<td>The buffer the results will be put in.  Must be at least 2 * <i>length</i> + 1 chars long.</td></tr>
<tr><td>char* <i>from</i></td>
<td>The string to convert.</td></tr>
<tr><td>uint <i>length</i></td>
<td>The number of chars to escape.  The terminating 0 should not be included.</td></tr>
<tr><td>int* <i>error</i></td>
<td>0 on success and nonzero on failure.  Can be <b>null</b>.</td></tr>
</table><br>
<b>Returns:</b><br>
The number of characters in <i>to</i>.  This doesn't include the terminating 0.
 
<br><br>

</dd>
<dt><big>char* <u>PQescapeByteaConn</u>(PGconn * <i>conn</i>, ubyte* <i>from</i>, uint <i>from_length</i>, uint* <i>to_length</i>);
</big></dt>
<dd>Escape binary data for use within a SQL command.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>ubyte* <i>from</i></td>
<td>A pointer to the first byte to escape.</td></tr>
<tr><td>uint <i>from_length</i></td>
<td>The number of bytes to escape.  The terminating 0 should not be included.</td></tr>
<tr><td>uint* <i>to_length</i></td>
<td>A pointer to a variable that will hold the length of the escaped string.</td></tr>
</table><br>
<b>Returns:</b><br>
The escaped version of bintext on success and <b>null</b> on failure.
 
<br><br>

</dd>
<dt><big>deprecated uint <u>PQescapeString</u>(char* <i>to</i>, char* <i>from</i>, uint <i>length</i>);
</big></dt>
<dd>Escape a string for use within a SQL command.
<br><br>
<font color=red>Deprecated:</font><br>
Replaced by PQescapeStringConn in PostgreSQL 8.1.4.

<br><br>
<b>Params:</b><br>
<table><tr><td>char* <i>to</i></td>
<td>The buffer the results will be put in.  Must be at least 2 * <i>length</i> + 1 chars long.</td></tr>
<tr><td>char* <i>from</i></td>
<td>The string to convert.</td></tr>
<tr><td>uint <i>length</i></td>
<td>The number of chars to escape.  The terminating 0 should not be included.</td></tr>
</table><br>
<b>Returns:</b><br>
The number of characters in <i>to</i>.
 
<br><br>

</dd>
<dt><big>deprecated char* <u>PQescapeBytea</u>(ubyte* <i>bintext</i>, uint <i>binlen</i>, uint* <i>bytealen</i>);
</big></dt>
<dd>Escape binary data for use within a SQL command.
<br><br>
<font color=red>Deprecated:</font><br>
Replaced by PQescapeByteaConn in PostgreSQL 8.1.4.

<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte* <i>bintext</i></td>
<td>A pointer to the first byte to escape.</td></tr>
<tr><td>uint <i>binlen</i></td>
<td>The number of bytes to escape.  The terminating 0 should not be included.</td></tr>
<tr><td>uint* <i>bytealen</i></td>
<td>A pointer to a variable that will hold the length of the escaped string.</td></tr>
</table><br>
<b>Returns:</b><br>
The escaped version of <i>bintext</i>.
 
<br><br>

</dd>
<dt><big>ubyte* <u>PQunescapeBytea</u>(char* <i>strtext</i>, uint* <i>retbuflen</i>);
</big></dt>
<dd>Unescape binary data.
<br><br>
<b>Params:</b><br>
<table><tr><td>char* <i>strtext</i></td>
<td>The escaped binary data.</td></tr>
<tr><td>uint* <i>retbuflen</i></td>
<td>A pointer to a variable that will hold the length of the escaped string.</td></tr>
</table><br>
<b>Returns:</b><br>
The unescaped version of <i>strtext</i>.
 
<br><br>

</dd>
<dt><big>void <u>PQprint</u>(_iobuf * <i>fout</i>, PGresult * <i>res</i>, _PQprintOpt * <i>ps</i>);
</big></dt>
<dd>Print all of the rows to a stream.
<br><br>
<b>Params:</b><br>
<table><tr><td>_iobuf * <i>fout</i></td>
<td>The CStream to output the information to.</td></tr>
<tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>_PQprintOpt * <i>ps</i></td>
<td>A PQprintOpt structure containing your printing options.</td></tr>
</table><br>

</dd>
<dt><big>deprecated void <u>PQdisplayTuples</u>(PGresult * <i>res</i>, _iobuf * <i>fp</i>, int <i>fillAlign</i>, char* <i>fieldSep</i>, int <i>printHeader</i>, int <i>quiet</i>);
</big></dt>
<dd>Print all of the rows to a stream.
<br><br>
<font color=red>Deprecated:</font><br>
Use PQprint instead.

<br><br>
<b>Params:</b><br>
<table><tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>_iobuf * <i>fp</i></td>
<td>The CStream to output the information to.</td></tr>
<tr><td>int <i>fillAlign</i></td>
<td>Space fill to align columns.</td></tr>
<tr><td>char* <i>fieldSep</i></td>
<td>The character to use as a field seperator.</td></tr>
<tr><td>int <i>printHeader</i></td>
<td>Use 1 to display headers and 0 not to.</td></tr>
<tr><td>int <i>quiet</i></td>
<td>Use 0 to show row count at the end and 1 not to.</td></tr>
</table><br>

</dd>
<dt><big>deprecated void <u>PQprintTuples</u>(PGresult * <i>res</i>, _iobuf * <i>fout</i>, int <i>printAttName</i>, int <i>terseOutput</i>, int <i>width</i>);
</big></dt>
<dd>Print all of the rows to a stream.
<br><br>
<font color=red>Deprecated:</font><br>
Use PQprint instead.

<br><br>
<b>Params:</b><br>
<table><tr><td>PGresult * <i>res</i></td>
<td>The PGresult structure returned by the server.</td></tr>
<tr><td>_iobuf * <i>fout</i></td>
<td>The CStream to output the information to.</td></tr>
<tr><td>int <i>printAttName</i></td>
<td>Use 1 to print attribute names and 0 not to.</td></tr>
<tr><td>int <i>terseOutput</i></td>
<td>Use 1 to show delimiter bars and 0 not to.</td></tr>
<tr><td>int <i>width</i></td>
<td>The width of the columns.  Use 0 for variable width.</td></tr>
</table><br>

</dd>
<dt><big>int <u>lo_open</u>(PGconn * <i>conn</i>, uint <i>lobjId</i>, int <i>mode</i>);
</big></dt>
<dd>Open an existing large object.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>PostgreSQL connection.</td></tr>
<tr><td>uint <i>lobjId</i></td>
<td>Oid of the large object to open.</td></tr>
<tr><td>int <i>mode</i></td>
<td>Whether to make it readonly or not.  Uses INV_READ and INV_WRITE.</td></tr>
</table><br>
<b>Returns:</b><br>
An integer for use with other large object functions on success or -1 on failure.
 
<br><br>

</dd>
<dt><big>int <u>lo_close</u>(PGconn * <i>conn</i>, int <i>fd</i>);
</big></dt>
<dd>Close an opened large object.
<br><br>
This is done automatically to any large objects that are open at the end of a transaction.

<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>int <i>fd</i></td>
<td>The integer returned when the large object was opened.</td></tr>
</table><br>
<b>Returns:</b><br>
0 on success or -1 on failure.
 
<br><br>

</dd>
<dt><big>int <u>lo_read</u>(PGconn * <i>conn</i>, int <i>fd</i>, byte* <i>buf</i>, uint <i>len</i>);
</big></dt>
<dd>Read from an open large object.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>int <i>fd</i></td>
<td>The integer returned when the large object was opened;</td></tr>
<tr><td>byte* <i>buf</i></td>
<td>The buffer that that data will be written to.</td></tr>
<tr><td>uint <i>len</i></td>
<td>The number of bytes to copy to <i>buf</i>.</td></tr>
</table><br>
<b>Returns:</b><br>
The number of bytes read on success or a negative number on failure.
 
<br><br>

</dd>
<dt><big>int <u>lo_write</u>(PGconn * <i>conn</i>, int <i>fd</i>, byte* <i>buf</i>, uint <i>len</i>);
</big></dt>
<dd>Writes to an open large object.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>int <i>fd</i></td>
<td>The integer returned when the large object was opened.</td></tr>
<tr><td>byte* <i>buf</i></td>
<td>The buffer that the data will be read from.</td></tr>
<tr><td>uint <i>len</i></td>
<td>The number of bytes to copy from <i>buf</i>.</td></tr>
</table><br>
<b>Returns:</b><br>
The number of bytes read on success or a negative number on failure.
 
<br><br>

</dd>
<dt><big>int <u>lo_lseek</u>(PGconn * <i>conn</i>, int <i>fd</i>, int <i>offset</i>, int <i>whence</i>);
</big></dt>
<dd>Change the location of reading and writing in an open large object.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>int <i>fd</i></td>
<td>The integer returned when the large object was opened.</td></tr>
<tr><td>int <i>offset</i></td>
<td>How far to move.</td></tr>
<tr><td>int <i>whence</i></td>
<td>Where to start counting.  Uses SEEK_SET, SEEK_CUR, and SEEK_END.</td></tr>
</table><br>
<b>Returns:</b><br>
The new location pointer on success or -1 on failure.
 
<br><br>

</dd>
<dt><big>uint <u>lo_creat</u>(PGconn * <i>conn</i>, int <i>mode</i>);
</big></dt>
<dd>Create a new large object.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>int <i>mode</i></td>
<td>Ignored as of PostgreSQL version 8.1.</td></tr>
</table><br>
<b>Returns:</b><br>
The Oid of the large object on success or InvalidOid on failure.
 
<br><br>

</dd>
<dt><big>uint <u>lo_create</u>(PGconn * <i>conn</i>, uint <i>lobjId</i>);
</big></dt>
<dd>Create a new large object.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>uint <i>lobjId</i></td>
<td>Requested Oid to assign the large object to.</td></tr>
</table><br>
<b>Returns:</b><br>
The Oid of the large object or InvalidOid on failure.
 
<br><br>

</dd>
<dt><big>int <u>lo_tell</u>(PGconn * <i>conn</i>, int <i>fd</i>);
</big></dt>
<dd>Get the location pointer of an open large object.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>int <i>fd</i></td>
<td>The integer returned when the large object was opened.</td></tr>
</table><br>
<b>Returns:</b><br>
The location pointer or a negative number on failure.
 
<br><br>

</dd>
<dt><big>int <u>lo_unlink</u>(PGconn * <i>conn</i>, uint <i>lobjId</i>);
</big></dt>
<dd>Remove a large object from the database.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>lobjOid</td>
<td>the Oid of the large object to remove.</td></tr>
</table><br>
<b>Returns:</b><br>
1 on success or -1 on failure.
 
<br><br>

</dd>
<dt><big>uint <u>lo_import</u>(PGconn * <i>conn</i>, char* <i>filename</i>);
</big></dt>
<dd>Load a large object from a file.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>char* <i>filename</i></td>
<td>Name of the file to load.</td></tr>
</table><br>
<b>Returns:</b><br>
The Oid of the large object or InvalidOid on failure.
 
<br><br>

</dd>
<dt><big>int <u>lo_export</u>(PGconn * <i>conn</i>, uint <i>lobjId</i>, char* <i>filename</i>);
</big></dt>
<dd>Save a large object to a file.
<br><br>
<b>Params:</b><br>
<table><tr><td>PGconn * <i>conn</i></td>
<td>The PostgreSQL connection.</td></tr>
<tr><td>lobjOid</td>
<td>Oid of the large object to save.</td></tr>
<tr><td>char* <i>filename</i></td>
<td>Name of the file to save to.</td></tr>
</table><br>
<b>Returns:</b><br>
1 on success or -1 on failure.
 
<br><br>

</dd>
<dt><big>int <u>PQmblen</u>(char* <i>s</i>, int <i>encoding</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>PQdsplen</u>(char* <i>s</i>, int <i>encoding</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>PQenv2encoding</u>();
</big></dt>
<dd><br><br>
</dd>
</dl>

	<hr><small>Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. LGPL
 
</small>
	</body></html>
