<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<title>dbi.sqlite.imp</title>
	<style type="text/css">
		.underline {
			text-decoration: underline;
		}

		.big {
			font-size: larger;
		}

		.small {
			font-size: smaller;
		}

		.red {
			color: red;
		}

		.blue {
			color: blue;
		}

		.green {
			color: green;
		}

		.yellow {
			color: yellow;
		}

		.black {
			color: black;
		}

		.white {
			color: white;
		}
	</style>
</head>
<body>
<h1>dbi.sqlite.imp</h1>
<!-- Generated by Ddoc from dbi\sqlite\imp.d -->
<p>SQLite import library.
</p>
<p>Part of the D DBI project.

</p>
<p><strong>Version:</strong><br />SQLite version 3.3.8
<br /><br />

	Import library version 0.04

</p>
<p><strong>Authors:</strong><br />The D DBI project

</p>

<dl><dt><span class="big">struct <span class="underline">sqlite3</span>;
</span></dt>
<dd><br /><br />
<dl></dl>
</dd>
<dt><span class="big">struct <span class="underline">sqlite3_context</span>;
</span></dt>
<dd><br /><br />
<dl></dl>
</dd>
<dt><span class="big">struct <span class="underline">sqlite3_index_info</span>;
</span></dt>
<dd><br /><br />
<dl><dt><span class="big">int <span class="underline">nConstraint</span>;
</span></dt>
<dd><p>Number of entries in aConstraint.
</p>

</dd>
<dt><span class="big">sqlite3_index_constraint * <span class="underline">aConstraint</span>;
</span></dt>
<dd><p>Table of WHERE clause constraints.
</p>

</dd>
<dt><span class="big">int <span class="underline">nOrderBy</span>;
</span></dt>
<dd><p>Number of terms in the ORDER BY clause.
</p>

</dd>
<dt><span class="big">sqlite3_index_orderby * <span class="underline">aOrderBy</span>;
</span></dt>
<dd><p>The ORDER BY clause.
</p>

</dd>
<dt><span class="big">sqlite3_index_constraint_usage * <span class="underline">aConstraintUsage</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">idxNum</span>;
</span></dt>
<dd><p>Number used to identify the index.
</p>

</dd>
<dt><span class="big">char* <span class="underline">idxStr</span>;
</span></dt>
<dd><p>String, possibly obtained from sqlite3_malloc.
</p>

</dd>
<dt><span class="big">int <span class="underline">needToFreeIdxStr</span>;
</span></dt>
<dd><p>Free idxStr using sqlite3_free() if <strong>true</strong>.
</p>

</dd>
<dt><span class="big">int <span class="underline">orderByConsumed</span>;
</span></dt>
<dd><p><strong>true</strong> if output is already ordered.
</p>

</dd>
<dt><span class="big">double <span class="underline">estimatedCost</span>;
</span></dt>
<dd><p>Estimated cost of using this index.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">struct <span class="underline">sqlite3_module</span>;
</span></dt>
<dd><br /><br />
<dl></dl>
</dd>
<dt><span class="big">struct <span class="underline">sqlite3_stmt</span>;
</span></dt>
<dd><br /><br />
<dl></dl>
</dd>
<dt><span class="big">struct <span class="underline">sqlite3_value</span>;
</span></dt>
<dd><br /><br />
<dl></dl>
</dd>
<dt><span class="big">struct <span class="underline">sqlite3_vtab</span>;
</span></dt>
<dd><br /><br />
<dl><dt><span class="big">sqlite3_module * <span class="underline">pModule</span>;
</span></dt>
<dd><p>The module for this virtual table.
</p>

</dd>
<dt><span class="big">int <span class="underline">nRef</span>;
</span></dt>
<dd><p>Used internally.
</p>

</dd>
<dt><span class="big">char* <span class="underline">zErrMsg</span>;
</span></dt>
<dd><p>Error message from sqlite3_mprintf().
</p>

</dd>
</dl>
</dd>
<dt><span class="big">struct <span class="underline">sqlite3_vtab_cursor</span>;
</span></dt>
<dd><br /><br />
<dl><dt><span class="big">sqlite3_vtab * <span class="underline">pVtab</span>;
</span></dt>
<dd><p>Virtual table of this cursor.
</p>

</dd>
</dl>
</dd>
<dt><span class="big">alias <span class="underline">sqlite_callback</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">const int <span class="underline">SQLITE_OK</span>;
</span></dt>
<dd><p>Successful result.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_ERROR</span>;
</span></dt>
<dd><p>SQL error or missing database.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_INTERNAL</span>;
</span></dt>
<dd><p>An internal logic error in SQLite.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_PERM</span>;
</span></dt>
<dd><p>Access permission denied.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_ABORT</span>;
</span></dt>
<dd><p>Callback routine requested an abort.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_BUSY</span>;
</span></dt>
<dd><p>The database file is locked.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_LOCKED</span>;
</span></dt>
<dd><p>A table in the database is locked.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_NOMEM</span>;
</span></dt>
<dd><p>A malloc() failed.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_READONLY</span>;
</span></dt>
<dd><p>Attempt to write a readonly database.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_INTERRUPT</span>;
</span></dt>
<dd><p>Operation terminated by sqlite_interrupt().
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_IOERR</span>;
</span></dt>
<dd><p>Some kind of disk I/O error occurred.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_CORRUPT</span>;
</span></dt>
<dd><p>The database disk image is malformed.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_NOTFOUND</span>;
</span></dt>
<dd><p>(Internal Only) Table or record not found.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_FULL</span>;
</span></dt>
<dd><p>Insertion failed because database is full.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_CANTOPEN</span>;
</span></dt>
<dd><p>Unable to open the database file.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_PROTOCOL</span>;
</span></dt>
<dd><p>Database lock protocol error.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_EMPTY</span>;
</span></dt>
<dd><p>(Internal Only) Database table is empty.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_SCHEMA</span>;
</span></dt>
<dd><p>The database schema changed.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_TOOBIG</span>;
</span></dt>
<dd><p>Too much data for one row of a table.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_CONSTRAINT</span>;
</span></dt>
<dd><p>Abort due to constraint violation.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_MISMATCH</span>;
</span></dt>
<dd><p>Data type mismatch.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_MISUSE</span>;
</span></dt>
<dd><p>Library used incorrectly.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_NOLFS</span>;
</span></dt>
<dd><p>Uses OS features not supported on host.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_AUTH</span>;
</span></dt>
<dd><p>Authorization denied.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_ROW</span>;
</span></dt>
<dd><p>sqlite_step() has another row ready.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_DONE</span>;
</span></dt>
<dd><p>sqlite_step() has finished executing.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_UTF8</span>;
</span></dt>
<dd><p>The text is in UTF8 format.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_UTF16BE</span>;
</span></dt>
<dd><p>The text is in UTF16 big endian format.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_UTF16LE</span>;
</span></dt>
<dd><p>The text is in UTF16 little endian format.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_UTF16</span>;
</span></dt>
<dd><p>The text is in UTF16 format.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_ANY</span>;
</span></dt>
<dd><p>The text is in some format or another.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_INTEGER</span>;
</span></dt>
<dd><p>The data value is an integer.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_FLOAT</span>;
</span></dt>
<dd><p>The data value is a float.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_TEXT</span>;
</span></dt>
<dd><p>The data value is text.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_BLOB</span>;
</span></dt>
<dd><p>The data value is a blob.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_NULL</span>;
</span></dt>
<dd><p>The data value is null.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_DENY</span>;
</span></dt>
<dd><p>Abort the SQL statement with an error.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_IGNORE</span>;
</span></dt>
<dd><p>Don't allow access, but don't generate an error.
</p>

</dd>
<dt><span class="big">const void(* <span class="underline">SQLITE_STATIC</span>)(void*);
</span></dt>
<dd><p>The data doesn't need to be freed by SQLite.  
</p>

</dd>
<dt><span class="big">const void(* <span class="underline">SQLITE_TRANSIENT</span>)(void*);
</span></dt>
<dd><p>SQLite should make a private copy of the data.
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_CREATE_INDEX</span>;
</span></dt>
<dd><p>Index Name		Table Name
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_CREATE_TABLE</span>;
</span></dt>
<dd><p>Table Name		NULL
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_CREATE_TEMP_INDEX</span>;
</span></dt>
<dd><p>Index Name		Table Name
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_CREATE_TEMP_TABLE</span>;
</span></dt>
<dd><p>Table Name		NULL
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_CREATE_TEMP_TRIGGER</span>;
</span></dt>
<dd><p>Trigger Name	Table Name
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_CREATE_TEMP_VIEW</span>;
</span></dt>
<dd><p>View Name		NULL
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_CREATE_TRIGGER</span>;
</span></dt>
<dd><p>Trigger Name	Table Name
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_CREATE_VIEW</span>;
</span></dt>
<dd><p>View Name		NULL
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_DELETE</span>;
</span></dt>
<dd><p>Table Name		NULL
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_DROP_INDEX</span>;
</span></dt>
<dd><p>Index Name		Table Name
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_DROP_TABLE</span>;
</span></dt>
<dd><p>Table Name		NULL
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_DROP_TEMP_INDEX</span>;
</span></dt>
<dd><p>Index Name		Table Name
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_DROP_TEMP_TABLE</span>;
</span></dt>
<dd><p>Table Name		NULL
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_DROP_TEMP_TRIGGER</span>;
</span></dt>
<dd><p>Trigger Name	Table Name
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_DROP_TEMP_VIEW</span>;
</span></dt>
<dd><p>View Name		NULL
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_DROP_TRIGGER</span>;
</span></dt>
<dd><p>Trigger Name	Table Name
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_DROP_VIEW</span>;
</span></dt>
<dd><p>View Name		NULL
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_INSERT</span>;
</span></dt>
<dd><p>Table Name		NULL
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_PRAGMA</span>;
</span></dt>
<dd><p>Pragma Name		1st arg or NULL
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_READ</span>;
</span></dt>
<dd><p>Table Name		Column Name
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_SELECT</span>;
</span></dt>
<dd><p>NULL		NULL
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_TRANSACTION</span>;
</span></dt>
<dd><p>NULL		NULL
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_UPDATE</span>;
</span></dt>
<dd><p>Table Name		Column Name
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_ATTACH</span>;
</span></dt>
<dd><p>Filename		NULL
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_DETACH</span>;
</span></dt>
<dd><p>Database Name	NULL
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_ALTER_TABLE</span>;
</span></dt>
<dd><p>Database Name	Table Name
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_REINDEX</span>;
</span></dt>
<dd><p>Index Name		NULL
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_ANALYZE</span>;
</span></dt>
<dd><p>Table Name		NULL
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_CREATE_VTABLE</span>;
</span></dt>
<dd><p>Table Name		Module Name
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_DROP_VTABLE</span>;
</span></dt>
<dd><p>Table Name		Module Name
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_FUNCTION</span>;
</span></dt>
<dd><p>Function Name	NULL
</p>

</dd>
<dt><span class="big">const int <span class="underline">SQLITE_INDEX_CONSTRAINT_EQ</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">const int <span class="underline">SQLITE_INDEX_CONSTRAINT_GT</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">const int <span class="underline">SQLITE_INDEX_CONSTRAINT_LE</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">const int <span class="underline">SQLITE_INDEX_CONSTRAINT_LT</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">const int <span class="underline">SQLITE_INDEX_CONSTRAINT_GE</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">const int <span class="underline">SQLITE_INDEX_CONSTRAINT_MATCH</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">const int <span class="underline">SQLITE_IOERR_READ</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">const int <span class="underline">SQLITE_IOERR_SHORT_READ</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">const int <span class="underline">SQLITE_IOERR_WRITE</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">const int <span class="underline">SQLITE_IOERR_FSYNC</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">const int <span class="underline">SQLITE_IOERR_DIR_FSYNC</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">const int <span class="underline">SQLITE_IOERR_TRUNCATE</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">const int <span class="underline">SQLITE_IOERR_FSTAT</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">const int <span class="underline">SQLITE_IOERR_UNLOCK</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">const int <span class="underline">SQLITE_IOERR_RDLOCK</span>;
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void* <span class="underline">sqlite3_aggregate_context</span>(sqlite3_context * <em>ctx</em>, int <em>nBytes</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">deprecated int <span class="underline">sqlite3_aggregate_count</span>(sqlite3_context * <em>ctx</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_auto_extension</span>(void* <em>xEntryPoint</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_bind_blob</span>(sqlite3_stmt * <em>stmt</em>, int <em>index</em>, void* <em>value</em>, int <em>n</em>, void(* <em>destructor</em>)(void*));
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_bind_double</span>(sqlite3_stmt * <em>stmt</em>, int <em>index</em>, double <em>value</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_bind_int</span>(sqlite3_stmt * <em>stmt</em>, int <em>index</em>, int <em>value</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_bind_int64</span>(sqlite3_stmt * <em>stmt</em>, int <em>index</em>, long <em>value</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_bind_null</span>(sqlite3_stmt * <em>stmt</em>, int <em>index</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_bind_text</span>(sqlite3_stmt * <em>stmt</em>, int <em>index</em>, char* <em>value</em>, int <em>n</em>, void(* <em>destructor</em>)(void*));
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_bind_text16</span>(sqlite3_stmt * <em>stmt</em>, int <em>index</em>, void* <em>value</em>, int <em>n</em>, void(* <em>destructor</em>)(void*));
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_bind_parameter_count</span>(sqlite3_stmt * <em>stmt</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_bind_parameter_index</span>(sqlite3_stmt * <em>stmt</em>, char* <em>zName</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">char* <span class="underline">sqlite3_bind_parameter_name</span>(sqlite3_stmt * <em>stmt</em>, int <em>n</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_busy_handler</span>(sqlite3 * <em>database</em>, int(* <em>handler</em>)(void*, int), void* <em>n</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_busy_timeout</span>(sqlite3 * <em>database</em>, int <em>ms</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_changes</span>(sqlite3 * <em>database</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_clear_bindings</span>(sqlite3_stmt * <em>statement</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_close</span>(sqlite3 * <em>database</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_collation_needed</span>(sqlite3 * <em>database</em>, void* <em>names</em>, void(*)(void* <em>names</em>, sqlite3 * <em>database</em>, int eTextRep, char* sequence));
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_collation_needed</span>(sqlite3 * <em>database</em>, void* <em>names</em>, void(*)(void* <em>names</em>, sqlite3 * <em>database</em>, int eTextRep, void* sequence));
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void* <span class="underline">sqlite3_column_blob</span>(sqlite3_stmt * <em>stmt</em>, int <em>iCol</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_column_bytes</span>(sqlite3_stmt * <em>stmt</em>, int <em>iCol</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_column_bytes16</span>(sqlite3_stmt * <em>stmt</em>, int <em>iCol</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">double <span class="underline">sqlite3_column_double</span>(sqlite3_stmt * <em>stmt</em>, int <em>iCol</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_column_int</span>(sqlite3_stmt * <em>stmt</em>, int <em>iCol</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">long <span class="underline">sqlite3_column_int64</span>(sqlite3_stmt * <em>stmt</em>, int <em>iCol</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">char* <span class="underline">sqlite3_column_text</span>(sqlite3_stmt * <em>stmt</em>, int <em>iCol</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void* <span class="underline">sqlite3_column_text16</span>(sqlite3_stmt * <em>stmt</em>, int <em>iCol</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_column_type</span>(sqlite3_stmt * <em>stmt</em>, int <em>iCol</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_column_count</span>(sqlite3_stmt * <em>stmt</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">char* <span class="underline">sqlite3_column_database_name</span>(sqlite3_stmt * <em>stmt</em>, int <em>n</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void* <span class="underline">sqlite3_column_database_name16</span>(sqlite3_stmt * <em>stmt</em>, int <em>n</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">char* <span class="underline">sqlite3_column_decltype</span>(sqlite3_stmt * <em>stmt</em>, int <em>i</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void* <span class="underline">sqlite3_column_decltype16</span>(sqlite3_stmt * <em>stmt</em>, int <em>i</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">char* <span class="underline">sqlite3_column_name</span>(sqlite3_stmt * <em>stmt</em>, int <em>n</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void* <span class="underline">sqlite3_column_name16</span>(sqlite3_stmt * <em>stmt</em>, int <em>n</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">char* <span class="underline">sqlite3_column_origin_name</span>(sqlite3_stmt * <em>stmt</em>, int <em>n</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void* <span class="underline">sqlite3_column_origin_name16</span>(sqlite3_stmt * <em>sStmt</em>, int <em>n</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">char* <span class="underline">sqlite3_column_table_name</span>(sqlite3_stmt * <em>stmt</em>, int <em>n</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void* <span class="underline">sqlite3_column_table_name16</span>(sqlite3_stmt * <em>stmt</em>, int <em>n</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">sqlite3_value * <span class="underline">sqlite3_column_value</span>(sqlite3_stmt * <em>stmt</em>, int <em>iCol</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void* <span class="underline">sqlite3_commit_hook</span>(sqlite3 * <em>database</em>, int(* <em>xCallback</em>)(void* <em>args</em>), void* <em>args</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_complete</span>(char* <em>sql</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_complete16</span>(void* <em>sql</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_create_collation</span>(sqlite3 * <em>database</em>, char* <em>zName</em>, int <em>pref16</em>, void* <em>routine</em>, int(* <em>xCompare</em>)(void*, int, void*, int, void*));
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_create_collation16</span>(sqlite3 * <em>database</em>, char* <em>zName</em>, int <em>pref16</em>, void* <em>routine</em>, int(* <em>xCompare</em>)(void*, int, void*, int, void*));
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_create_function</span>(sqlite3 * <em>database</em>, char* <em>zFunctionName</em>, int <em>nArg</em>, int <em>eTextRep</em>, void* <em>pUserData</em>, void(* <em>xFunc</em>)(sqlite3_context *, int, sqlite3_value **), void(* <em>xStep</em>)(sqlite3_context *, int, sqlite3_value **), void(* <em>xFinal</em>)(sqlite3_context *));
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_create_function</span>(sqlite3 * <em>database</em>, void* <em>zFunctionName</em>, int <em>nArg</em>, int <em>eTextRep</em>, void* <em>pUserData</em>, void(* <em>xFunc</em>)(sqlite3_context *, int, sqlite3_value **), void(* <em>xStep</em>)(sqlite3_context *, int, sqlite3_value **), void(* <em>xFinal</em>)(sqlite3_context *));
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_create_module</span>(sqlite3 * <em>db</em>, char* <em>zName</em>, sqlite3_module * <em>methods</em>, void* <em>data</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_data_count</span>(sqlite3_stmt * <em>stmt</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">sqlite3 * <span class="underline">sqlite3_db_handle</span>(sqlite3_stmt * <em>stmt</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_declare_vtab</span>(sqlite3 * <em>db</em>, char* <em>zCreateTable</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_enable_load_extension</span>(sqlite3 * <em>db</em>, int <em>onoff</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_enable_shared_cache</span>(int <em>enable</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_errcode</span>(sqlite3 * <em>db</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">char* <span class="underline">sqlite3_errmsg</span>(sqlite3 * <em>database</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void* <span class="underline">sqlite3_errmsg16</span>(sqlite3 * <em>database</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_exec</span>(sqlite3 * <em>database</em>, char* <em>sql</em>, int(* <em>routine</em>)(void*, int, char**, char**), void* <em>arg</em>, char** <em>errmsg</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_expired</span>(sqlite3_stmt * <em>stmt</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_extended_result_codes</span>(sqlite3 * <em>database</em>, int <em>onoff</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_finalize</span>(sqlite3_stmt * <em>stmt</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">sqlite3_free</span>(char* <em>ptr</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_get_table</span>(sqlite3 * <em>database</em>, char* <em>sql</em>, char*** <em>resultp</em>, int* <em>nrow</em>, int* <em>ncolumn</em>, char** <em>errmsg</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">sqlite3_free_table</span>(char** <em>result</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_get_autocommit</span>(sqlite3 * <em>database</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_global_recover</span>();
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">sqlite3_interrupt</span>(sqlite3 * <em>database</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">long <span class="underline">sqlite3_last_insert_rowid</span>(sqlite3 * <em>database</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">char* <span class="underline">sqlite3_libversion</span>();
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_load_extension</span>(sqlite3 * <em>db</em>, char* <em>zFile</em>, char* <em>zProc</em>, char** <em>ppErrMsg</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void* <span class="underline">sqlite3_malloc</span>(int <em>size</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">char* <span class="underline">sqlite3_mprintf</span>(char* <em>string</em>,...);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">char* <span class="underline">sqlite3_vmprintf</span>(char* <em>string</em>, void* <em>args</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_open</span>(char* <em>filename</em>, sqlite3 ** <em>database</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_open16</span>(void* <em>filename</em>, sqlite3 ** <em>database</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_overload_function</span>(sqlite3 * <em>database</em>, char* <em>zFuncName</em>, int <em>nArg</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_prepare</span>(sqlite3 * <em>database</em>, char* <em>zSql</em>, int <em>nBytes</em>, sqlite3_stmt ** <em>stmt</em>, char** <em>zTail</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_prepare16</span>(sqlite3 * <em>database</em>, void* <em>zSql</em>, int <em>nBytes</em>, sqlite3_stmt ** <em>stmt</em>, void** <em>zTail</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">sqlite3_progress_handler</span>(sqlite3 * <em>database</em>, int <em>n</em>, int(* <em>callback</em>)(void* args), void* <em>arg</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void* <span class="underline">sqlite3_realloc</span>(void* <em>ptr</em>, int <em>size</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_release_memory</span>(int <em>n</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_reset</span>(sqlite3_stmt * <em>stmt</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">sqlite3_reset_auto_extension</span>();
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">sqlite3_result_blob</span>(sqlite3_context * <em>context</em>, void* <em>value</em>, int <em>n</em>, void(* <em>destructor</em>)(void*));
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">sqlite3_result_double</span>(sqlite3_context * <em>context</em>, double <em>value</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">sqlite3_result_error</span>(sqlite3_context * <em>context</em>, char* <em>value</em>, int <em>n</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">sqlite3_result_error16</span>(sqlite3_context * <em>context</em>, void* <em>value</em>, int <em>n</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">sqlite3_result_int</span>(sqlite3_context * <em>context</em>, int <em>value</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">sqlite3_result_int64</span>(sqlite3_context * <em>context</em>, long <em>value</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">sqlite3_result_null</span>(sqlite3_context * <em>context</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">sqlite3_result_text</span>(sqlite3_context * <em>context</em>, char* <em>value</em>, int <em>n</em>, void(* <em>destructor</em>)(void*));
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">sqlite3_result_text16</span>(sqlite3_context * <em>context</em>, void* <em>value</em>, int <em>n</em>, void(* <em>destructor</em>)(void*));
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">sqlite3_result_text16be</span>(sqlite3_context * <em>context</em>, void* <em>value</em>, int <em>n</em>, void(* <em>destructor</em>)(void*));
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">sqlite3_result_text16le</span>(sqlite3_context * <em>context</em>, void* <em>value</em>, int <em>n</em>, void(* <em>destructor</em>)(void*));
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">sqlite3_result_value</span>(sqlite3_context * <em>context</em>, sqlite3_value * <em>value</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void* <span class="underline">sqlite3_rollback_hook</span>(sqlite3 * <em>database</em>, void(* <em>callback</em>)(void*), void* <em>args</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_set_authorizer</span>(sqlite3 * <em>database</em>, int(* <em>xAuth</em>)(void*, int, char*, char*, char*, char*), void* <em>UserData</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_sleep</span>(int <em>ms</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">sqlite3_soft_heap_limit</span>(int <em>n</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_step</span>(sqlite3_stmt * <em>stmt</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_table_column_metadata</span>(sqlite3 * <em>database</em>, char* <em>zDbName</em>, char* <em>zTableName</em>, char* <em>zColumnName</em>, char** <em>zDataType</em>, char** <em>zCollSeq</em>, int* <em>notNull</em>, int* <em>primaryKey</em>, int* <em>autoInc</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void <span class="underline">sqlite3_thread_cleanup</span>();
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_total_changes</span>(sqlite3 * <em>database</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void* <span class="underline">sqlite3_trace</span>(sqlite3 * <em>database</em>, void(* <em>xTrace</em>)(void*, char*), void* <em>args</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_transfer_bindings</span>(sqlite3_stmt * <em>stmt</em>, sqlite3_stmt * <em>stmt</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void* <span class="underline">sqlite3_update_hook</span>(sqlite3 * <em>database</em>, void(* <em>callback</em>)(void*, int, char*, char*, long), void* <em>args</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void* <span class="underline">sqlite3_user_data</span>(sqlite3_context * <em>context</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void* <span class="underline">sqlite3_value_blob</span>(sqlite3_value * <em>value</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_value_bytes</span>(sqlite3_value * <em>value</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_value_bytes16</span>(sqlite3_value * <em>value</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">double <span class="underline">sqlite3_value_double</span>(sqlite3_value * <em>value</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_value_int</span>(sqlite3_value * <em>value</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">long <span class="underline">sqlite3_value_int64</span>(sqlite3_value * <em>value</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">char* <span class="underline">sqlite3_value_text</span>(sqlite3_value * <em>value</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void* <span class="underline">sqlite3_value_text16</span>(sqlite3_value * <em>value</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void* <span class="underline">sqlite3_value_text16be</span>(sqlite3_value * <em>value</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">void* <span class="underline">sqlite3_value_text16le</span>(sqlite3_value * <em>value</em>);
</span></dt>
<dd><br /><br />
</dd>
<dt><span class="big">int <span class="underline">sqlite3_value_type</span>(sqlite3_value * <em>value</em>);
</span></dt>
<dd><br /><br />
</dd>
</dl>

<hr />
<p><span class="small">Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. BSD license
 
</span></p>
</body>
</html>
