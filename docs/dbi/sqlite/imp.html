<html><head>
	<META http-equiv="content-type" content="text/html; charset=utf-8">
	<title>dbi.sqlite.imp</title>
	</head><body>
	<h1>dbi.sqlite.imp</h1>
	<!-- Generated by Ddoc from dbi\sqlite\imp.d -->
SQLite import library.
 Part of the D DBI project.
<br><br>
SQLite version 3.3.6
 Import library version 0.02

<br><br>
<b>Authors:</b><br>
The D DBI project

<br><br>

<dl><dt><big>struct <u>sqlite3</u>;
</big></dt>
<dd><br><br>
<dl></dl>
</dd>
<dt><big>struct <u>sqlite3_context</u>;
</big></dt>
<dd><br><br>
<dl></dl>
</dd>
<dt><big>struct <u>sqlite3_stmt</u>;
</big></dt>
<dd><br><br>
<dl></dl>
</dd>
<dt><big>struct <u>sqlite3_value</u>;
</big></dt>
<dd><br><br>
<dl></dl>
</dd>
<dt><big>alias <u>sqlite_callback</u>;
</big></dt>
<dd><br><br>
</dd>
<dt><big>const uint <u>SQLITE_OK</u>;
</big></dt>
<dd>Successful result.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_ERROR</u>;
</big></dt>
<dd>SQL error or missing database.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_INTERNAL</u>;
</big></dt>
<dd>An internal logic error in SQLite.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_PERM</u>;
</big></dt>
<dd>Access permission denied.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_ABORT</u>;
</big></dt>
<dd>Callback routine requested an abort.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_BUSY</u>;
</big></dt>
<dd>The database file is locked.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_LOCKED</u>;
</big></dt>
<dd>A table in the database is locked.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_NOMEM</u>;
</big></dt>
<dd>A malloc() failed.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_READONLY</u>;
</big></dt>
<dd>Attempt to write a readonly database.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_INTERRUPT</u>;
</big></dt>
<dd>Operation terminated by sqlite_interrupt().
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_IOERR</u>;
</big></dt>
<dd>Some kind of disk I/O error occurred.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_CORRUPT</u>;
</big></dt>
<dd>The database disk image is malformed.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_NOTFOUND</u>;
</big></dt>
<dd>(Internal Only) Table or record not found.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_FULL</u>;
</big></dt>
<dd>Insertion failed because database is full.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_CANTOPEN</u>;
</big></dt>
<dd>Unable to open the database file.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_PROTOCOL</u>;
</big></dt>
<dd>Database lock protocol error.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_EMPTY</u>;
</big></dt>
<dd>(Internal Only) Database table is empty.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_SCHEMA</u>;
</big></dt>
<dd>The database schema changed.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_TOOBIG</u>;
</big></dt>
<dd>Too much data for one row of a table.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_CONSTRAINT</u>;
</big></dt>
<dd>Abort due to constraint violation.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_MISMATCH</u>;
</big></dt>
<dd>Data type mismatch.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_MISUSE</u>;
</big></dt>
<dd>Library used incorrectly.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_NOLFS</u>;
</big></dt>
<dd>Uses OS features not supported on host.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_AUTH</u>;
</big></dt>
<dd>Authorization denied.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_ROW</u>;
</big></dt>
<dd>sqlite_step() has another row ready.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_DONE</u>;
</big></dt>
<dd>sqlite_step() has finished executing.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_UTF8</u>;
</big></dt>
<dd>The text is in UTF8 format.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_UTF16BE</u>;
</big></dt>
<dd>The text is in UTF16 big endian format.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_UTF16LE</u>;
</big></dt>
<dd>The text is in UTF16 little endian format.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_UTF16</u>;
</big></dt>
<dd>The text is in UTF16 format.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_ANY</u>;
</big></dt>
<dd>The text is in some format or another.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_INTEGER</u>;
</big></dt>
<dd>The data value is an integer.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_FLOAT</u>;
</big></dt>
<dd>The data value is a float.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_TEXT</u>;
</big></dt>
<dd>The data value is text.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_BLOB</u>;
</big></dt>
<dd>The data value is a blob.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_NULL</u>;
</big></dt>
<dd>The data value is null.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_DENY</u>;
</big></dt>
<dd>Abort the SQL statement with an error.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_IGNORE</u>;
</big></dt>
<dd>Don't allow access, but don't generate an error.
<br><br>

</dd>
<dt><big>const void(* <u>SQLITE_STATIC</u>)(void*);
</big></dt>
<dd>The data doesn't need to be freed by SQLite.  
<br><br>

</dd>
<dt><big>const void(* <u>SQLITE_TRANSIENT</u>)(void*);
</big></dt>
<dd>SQLite should make a private copy of the data.
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_CREATE_INDEX</u>;
</big></dt>
<dd>Index Name		Table Name
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_CREATE_TABLE</u>;
</big></dt>
<dd>Table Name		NULL
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_CREATE_TEMP_INDEX</u>;
</big></dt>
<dd>Index Name		Table Name
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_CREATE_TEMP_TABLE</u>;
</big></dt>
<dd>Table Name		NULL
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_CREATE_TEMP_TRIGGER</u>;
</big></dt>
<dd>Trigger Name	Table Name
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_CREATE_TEMP_VIEW</u>;
</big></dt>
<dd>View Name		NULL
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_CREATE_TRIGGER</u>;
</big></dt>
<dd>Trigger Name	Table Name
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_CREATE_VIEW</u>;
</big></dt>
<dd>View Name		NULL
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_DELETE</u>;
</big></dt>
<dd>Table Name		NULL
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_DROP_INDEX</u>;
</big></dt>
<dd>Index Name		Table Name
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_DROP_TABLE</u>;
</big></dt>
<dd>Table Name		NULL
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_DROP_TEMP_INDEX</u>;
</big></dt>
<dd>Index Name		Table Name
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_DROP_TEMP_TABLE</u>;
</big></dt>
<dd>Table Name		NULL
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_DROP_TEMP_TRIGGER</u>;
</big></dt>
<dd>Trigger Name	Table Name
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_DROP_TEMP_VIEW</u>;
</big></dt>
<dd>View Name		NULL
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_DROP_TRIGGER</u>;
</big></dt>
<dd>Trigger Name	Table Name
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_DROP_VIEW</u>;
</big></dt>
<dd>View Name		NULL
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_INSERT</u>;
</big></dt>
<dd>Table Name		NULL
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_PRAGMA</u>;
</big></dt>
<dd>Pragma Name		1st arg or NULL
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_READ</u>;
</big></dt>
<dd>Table Name		Column Name
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_SELECT</u>;
</big></dt>
<dd>NULL		NULL
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_TRANSACTION</u>;
</big></dt>
<dd>NULL		NULL
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_UPDATE</u>;
</big></dt>
<dd>Table Name		Column Name
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_ATTACH</u>;
</big></dt>
<dd>Filename		NULL
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_DETACH</u>;
</big></dt>
<dd>Database Name	NULL
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_ALTER_TABLE</u>;
</big></dt>
<dd>Database Name	Table Name
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_REINDEX</u>;
</big></dt>
<dd>Index Name		NULL
<br><br>

</dd>
<dt><big>const uint <u>SQLITE_ANALYZE</u>;
</big></dt>
<dd>Table Name		NULL
<br><br>

</dd>
<dt><big>void* <u>sqlite3_aggregate_context</u>(sqlite3_context * <i>ctx</i>, int <i>nBytes</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>deprecated int <u>sqlite3_aggregate_count</u>(sqlite3_context * <i>ctx</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_bind_blob</u>(sqlite3_stmt * <i>stmt</i>, int <i>index</i>, void* <i>value</i>, int <i>n</i>, void(* <i>destructor</i>)(void*));
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_bind_double</u>(sqlite3_stmt * <i>stmt</i>, int <i>index</i>, double <i>value</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_bind_int</u>(sqlite3_stmt * <i>stmt</i>, int <i>index</i>, int <i>value</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_bind_int64</u>(sqlite3_stmt * <i>stmt</i>, int <i>index</i>, long <i>value</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_bind_null</u>(sqlite3_stmt * <i>stmt</i>, int <i>index</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_bind_text</u>(sqlite3_stmt * <i>stmt</i>, int <i>index</i>, char* <i>value</i>, int <i>n</i>, void(* <i>destructor</i>)(void*));
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_bind_text16</u>(sqlite3_stmt * <i>stmt</i>, int <i>index</i>, void* <i>value</i>, int <i>n</i>, void(* <i>destructor</i>)(void*));
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_bind_parameter_count</u>(sqlite3_stmt * <i>stmt</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_bind_parameter_index</u>(sqlite3_stmt * <i>stmt</i>, char* <i>zName</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>char* <u>sqlite3_bind_parameter_name</u>(sqlite3_stmt * <i>stmt</i>, int <i>n</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_busy_handler</u>(sqlite3 * <i>database</i>, int(* <i>handler</i>)(void*, int), void* <i>n</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_busy_timeout</u>(sqlite3 * <i>database</i>, int <i>ms</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_changes</u>(sqlite3 * <i>database</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_clear_bindings</u>(sqlite3_stmt * <i>statement</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_close</u>(sqlite3 * <i>database</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_collation_needed</u>(sqlite3 * <i>database</i>, void* <i>names</i>, void(*)(void* <i>names</i>, sqlite3 * <i>database</i>, int eTextRep, char* sequence));
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_collation_needed</u>(sqlite3 * <i>database</i>, void* <i>names</i>, void(*)(void* <i>names</i>, sqlite3 * <i>database</i>, int eTextRep, void* sequence));
</big></dt>
<dd><br><br>
</dd>
<dt><big>void* <u>sqlite3_column_blob</u>(sqlite3_stmt * <i>stmt</i>, int <i>iCol</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_column_bytes</u>(sqlite3_stmt * <i>stmt</i>, int <i>iCol</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_column_bytes16</u>(sqlite3_stmt * <i>stmt</i>, int <i>iCol</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>double <u>sqlite3_column_double</u>(sqlite3_stmt * <i>stmt</i>, int <i>iCol</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_column_int</u>(sqlite3_stmt * <i>stmt</i>, int <i>iCol</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>long <u>sqlite3_column_int64</u>(sqlite3_stmt * <i>stmt</i>, int <i>iCol</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>char* <u>sqlite3_column_text</u>(sqlite3_stmt * <i>stmt</i>, int <i>iCol</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void* <u>sqlite3_column_text16</u>(sqlite3_stmt * <i>stmt</i>, int <i>iCol</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_column_type</u>(sqlite3_stmt * <i>stmt</i>, int <i>iCol</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_column_count</u>(sqlite3_stmt * <i>stmt</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>char* <u>sqlite3_column_database_name</u>(sqlite3_stmt * <i>stmt</i>, int <i>n</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void* <u>sqlite3_column_database_name16</u>(sqlite3_stmt * <i>stmt</i>, int <i>n</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>char* <u>sqlite3_column_decltype</u>(sqlite3_stmt * <i>stmt</i>, int <i>i</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void* <u>sqlite3_column_decltype16</u>(sqlite3_stmt * <i>stmt</i>, int <i>i</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>char* <u>sqlite3_column_name</u>(sqlite3_stmt * <i>stmt</i>, int <i>n</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void* <u>sqlite3_column_name16</u>(sqlite3_stmt * <i>stmt</i>, int <i>n</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>char* <u>sqlite3_column_origin_name</u>(sqlite3_stmt * <i>stmt</i>, int <i>n</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void* <u>sqlite3_column_origin_name16</u>(sqlite3_stmt * <i>sStmt</i>, int <i>n</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>char* <u>sqlite3_column_table_name</u>(sqlite3_stmt * <i>stmt</i>, int <i>n</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void* <u>sqlite3_column_table_name16</u>(sqlite3_stmt * <i>stmt</i>, int <i>n</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void* <u>sqlite3_commit_hook</u>(sqlite3 * <i>database</i>, int(* <i>xCallback</i>)(void* <i>args</i>), void* <i>args</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_complete</u>(char* <i>sql</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_complete16</u>(void* <i>sql</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_create_collation</u>(sqlite3 * <i>database</i>, char* <i>zName</i>, int <i>pref16</i>, void* <i>routine</i>, int(* <i>xCompare</i>)(void*, int, void*, int, void*));
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_create_collation16</u>(sqlite3 * <i>database</i>, char* <i>zName</i>, int <i>pref16</i>, void* <i>routine</i>, int(* <i>xCompare</i>)(void*, int, void*, int, void*));
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_create_function</u>(sqlite3 * <i>database</i>, char* <i>zFunctionName</i>, int <i>nArg</i>, int <i>eTextRep</i>, void* <i>pUserData</i>, void(* <i>xFunc</i>)(sqlite3_context *, int, sqlite3_value **), void(* <i>xStep</i>)(sqlite3_context *, int, sqlite3_value **), void(* <i>xFinal</i>)(sqlite3_context *));
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_create_function</u>(sqlite3 * <i>database</i>, void* <i>zFunctionName</i>, int <i>nArg</i>, int <i>eTextRep</i>, void* <i>pUserData</i>, void(* <i>xFunc</i>)(sqlite3_context *, int, sqlite3_value **), void(* <i>xStep</i>)(sqlite3_context *, int, sqlite3_value **), void(* <i>xFinal</i>)(sqlite3_context *));
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_data_count</u>(sqlite3_stmt * <i>stmt</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>sqlite3 * <u>sqlite3_db_handle</u>(sqlite3_stmt * <i>stmt</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_enable_shared_cache</u>(int <i>enable</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_errcode</u>(sqlite3 * <i>db</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>char* <u>sqlite3_errmsg</u>(sqlite3 * <i>database</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void* <u>sqlite3_errmsg16</u>(sqlite3 * <i>database</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_exec</u>(sqlite3 * <i>database</i>, char* <i>sql</i>, int(* <i>routine</i>)(void*, int, char**, char**), void* <i>arg</i>, char** <i>errmsg</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_expired</u>(sqlite3_stmt * <i>stmt</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_finalize</u>(sqlite3_stmt * <i>stmt</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void <u>sqlite3_free</u>(char* <i>z</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_get_table</u>(sqlite3 * <i>database</i>, char* <i>sql</i>, char*** <i>resultp</i>, int* <i>nrow</i>, int* <i>ncolumn</i>, char** <i>errmsg</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void <u>sqlite3_free_table</u>(char** <i>result</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_get_autocommit</u>(sqlite3 * <i>database</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_global_recover</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big>void <u>sqlite3_interrupt</u>(sqlite3 * <i>database</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>long <u>sqlite3_last_insert_rowid</u>(sqlite3 * <i>database</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>char* <u>sqlite3_libversion</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big>char* <u>sqlite3_mprintf</u>(char* <i>string</i>,...);
</big></dt>
<dd><br><br>
</dd>
<dt><big>char* <u>sqlite3_vmprintf</u>(char* <i>string</i>, void* <i>args</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_open</u>(char* <i>filename</i>, sqlite3 ** <i>database</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_open16</u>(void* <i>filename</i>, sqlite3 ** <i>database</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_prepare</u>(sqlite3 * <i>database</i>, char* <i>zSql</i>, int <i>nBytes</i>, sqlite3_stmt ** <i>stmt</i>, char** <i>zTail</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_prepare16</u>(sqlite3 * <i>database</i>, void* <i>zSql</i>, int <i>nBytes</i>, sqlite3_stmt ** <i>stmt</i>, void** <i>zTail</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void <u>sqlite3_progress_handler</u>(sqlite3 * <i>database</i>, int <i>n</i>, int(* <i>callback</i>)(void* args), void* <i>arg</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_release_memory</u>(int <i>n</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_reset</u>(sqlite3_stmt * <i>stmt</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void <u>sqlite3_result_blob</u>(sqlite3_context * <i>context</i>, void* <i>value</i>, int <i>n</i>, void(* <i>destructor</i>)(void*));
</big></dt>
<dd><br><br>
</dd>
<dt><big>void <u>sqlite3_result_double</u>(sqlite3_context * <i>context</i>, double <i>value</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void <u>sqlite3_result_error</u>(sqlite3_context * <i>context</i>, char* <i>value</i>, int <i>n</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void <u>sqlite3_result_error16</u>(sqlite3_context * <i>context</i>, void* <i>value</i>, int <i>n</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void <u>sqlite3_result_int</u>(sqlite3_context * <i>context</i>, int <i>value</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void <u>sqlite3_result_int64</u>(sqlite3_context * <i>context</i>, long <i>value</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void <u>sqlite3_result_null</u>(sqlite3_context * <i>context</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void <u>sqlite3_result_text</u>(sqlite3_context * <i>context</i>, char* <i>value</i>, int <i>n</i>, void(* <i>destructor</i>)(void*));
</big></dt>
<dd><br><br>
</dd>
<dt><big>void <u>sqlite3_result_text16</u>(sqlite3_context * <i>context</i>, void* <i>value</i>, int <i>n</i>, void(* <i>destructor</i>)(void*));
</big></dt>
<dd><br><br>
</dd>
<dt><big>void <u>sqlite3_result_text16be</u>(sqlite3_context * <i>context</i>, void* <i>value</i>, int <i>n</i>, void(* <i>destructor</i>)(void*));
</big></dt>
<dd><br><br>
</dd>
<dt><big>void <u>sqlite3_result_text16le</u>(sqlite3_context * <i>context</i>, void* <i>value</i>, int <i>n</i>, void(* <i>destructor</i>)(void*));
</big></dt>
<dd><br><br>
</dd>
<dt><big>void <u>sqlite3_result_value</u>(sqlite3_context * <i>context</i>, sqlite3_value * <i>value</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void* <u>sqlite3_rollback_hook</u>(sqlite3 * <i>database</i>, void(* <i>callback</i>)(void*), void* <i>args</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_set_authorizer</u>(sqlite3 * <i>database</i>, int(* <i>xAuth</i>)(void*, int, char*, char*, char*, char*), void* <i>UserData</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_sleep</u>(int <i>ms</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void <u>sqlite3_soft_heap_limit</u>(int <i>n</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_step</u>(sqlite3_stmt * <i>stmt</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_table_column_metadata</u>(sqlite3 * <i>database</i>, char* <i>zDbName</i>, char* <i>zTableName</i>, char* <i>zColumnName</i>, char** <i>zDataType</i>, char** <i>zCollSeq</i>, int* <i>notNull</i>, int* <i>primaryKey</i>, int* <i>autoInc</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void <u>sqlite3_thread_cleanup</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_total_changes</u>(sqlite3 * <i>database</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void* <u>sqlite3_trace</u>(sqlite3 * <i>database</i>, void(* <i>xTrace</i>)(void*, char*), void* <i>args</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_transfer_bindings</u>(sqlite3_stmt * <i>stmt</i>, sqlite3_stmt * <i>stmt</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void* <u>sqlite3_update_hook</u>(sqlite3 * <i>database</i>, void(* <i>callback</i>)(void*, int, char*, char*, long), void* <i>args</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void* <u>sqlite3_user_data</u>(sqlite3_context * <i>context</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void* <u>sqlite3_value_blob</u>(sqlite3_value * <i>value</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_value_bytes</u>(sqlite3_value * <i>value</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_value_bytes16</u>(sqlite3_value * <i>value</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>double <u>sqlite3_value_double</u>(sqlite3_value * <i>value</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_value_int</u>(sqlite3_value * <i>value</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>long <u>sqlite3_value_int64</u>(sqlite3_value * <i>value</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>char* <u>sqlite3_value_text</u>(sqlite3_value * <i>value</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void* <u>sqlite3_value_text16</u>(sqlite3_value * <i>value</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void* <u>sqlite3_value_text16be</u>(sqlite3_value * <i>value</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>void* <u>sqlite3_value_text16le</u>(sqlite3_value * <i>value</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big>int <u>sqlite3_value_type</u>(sqlite3_value * <i>value</i>);
</big></dt>
<dd><br><br>
</dd>
</dl>

	<hr><small>Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. BSD license
 
</small>
	</body></html>
